!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing aclocal-1.16$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ADD	FunctorOps.h	/^    ADD,   \/\/ addition$/;"	m	class:souffle::FunctorOp
ALL	EquivalenceRelation.h	/^        enum IterType { ALL, ANTERIOR, ANTPOST, WITHIN };$/;"	e	enum:souffle::EquivalenceRelation::iterator::IterType
ALLOCA	Makefile	/^ALLOCA = $/;"	m
AMTAR	Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_COLOR_TESTS	Makefile	/^AM_COLOR_TESTS = always$/;"	m
AM_DEFAULT_VERBOSITY	Makefile	/^AM_DEFAULT_VERBOSITY = 1$/;"	m
AM_RECURSIVE_TARGETS	Makefile	/^AM_RECURSIVE_TARGETS = check recheck$/;"	m
AM_V_CC	Makefile	/^AM_V_CC = $(am__v_CC_$(V))$/;"	m
AM_V_CCLD	Makefile	/^AM_V_CCLD = $(am__v_CCLD_$(V))$/;"	m
AM_V_CXX	Makefile	/^AM_V_CXX = $(am__v_CXX_$(V))$/;"	m
AM_V_CXXLD	Makefile	/^AM_V_CXXLD = $(am__v_CXXLD_$(V))$/;"	m
AM_V_GEN	Makefile	/^AM_V_GEN = $(am__v_GEN_$(V))$/;"	m
AM_V_P	Makefile	/^AM_V_P = $(am__v_P_$(V))$/;"	m
AM_V_at	Makefile	/^AM_V_at = $(am__v_at_$(V))$/;"	m
AM_V_lt	Makefile	/^AM_V_lt = $(am__v_lt_$(V))$/;"	m
ANTERIOR	EquivalenceRelation.h	/^        enum IterType { ALL, ANTERIOR, ANTPOST, WITHIN };$/;"	e	enum:souffle::EquivalenceRelation::iterator::IterType
ANTPOST	EquivalenceRelation.h	/^        enum IterType { ALL, ANTERIOR, ANTPOST, WITHIN };$/;"	e	enum:souffle::EquivalenceRelation::iterator::IterType
AR	Makefile	/^AR = ar$/;"	m
ARRAY	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
AS	parser.hh	/^        AS = 300,$/;"	e	enum:yy::parser::token::yytokentype
ASSERT_LE	test/test.h	/^#define ASSERT_LE(/;"	d
ASSERT_TRUE	test/test.h	/^#define ASSERT_TRUE(/;"	d
AT	parser.hh	/^        AT = 318,$/;"	e	enum:yy::parser::token::yytokentype
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing autoheader$/;"	m
AUTOM4TE	Makefile	/^AUTOM4TE = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing autom4te$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing automake-1.16$/;"	m
AWK	Makefile	/^AWK = awk$/;"	m
AdornedClause	MagicSet.h	/^    AdornedClause(AstClause* clause, std::string headAdornment, std::vector<std::string> bodyAdornment,$/;"	f	class:souffle::AdornedClause
AdornedClause	MagicSet.h	/^class AdornedClause {$/;"	c	namespace:souffle
AdornedPredicate	MagicSet.h	/^    AdornedPredicate(AstRelationIdentifier name, std::string adornment)$/;"	f	class:souffle::AdornedPredicate
AdornedPredicate	MagicSet.h	/^class AdornedPredicate {$/;"	c	namespace:souffle
Adornment	MagicSet.h	/^class Adornment : public AstAnalysis {$/;"	c	namespace:souffle
Assignment	Constraints.h	/^    Assignment() : bottom(bottom_factory_type()()) {}$/;"	f	class:souffle::Assignment
Assignment	Constraints.h	/^class Assignment {$/;"	c	namespace:souffle
AstAggregator	AstArgument.h	/^    AstAggregator(Op fun) : fun(fun), expr(nullptr) {}$/;"	f	class:souffle::AstAggregator
AstAggregator	AstArgument.h	/^class AstAggregator : public AstArgument {$/;"	c	namespace:souffle
AstAnalysis	AstAnalysis.h	/^class AstAnalysis {$/;"	c	namespace:souffle
AstArgument	AstArgument.h	/^class AstArgument : public AstNode {$/;"	c	namespace:souffle
AstAtom	AstLiteral.h	/^    AstAtom(AstRelationIdentifier name = AstRelationIdentifier()) : name(std::move(name)) {}$/;"	f	class:souffle::AstAtom
AstAtom	AstLiteral.h	/^class AstAtom : public AstLiteral {$/;"	c	namespace:souffle
AstAttribute	AstAttribute.h	/^    AstAttribute(std::string n, AstTypeIdentifier t, const Type* \/*type*\/ = nullptr)$/;"	f	class:souffle::AstAttribute
AstAttribute	AstAttribute.h	/^class AstAttribute : public AstNode {$/;"	c	namespace:souffle
AstBinaryConstraint	AstLiteral.h	/^    AstBinaryConstraint($/;"	f	class:souffle::AstBinaryConstraint
AstBinaryConstraint	AstLiteral.h	/^class AstBinaryConstraint : public AstConstraint {$/;"	c	namespace:souffle
AstBooleanConstraint	AstLiteral.h	/^    AstBooleanConstraint(bool truthValue) : truthValue(truthValue) {}$/;"	f	class:souffle::AstBooleanConstraint
AstBooleanConstraint	AstLiteral.h	/^class AstBooleanConstraint : public AstConstraint {$/;"	c	namespace:souffle
AstClause	AstClause.h	/^    AstClause() : head(nullptr), plan(nullptr) {}$/;"	f	class:souffle::AstClause
AstClause	AstClause.h	/^class AstClause : public AstNode {$/;"	c	namespace:souffle
AstComponent	AstComponent.h	/^class AstComponent : public AstNode {$/;"	c	namespace:souffle
AstComponentChecker	AstComponentChecker.h	/^class AstComponentChecker : public AstTransformer {$/;"	c	namespace:souffle
AstComponentInit	AstComponent.h	/^class AstComponentInit : public AstNode {$/;"	c	namespace:souffle
AstComponentType	AstComponent.h	/^    AstComponentType($/;"	f	class:souffle::AstComponentType
AstComponentType	AstComponent.h	/^class AstComponentType : public AstNode {$/;"	c	namespace:souffle
AstConstant	AstArgument.h	/^    AstConstant(AstDomain i) : AstArgument(), idx(i) {}$/;"	f	class:souffle::AstConstant
AstConstant	AstArgument.h	/^class AstConstant : public AstArgument {$/;"	c	namespace:souffle
AstConstraint	AstLiteral.h	/^class AstConstraint : public AstLiteral {$/;"	c	namespace:souffle
AstConstraintAnalysis	AstConstraintAnalysis.h	/^class AstConstraintAnalysis : public AstVisitor<void> {$/;"	c	namespace:souffle::__anon68
AstConstraintAnalysisVar	AstConstraintAnalysis.h	/^    explicit AstConstraintAnalysisVar(const AstArgument& arg)$/;"	f	struct:souffle::__anon68::AstConstraintAnalysisVar
AstConstraintAnalysisVar	AstConstraintAnalysis.h	/^    explicit AstConstraintAnalysisVar(const AstArgument* arg)$/;"	f	struct:souffle::__anon68::AstConstraintAnalysisVar
AstConstraintAnalysisVar	AstConstraintAnalysis.h	/^struct AstConstraintAnalysisVar : public Variable<const AstArgument*, PropertySpace> {$/;"	s	namespace:souffle::__anon68
AstCounter	AstArgument.h	/^    AstCounter() : AstArgument() {}$/;"	f	class:souffle::AstCounter
AstCounter	AstArgument.h	/^class AstCounter : public AstArgument {$/;"	c	namespace:souffle
AstExecutionOrder	AstClause.h	/^class AstExecutionOrder : public AstNode {$/;"	c	namespace:souffle
AstExecutionPlan	AstClause.h	/^class AstExecutionPlan : public AstNode {$/;"	c	namespace:souffle
AstExecutionPlanChecker	AstSemanticChecker.h	/^class AstExecutionPlanChecker : public AstTransformer {$/;"	c	namespace:souffle
AstFunctor	AstArgument.h	/^class AstFunctor : public AstArgument {};$/;"	c	namespace:souffle
AstFunctorDeclaration	AstFunctorDeclaration.h	/^    AstFunctorDeclaration(const std::string& name, const std::string& type) : name(name), type(type) {$/;"	f	class:souffle::AstFunctorDeclaration
AstFunctorDeclaration	AstFunctorDeclaration.h	/^class AstFunctorDeclaration : public AstNode {$/;"	c	namespace:souffle
AstIO	AstIO.h	/^    AstIO(const AstIO& io) : names(io.names), kvps(io.kvps) {}$/;"	f	class:souffle::AstIO
AstIO	AstIO.h	/^class AstIO : public AstNode {$/;"	c	namespace:souffle
AstIntrinsicFunctor	AstArgument.h	/^    AstIntrinsicFunctor(FunctorOp function, Operands... operands) : function(function) {$/;"	f	class:souffle::AstIntrinsicFunctor
AstIntrinsicFunctor	AstArgument.h	/^    AstIntrinsicFunctor(FunctorOp function, std::vector<std::unique_ptr<AstArgument>> operands)$/;"	f	class:souffle::AstIntrinsicFunctor
AstIntrinsicFunctor	AstArgument.h	/^class AstIntrinsicFunctor : public AstFunctor {$/;"	c	namespace:souffle
AstLiteral	AstLiteral.h	/^class AstLiteral : public AstNode {$/;"	c	namespace:souffle
AstLoad	AstIO.h	/^    AstLoad(const AstIO& io) : AstIO(io) {$/;"	f	class:souffle::AstLoad
AstLoad	AstIO.h	/^class AstLoad : public AstIO {$/;"	c	namespace:souffle
AstNameComparison	AstRelation.h	/^struct AstNameComparison {$/;"	s	namespace:souffle
AstNegation	AstLiteral.h	/^    AstNegation(std::unique_ptr<AstAtom> atom) : atom(std::move(atom)) {}$/;"	f	class:souffle::AstNegation
AstNegation	AstLiteral.h	/^class AstNegation : public AstLiteral {$/;"	c	namespace:souffle
AstNode	AstNode.h	/^class AstNode {$/;"	c	namespace:souffle
AstNodeMapper	AstNode.h	/^class AstNodeMapper {$/;"	c	namespace:souffle
AstNullConstant	AstArgument.h	/^    AstNullConstant() : AstConstant(0) {}$/;"	f	class:souffle::AstNullConstant
AstNullConstant	AstArgument.h	/^class AstNullConstant : public AstConstant {$/;"	c	namespace:souffle
AstNumberConstant	AstArgument.h	/^    AstNumberConstant(AstDomain num) : AstConstant(num) {}$/;"	f	class:souffle::AstNumberConstant
AstNumberConstant	AstArgument.h	/^class AstNumberConstant : public AstConstant {$/;"	c	namespace:souffle
AstPragma	AstPragma.h	/^    AstPragma(std::string k, std::string v) : key(std::move(k)), value(std::move(v)) {}$/;"	f	class:souffle::AstPragma
AstPragma	AstPragma.h	/^class AstPragma : public AstNode {$/;"	c	namespace:souffle
AstPragmaChecker	AstPragma.h	/^class AstPragmaChecker : public AstTransformer {$/;"	c	namespace:souffle
AstPrimitiveType	AstType.h	/^    AstPrimitiveType(const AstTypeIdentifier& name, bool num = false) : AstType(name), num(num) {}$/;"	f	class:souffle::AstPrimitiveType
AstPrimitiveType	AstType.h	/^class AstPrimitiveType : public AstType {$/;"	c	namespace:souffle
AstPrintSize	AstIO.h	/^    AstPrintSize() {$/;"	f	class:souffle::AstPrintSize
AstPrintSize	AstIO.h	/^    AstPrintSize(const AstIO& io) : AstStore(io) {$/;"	f	class:souffle::AstPrintSize
AstPrintSize	AstIO.h	/^class AstPrintSize : public AstStore {$/;"	c	namespace:souffle
AstProfileUse	AstProfileUse.h	/^    AstProfileUse() : programRun(std::make_shared<profile::ProgramRun>(profile::ProgramRun())) {}$/;"	f	class:souffle::AstProfileUse
AstProfileUse	AstProfileUse.h	/^class AstProfileUse : public AstAnalysis {$/;"	c	namespace:souffle
AstProgram	AstProgram.h	/^class AstProgram : public AstNode {$/;"	c	namespace:souffle
AstProvenanceNegation	AstLiteral.h	/^    AstProvenanceNegation(std::unique_ptr<AstAtom> atom) : atom(std::move(atom)) {}$/;"	f	class:souffle::AstProvenanceNegation
AstProvenanceNegation	AstLiteral.h	/^class AstProvenanceNegation : public AstLiteral {$/;"	c	namespace:souffle
AstRecordInit	AstArgument.h	/^class AstRecordInit : public AstArgument {$/;"	c	namespace:souffle
AstRecordType	AstType.h	/^class AstRecordType : public AstType {$/;"	c	namespace:souffle
AstRelation	AstRelation.h	/^class AstRelation : public AstNode {$/;"	c	namespace:souffle
AstRelationIdentifier	AstRelationIdentifier.h	/^    AstRelationIdentifier(const char* name) : AstRelationIdentifier(std::string(name)) {}$/;"	f	class:souffle::AstRelationIdentifier
AstRelationIdentifier	AstRelationIdentifier.h	/^    AstRelationIdentifier(const std::string& name = "") : names(toVector(name)) {}$/;"	f	class:souffle::AstRelationIdentifier
AstRelationIdentifier	AstRelationIdentifier.h	/^class AstRelationIdentifier {$/;"	c	namespace:souffle
AstSemanticChecker	AstSemanticChecker.h	/^class AstSemanticChecker : public AstTransformer {$/;"	c	namespace:souffle
AstStore	AstIO.h	/^    AstStore(const AstIO& io) : AstIO(io) {$/;"	f	class:souffle::AstStore
AstStore	AstIO.h	/^class AstStore : public AstIO {$/;"	c	namespace:souffle
AstStringConstant	AstArgument.h	/^    AstStringConstant(SymbolTable& symTable, const std::string& c)$/;"	f	class:souffle::AstStringConstant
AstStringConstant	AstArgument.h	/^    AstStringConstant(SymbolTable& symTable, size_t index) : AstConstant(index), symTable(symTable) {}$/;"	f	class:souffle::AstStringConstant
AstStringConstant	AstArgument.h	/^class AstStringConstant : public AstConstant {$/;"	c	namespace:souffle
AstSubroutineArgument	AstArgument.h	/^    AstSubroutineArgument(size_t n) : AstArgument(), number(n) {}$/;"	f	class:souffle::AstSubroutineArgument
AstSubroutineArgument	AstArgument.h	/^class AstSubroutineArgument : public AstArgument {$/;"	c	namespace:souffle
AstTransformer	AstTransformer.h	/^class AstTransformer {$/;"	c	namespace:souffle
AstTranslationUnit	AstTranslationUnit.h	/^    AstTranslationUnit(std::unique_ptr<AstProgram> program, SymbolTable& s, ErrorReport& e, DebugReport& d,$/;"	f	class:souffle::AstTranslationUnit
AstTranslationUnit	AstTranslationUnit.h	/^class AstTranslationUnit {$/;"	c	namespace:souffle
AstTranslator	AstTranslator.h	/^class AstTranslator {$/;"	c	namespace:souffle
AstType	AstType.h	/^    AstType(AstTypeIdentifier name = {""}) : name(std::move(name)) {}$/;"	f	class:souffle::AstType
AstType	AstType.h	/^class AstType : public AstNode {$/;"	c	namespace:souffle
AstTypeCast	AstArgument.h	/^    AstTypeCast(std::unique_ptr<AstArgument> value, std::string type)$/;"	f	class:souffle::AstTypeCast
AstTypeCast	AstArgument.h	/^class AstTypeCast : public AstArgument {$/;"	c	namespace:souffle
AstTypeIdentifier	AstType.h	/^    AstTypeIdentifier() : names() {}$/;"	f	class:souffle::AstTypeIdentifier
AstTypeIdentifier	AstType.h	/^    AstTypeIdentifier(const char* name) : AstTypeIdentifier(std::string(name)) {}$/;"	f	class:souffle::AstTypeIdentifier
AstTypeIdentifier	AstType.h	/^    AstTypeIdentifier(const std::string& name) : names({name}) {}$/;"	f	class:souffle::AstTypeIdentifier
AstTypeIdentifier	AstType.h	/^class AstTypeIdentifier {$/;"	c	namespace:souffle
AstUnionType	AstType.h	/^class AstUnionType : public AstType {$/;"	c	namespace:souffle
AstUnnamedVariable	AstArgument.h	/^    AstUnnamedVariable() : AstArgument() {}$/;"	f	class:souffle::AstUnnamedVariable
AstUnnamedVariable	AstArgument.h	/^class AstUnnamedVariable : public AstArgument {$/;"	c	namespace:souffle
AstUserDefinedFunctor	AstArgument.h	/^    AstUserDefinedFunctor(std::string name) : name(std::move(name)) {}$/;"	f	class:souffle::AstUserDefinedFunctor
AstUserDefinedFunctor	AstArgument.h	/^class AstUserDefinedFunctor : public AstFunctor {$/;"	c	namespace:souffle
AstVariable	AstArgument.h	/^    AstVariable(std::string n) : AstArgument(), name(std::move(n)) {}$/;"	f	class:souffle::AstVariable
AstVariable	AstArgument.h	/^class AstVariable : public AstArgument {$/;"	c	namespace:souffle
AstVisitor	AstVisitor.h	/^struct AstVisitor : public ast_visitor_tag {$/;"	s	namespace:souffle
Atom	profile/Rule.h	/^    Atom(std::string identifier, std::string rule, size_t level, size_t frequency)$/;"	f	class:souffle::profile::Atom
Atom	profile/Rule.h	/^class Atom {$/;"	c	namespace:souffle::profile
AtomFrequenciesVisitor	profile/Reader.h	/^    AtomFrequenciesVisitor(Rule& rule) : rule(rule) {}$/;"	f	class:souffle::profile::__anon72::AtomFrequenciesVisitor
AtomFrequenciesVisitor	profile/Reader.h	/^class AtomFrequenciesVisitor : public Visitor {$/;"	c	namespace:souffle::profile::__anon72
Auto	CompiledRelation.h	/^struct Auto {$/;"	s	namespace:souffle::ram
AutoRelation	CompiledRelation.h	/^class AutoRelation : public RelationBase<arity, AutoRelation<arity, Indices...>> {$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<0> : public RelationBase<0, AutoRelation<0>> {$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<2, First, Second, Rest...>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<3, First, Second, Rest...>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<4, First, Second, Rest...>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<5, First, Second, Rest...>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<6, First, Second, Rest...>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<arity, Index>$/;"	c	namespace:souffle::ram::detail
AutoRelation	CompiledRelation.h	/^class AutoRelation<arity> : public AutoRelation<arity, typename index_utils::get_full_index<arity>::type> {};$/;"	c	namespace:souffle::ram::detail
BAND	FunctorOps.h	/^    BAND,  \/\/ bitwise and$/;"	m	class:souffle::FunctorOp
BEGIN	scanner.cc	/^#define BEGIN /;"	d	file:
BISON	Makefile	/^BISON = bison$/;"	m
BISON_VERSION	Makefile	/^BISON_VERSION = 3.3.2$/;"	m
BITS_PER_ENTRY	Brie.h	/^    static const short BITS_PER_ENTRY = sizeof(value_t) * 8;$/;"	m	class:souffle::SparseBitMap
BIT_PER_STEP	Brie.h	/^    static const int BIT_PER_STEP = BITS;$/;"	m	class:souffle::SparseArray
BLOCKBITS	PiggyList.h	/^    const size_t BLOCKBITS = 16ul;$/;"	m	class:souffle::PiggyList
BLOCKBITS	PiggyList.h	/^    const size_t BLOCKBITS = 16ul;$/;"	m	class:souffle::RandomInsertPiggyList
BLOCKSIZE	PiggyList.h	/^    const size_t BLOCKSIZE = (1ul << BLOCKBITS);$/;"	m	class:souffle::PiggyList
BLOCK_SIZE	CompiledRecord.h	/^    static const std::size_t BLOCK_SIZE = 1 << 20;$/;"	m	class:souffle::detail::RecordMap
BLOCK_SIZE	InterpreterRelation.h	/^    static const int BLOCK_SIZE = 1024;$/;"	m	class:souffle::InterpreterRelation
BNOT	FunctorOps.h	/^    BNOT,      \/\/ bitwise negation$/;"	m	class:souffle::FunctorOp
BOOL	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
BOR	FunctorOps.h	/^    BOR,   \/\/ bitwise or$/;"	m	class:souffle::FunctorOp
BRIE	RelationRepresentation.h	/^    BRIE,$/;"	m	class:souffle::RelationRepresentation
BRIE_QUALIFIER	parser.hh	/^        BRIE_QUALIFIER = 267,$/;"	e	enum:yy::parser::token::yytokentype
BRIE_RELATION	AstRelation.h	/^#define BRIE_RELATION /;"	d
BTREE	RelationRepresentation.h	/^    BTREE,$/;"	m	class:souffle::RelationRepresentation
BTREE_QUALIFIER	parser.hh	/^        BTREE_QUALIFIER = 268,$/;"	e	enum:yy::parser::token::yytokentype
BTREE_RELATION	AstRelation.h	/^#define BTREE_RELATION /;"	d
BTree	CompiledRelation.h	/^struct BTree {$/;"	s	namespace:souffle::ram
BW_AND	parser.hh	/^        BW_AND = 326,$/;"	e	enum:yy::parser::token::yytokentype
BW_NOT	parser.hh	/^        BW_NOT = 329,$/;"	e	enum:yy::parser::token::yytokentype
BW_OR	parser.hh	/^        BW_OR = 327,$/;"	e	enum:yy::parser::token::yytokentype
BW_XOR	parser.hh	/^        BW_XOR = 328,$/;"	e	enum:yy::parser::token::yytokentype
BXOR	FunctorOps.h	/^    BXOR,  \/\/ bitwise exclusive or$/;"	m	class:souffle::FunctorOp
BaseTable	Global.h	/^    BaseTable() : _default(V()), _data(std::map<K, V>()) {}$/;"	f	class:souffle::BaseTable
BaseTable	Global.h	/^    BaseTable(const BaseTable& other) {$/;"	f	class:souffle::BaseTable
BaseTable	Global.h	/^class BaseTable {$/;"	c	namespace:souffle
BddBddBTranslator	souffle2bdd.cpp	/^class BddBddBTranslator : private AstVisitor<void, std::ostream&> {$/;"	c	namespace:souffle	file:
BinaryConstraintOp	BinaryConstraintOps.h	/^enum class BinaryConstraintOp {$/;"	c	namespace:souffle
BindingStore	MagicSet.h	/^class BindingStore {$/;"	c	namespace:souffle
Block	Table.h	/^        Block() : next(nullptr) {}$/;"	f	struct:souffle::Table::Block
Block	Table.h	/^    struct Block {$/;"	s	class:souffle::Table
Brie	CompiledRelation.h	/^struct Brie {$/;"	s	namespace:souffle::ram
CARET	parser.hh	/^        CARET = 320,$/;"	e	enum:yy::parser::token::yytokentype
CAT	FunctorOps.h	/^    CAT,   \/\/ string concatenation$/;"	m	class:souffle::FunctorOp
CAT	parser.hh	/^        CAT = 274,$/;"	e	enum:yy::parser::token::yytokentype
CC	Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O2$/;"	m
CLEANFILES	Makefile	/^CLEANFILES = $(BUILT_SOURCES)  parser.cc scanner.cc parser.hh stack.hh$/;"	m
COLON	parser.hh	/^        COLON = 313,$/;"	e	enum:yy::parser::token::yytokentype
COMMA	parser.hh	/^        COMMA = 312,$/;"	e	enum:yy::parser::token::yytokentype
COMMENT	scanner.cc	/^#define COMMENT /;"	d	file:
COMMENTS	json11.h	/^enum JsonParse { STANDARD, COMMENTS };$/;"	e	enum:json11::JsonParse
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPONENT	parser.hh	/^        COMPONENT = 294,$/;"	e	enum:yy::parser::token::yytokentype
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES = souffle-compile souffle-config$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONTAINS	BinaryConstraintOps.h	/^    CONTAINS,       \/\/ whether a sub-string is contained in a string$/;"	m	class:souffle::BinaryConstraintOp
COUNT	RamOperation.h	/^    enum Function { MAX, MIN, COUNT, SUM };$/;"	e	enum:souffle::RamAggregate::Function
COUNT	parser.hh	/^        COUNT = 280,$/;"	e	enum:yy::parser::token::yytokentype
CPP	Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CREATE_OP_CONTEXT	ParallelUtils.h	/^#define CREATE_OP_CONTEXT(/;"	d
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CXX	Makefile	/^CXX = g++$/;"	m
CXXCOMPILE	Makefile	/^CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\$/;"	m
CXXCPP	Makefile	/^CXXCPP = g++ -E$/;"	m
CXXDEPMODE	Makefile	/^CXXDEPMODE = depmode=gcc3$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS =  -Wall -std=c++11 -DUSE_PROVENANCE  -O3 -DUSE_LIBZ  -DUSE_SQLITE    $/;"	m
CXXLD	Makefile	/^CXXLD = $(CXX)$/;"	m
CXXLINK	Makefile	/^CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
C_T	profile/DataComparator.h	/^    static bool C_T(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
Cell	Brie.h	/^    union Cell {$/;"	u	class:souffle::SparseArray
Cell	profile/Cell.h	/^    Cell(T value) : value(value){};$/;"	f	class:souffle::profile::Cell
Cell	profile/Cell.h	/^    Cell(double value) : value(value){};$/;"	f	class:souffle::profile::Cell
Cell	profile/Cell.h	/^    Cell(long value) : value(value){};$/;"	f	class:souffle::profile::Cell
Cell	profile/Cell.h	/^    Cell(std::chrono::microseconds value) : value(value){};$/;"	f	class:souffle::profile::Cell
Cell	profile/Cell.h	/^    Cell(std::string value) : value(std::move(value)){};$/;"	f	class:souffle::profile::Cell
Cell	profile/Cell.h	/^class Cell : public CellInterface {$/;"	c	namespace:souffle::profile
Cell	profile/Cell.h	/^class Cell<double> : public CellInterface {$/;"	c	namespace:souffle::profile
Cell	profile/Cell.h	/^class Cell<long> : public CellInterface {$/;"	c	namespace:souffle::profile
Cell	profile/Cell.h	/^class Cell<std::chrono::microseconds> : public CellInterface {$/;"	c	namespace:souffle::profile
Cell	profile/Cell.h	/^class Cell<std::string> : public CellInterface {$/;"	c	namespace:souffle::profile
Cell	profile/Cell.h	/^class Cell<void> : public CellInterface, std::false_type {$/;"	c	namespace:souffle::profile
CellInterface	profile/CellInterface.h	/^class CellInterface {$/;"	c	namespace:souffle::profile
ClauseTranslator	AstTranslator.h	/^        ClauseTranslator(AstTranslator& translator) : translator(translator) {}$/;"	f	class:souffle::AstTranslator::ClauseTranslator
ClauseTranslator	AstTranslator.h	/^    class ClauseTranslator {$/;"	c	class:souffle::AstTranslator
Cli	profile/Cli.h	/^    Cli(int argc, char* argv[]) : args() {$/;"	f	class:souffle::profile::Cli
Cli	profile/Cli.h	/^class Cli {$/;"	c	namespace:souffle::profile
CmdOptions	CompiledOptions.h	/^    CmdOptions(const char* s, const char* id, const char* od, bool pe, const char* pfn, size_t nj,$/;"	f	class:souffle::CmdOptions
CmdOptions	CompiledOptions.h	/^class CmdOptions {$/;"	c	namespace:souffle
ComponentContent	ComponentModel.cpp	/^struct ComponentContent {$/;"	s	namespace:souffle::__anon73	file:
ComponentInstantiationTransformer	ComponentModel.h	/^class ComponentInstantiationTransformer : public AstTransformer {$/;"	c	namespace:souffle
ComponentLookup	ComponentModel.h	/^class ComponentLookup : public AstAnalysis {$/;"	c	namespace:souffle
ConditionalTransformer	AstTransforms.h	/^    ConditionalTransformer(bool cond, std::unique_ptr<AstTransformer> transformer)$/;"	f	class:souffle::ConditionalTransformer
ConditionalTransformer	AstTransforms.h	/^    ConditionalTransformer(std::function<bool()> cond, std::unique_ptr<AstTransformer> transformer)$/;"	f	class:souffle::ConditionalTransformer
ConditionalTransformer	AstTransforms.h	/^class ConditionalTransformer : public MetaTransformer {$/;"	c	namespace:souffle
ConfigProcessor	EventProcessor.h	/^    ConfigProcessor() {$/;"	f	class:souffle::profile::ConfigProcessor
ConfigProcessor	EventProcessor.h	/^const class ConfigProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
Constraint	Constraints.h	/^class Constraint {$/;"	c	namespace:souffle
ConvertExistenceChecksTransformer	RamTransforms.h	/^class ConvertExistenceChecksTransformer : public RamTransformer {$/;"	c	namespace:souffle
CreateIndicesTransformer	RamTransforms.h	/^class CreateIndicesTransformer : public RamTransformer {$/;"	c	namespace:souffle
DEBUILD	Makefile	/^DEBUILD = $/;"	m
DECL	parser.hh	/^        DECL = 287,$/;"	e	enum:yy::parser::token::yytokentype
DEFAULT	RelationRepresentation.h	/^    DEFAULT,$/;"	m	class:souffle::RelationRepresentation
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DIR	Makefile	/^DIR := ${CURDIR}$/;"	m
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(dist_bin_SCRIPTS) \\$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(am__libsouffle_la_SOURCES_DIST) $(souffle_SOURCES) \\$/;"	m
DIV	FunctorOps.h	/^    DIV,   \/\/ division$/;"	m	class:souffle::FunctorOp
DLLTOOL	Makefile	/^DLLTOOL = false$/;"	m
DOLLAR	parser.hh	/^        DOLLAR = 306,$/;"	e	enum:yy::parser::token::yytokentype
DOT	parser.hh	/^        DOT = 315,$/;"	e	enum:yy::parser::token::yytokentype
DOXYGEN_PAPER_SIZE	Makefile	/^DOXYGEN_PAPER_SIZE = $/;"	m
DSNVisitor	profile/Reader.h	/^    DSNVisitor(T& base) : base(base) {}$/;"	f	class:souffle::profile::__anon72::DSNVisitor
DSNVisitor	profile/Reader.h	/^class DSNVisitor : public Visitor {$/;"	c	namespace:souffle::profile::__anon72
DSYMUTIL	Makefile	/^DSYMUTIL = dsymutil$/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
DX_CONFIG	Makefile	/^DX_CONFIG = doxygen.cfg$/;"	m
DX_DOCDIR	Makefile	/^DX_DOCDIR = doc$/;"	m
DX_DOT	Makefile	/^DX_DOT = \/usr\/local\/bin\/dot$/;"	m
DX_DOXYGEN	Makefile	/^DX_DOXYGEN = \/usr\/local\/bin\/doxygen$/;"	m
DX_DVIPS	Makefile	/^DX_DVIPS = $/;"	m
DX_EGREP	Makefile	/^DX_EGREP = $/;"	m
DX_ENV	Makefile	/^DX_ENV =  SRCDIR='.' PROJECT='souffle' DOCDIR='doc' VERSION='1.0.0-3315-g27d34e2' PERL_PATH='\/usr\/local\/bin\/perl' HAVE_DOT='YES' DOT_PATH='\/usr\/local\/bin' GENERATE_MAN='NO' GENERATE_RTF='NO' GENERATE_XML='NO' GENERATE_HTMLHELP='NO' GENERATE_CHI='NO' GENERATE_HTML='YES' GENERATE_LATEX='NO'$/;"	m
DX_FLAG_chi	Makefile	/^DX_FLAG_chi = 0$/;"	m
DX_FLAG_chm	Makefile	/^DX_FLAG_chm = 0$/;"	m
DX_FLAG_doc	Makefile	/^DX_FLAG_doc = 1$/;"	m
DX_FLAG_dot	Makefile	/^DX_FLAG_dot = 1$/;"	m
DX_FLAG_html	Makefile	/^DX_FLAG_html = 1$/;"	m
DX_FLAG_man	Makefile	/^DX_FLAG_man = 0$/;"	m
DX_FLAG_pdf	Makefile	/^DX_FLAG_pdf = 0$/;"	m
DX_FLAG_ps	Makefile	/^DX_FLAG_ps = 0$/;"	m
DX_FLAG_rtf	Makefile	/^DX_FLAG_rtf = 0$/;"	m
DX_FLAG_xml	Makefile	/^DX_FLAG_xml = 0$/;"	m
DX_HHC	Makefile	/^DX_HHC = $/;"	m
DX_LATEX	Makefile	/^DX_LATEX = $/;"	m
DX_MAKEINDEX	Makefile	/^DX_MAKEINDEX = $/;"	m
DX_PDFLATEX	Makefile	/^DX_PDFLATEX = $/;"	m
DX_PERL	Makefile	/^DX_PERL = \/usr\/local\/bin\/perl$/;"	m
DX_PROJECT	Makefile	/^DX_PROJECT = souffle$/;"	m
DataComparator	profile/DataComparator.h	/^class DataComparator {$/;"	c	namespace:souffle::profile
DebugReport	DebugReport.h	/^class DebugReport {$/;"	c	namespace:souffle
DebugReportSection	DebugReport.h	/^    DebugReportSection(const std::string& id, std::string title, std::vector<DebugReportSection> subsections,$/;"	f	class:souffle::DebugReportSection
DebugReportSection	DebugReport.h	/^class DebugReportSection {$/;"	c	namespace:souffle
DebugReporter	DebugReport.h	/^    DebugReporter(std::unique_ptr<AstTransformer> wrappedTransformer)$/;"	f	class:souffle::DebugReporter
DebugReporter	DebugReport.h	/^class DebugReporter : public MetaTransformer {$/;"	c	namespace:souffle
Diagnostic	ErrorReport.h	/^    Diagnostic(Type type, DiagnosticMessage primaryMessage)$/;"	f	class:souffle::Diagnostic
Diagnostic	ErrorReport.h	/^    Diagnostic(Type type, DiagnosticMessage primaryMessage, std::vector<DiagnosticMessage> additionalMessages)$/;"	f	class:souffle::Diagnostic
Diagnostic	ErrorReport.h	/^class Diagnostic {$/;"	c	namespace:souffle
DiagnosticMessage	ErrorReport.h	/^    DiagnosticMessage(std::string message) : message(std::move(message)), hasLoc(false) {}$/;"	f	class:souffle::DiagnosticMessage
DiagnosticMessage	ErrorReport.h	/^    DiagnosticMessage(std::string message, SrcLocation location)$/;"	f	class:souffle::DiagnosticMessage
DiagnosticMessage	ErrorReport.h	/^class DiagnosticMessage {$/;"	c	namespace:souffle
DirectIndex	CompiledIndexUtils.h	/^struct DirectIndex {$/;"	s	namespace:souffle::ram::index_utils
DirectIndexedRelation	CompiledRelation.h	/^class DirectIndexedRelation$/;"	c	namespace:souffle::ram::detail
DirectoryEntry	ProfileDatabase.h	/^    DirectoryEntry(const std::string& name) : Entry(name) {}$/;"	f	class:souffle::profile::DirectoryEntry
DirectoryEntry	ProfileDatabase.h	/^class DirectoryEntry : public Entry {$/;"	c	namespace:souffle::profile
DisjointSet	UnionFind.h	/^class DisjointSet {$/;"	c	namespace:souffle
DisjointSetIndex	CompiledIndexUtils.h	/^class DisjointSetIndex {$/;"	c	namespace:souffle::ram::index_utils
DurationEntry	ProfileDatabase.h	/^    DurationEntry(const std::string& key, microseconds start, microseconds end)$/;"	f	class:souffle::profile::DurationEntry
DurationEntry	ProfileDatabase.h	/^class DurationEntry : public Entry {$/;"	c	namespace:souffle::profile
ECHO	scanner.cc	/^#define ECHO /;"	d	file:
ECHO_C	Makefile	/^ECHO_C = \\c$/;"	m
ECHO_N	Makefile	/^ECHO_N = $/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
EGREP	Makefile	/^EGREP = \/usr\/bin\/grep -E$/;"	m
END	parser.hh	/^        END = 0,$/;"	e	enum:yy::parser::token::yytokentype
EOB_ACT_CONTINUE_SCAN	scanner.cc	/^#define EOB_ACT_CONTINUE_SCAN /;"	d	file:
EOB_ACT_END_OF_FILE	scanner.cc	/^#define EOB_ACT_END_OF_FILE /;"	d	file:
EOB_ACT_LAST_MATCH	scanner.cc	/^#define EOB_ACT_LAST_MATCH /;"	d	file:
EQ	BinaryConstraintOps.h	/^    EQ,             \/\/ equivalence of two values$/;"	m	class:souffle::BinaryConstraintOp
EQREL_QUALIFIER	parser.hh	/^        EQREL_QUALIFIER = 269,$/;"	e	enum:yy::parser::token::yytokentype
EQREL_RELATION	AstRelation.h	/^#define EQREL_RELATION /;"	d
EQUALS	parser.hh	/^        EQUALS = 316,$/;"	e	enum:yy::parser::token::yytokentype
ERROR	ErrorReport.h	/^    enum Type { ERROR, WARNING };$/;"	e	enum:souffle::Diagnostic::Type
ETAGS	Makefile	/^ETAGS = etags$/;"	m
EXCLAMATION	parser.hh	/^        EXCLAMATION = 309,$/;"	e	enum:yy::parser::token::yytokentype
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXIT	SymbolTable.h	/^        EXIT = 0,$/;"	e	enum:souffle::SymbolTable::__anon65
EXP	FunctorOps.h	/^    EXP,   \/\/ exponent$/;"	m	class:souffle::FunctorOp
EXPECT_EQ	test/test.h	/^#define EXPECT_EQ(/;"	d
EXPECT_FALSE	test/test.h	/^#define EXPECT_FALSE(/;"	d
EXPECT_LT	test/test.h	/^#define EXPECT_LT(/;"	d
EXPECT_NE	test/test.h	/^#define EXPECT_NE(/;"	d
EXPECT_PRED2	test/test.h	/^#define EXPECT_PRED2(/;"	d
EXPECT_STREQ	test/test.h	/^#define EXPECT_STREQ(/;"	d
EXPECT_TRUE	test/test.h	/^#define EXPECT_TRUE(/;"	d
EXTRA_DIST	Makefile	/^EXTRA_DIST = parser.yy scanner.ll  test\/test.h$/;"	m
Entry	ProfileDatabase.h	/^    Entry(std::string key) : key(std::move(key)) {}$/;"	f	class:souffle::profile::Entry
Entry	ProfileDatabase.h	/^class Entry {$/;"	c	namespace:souffle::profile
EqRel	CompiledRelation.h	/^struct EqRel {$/;"	s	namespace:souffle::ram
EqrelMapComparator	UnionFind.h	/^struct EqrelMapComparator {$/;"	s	namespace:souffle
Equation	ResolveAliasesTransformer.cpp	/^    Equation(const AstArgument& lhs, const AstArgument& rhs)$/;"	f	class:souffle::__anon71::Equation
Equation	ResolveAliasesTransformer.cpp	/^    Equation(const AstArgument* lhs, const AstArgument* rhs)$/;"	f	class:souffle::__anon71::Equation
Equation	ResolveAliasesTransformer.cpp	/^    Equation(const Equation& other)$/;"	f	class:souffle::__anon71::Equation
Equation	ResolveAliasesTransformer.cpp	/^class Equation {$/;"	c	namespace:souffle::__anon71	file:
EquivalenceRelation	EquivalenceRelation.h	/^    EquivalenceRelation() : statesMapStale(false){};$/;"	f	class:souffle::EquivalenceRelation
EquivalenceRelation	EquivalenceRelation.h	/^class EquivalenceRelation {$/;"	c	namespace:souffle
ErrorReport	ErrorReport.h	/^    ErrorReport(bool nowarn = false) : nowarn(nowarn) {}$/;"	f	class:souffle::ErrorReport
ErrorReport	ErrorReport.h	/^class ErrorReport {$/;"	c	namespace:souffle
EventProcessor	EventProcessor.h	/^class EventProcessor {$/;"	c	namespace:souffle::profile
EventProcessorSingleton	EventProcessor.h	/^class EventProcessorSingleton {$/;"	c	namespace:souffle::profile
Explain	Explain.h	/^    Explain(ExplainProvenance& p, bool ncurses, int d = 4)$/;"	f	class:souffle::Explain
Explain	Explain.h	/^class Explain {$/;"	c	namespace:souffle
ExplainProvenance	ExplainProvenance.h	/^    ExplainProvenance(SouffleProgram& prog) : prog(prog) {}$/;"	f	class:souffle::ExplainProvenance
ExplainProvenance	ExplainProvenance.h	/^class ExplainProvenance {$/;"	c	namespace:souffle
ExplainProvenanceSLD	ExplainProvenanceSLD.h	/^    ExplainProvenanceSLD(SouffleProgram& prog) : ExplainProvenance(prog) {$/;"	f	class:souffle::ExplainProvenanceSLD
ExplainProvenanceSLD	ExplainProvenanceSLD.h	/^class ExplainProvenanceSLD : public ExplainProvenance {$/;"	c	namespace:souffle
FALSE	parser.hh	/^        FALSE = 283,$/;"	e	enum:yy::parser::token::yytokentype
FFI_CFLAGS	Makefile	/^FFI_CFLAGS = -I\/usr\/local\/Cellar\/libffi\/3.2.1\/lib\/libffi-3.2.1\/include$/;"	m
FFI_LIBS	Makefile	/^FFI_LIBS = -L\/usr\/local\/Cellar\/libffi\/3.2.1\/lib -lffi$/;"	m
FGREP	Makefile	/^FGREP = \/usr\/bin\/grep -F$/;"	m
FLEX	Makefile	/^FLEX = flex$/;"	m
FLEXINT_H	scanner.cc	/^#define FLEXINT_H$/;"	d	file:
FLEX_BETA	scanner.cc	/^#define FLEX_BETA$/;"	d	file:
FLEX_SCANNER	scanner.cc	/^#define FLEX_SCANNER$/;"	d	file:
FORWARD	AstVisitor.h	/^#define FORWARD(/;"	d
FORWARD	AstVisitor.h	/^#undef FORWARD$/;"	d
FORWARD	RamVisitor.h	/^#define FORWARD(/;"	d
FORWARD	RamVisitor.h	/^#undef FORWARD$/;"	d
FUNCTOR	parser.hh	/^        FUNCTOR = 288,$/;"	e	enum:yy::parser::token::yytokentype
Field	AstType.h	/^    struct Field {$/;"	s	class:souffle::AstRecordType
Field	TypeSystem.h	/^    struct Field {$/;"	s	struct:souffle::RecordType
FirstInfoSnapshot	Brie.h	/^    struct FirstInfoSnapshot {$/;"	s	class:souffle::SparseArray
FixpointTransformer	AstTransforms.h	/^    FixpointTransformer(std::unique_ptr<AstTransformer> transformer) : transformer(std::move(transformer)) {}$/;"	f	class:souffle::FixpointTransformer
FixpointTransformer	AstTransforms.h	/^class FixpointTransformer : public MetaTransformer {$/;"	c	namespace:souffle
FrequencyAtomProcessor	EventProcessor.h	/^    FrequencyAtomProcessor() {$/;"	f	class:souffle::profile::FrequencyAtomProcessor
FrequencyAtomProcessor	EventProcessor.h	/^const class FrequencyAtomProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
Function	RamOperation.h	/^    enum Function { MAX, MIN, COUNT, SUM };$/;"	g	class:souffle::RamAggregate
FunctorOp	FunctorOps.h	/^enum class FunctorOp {$/;"	c	namespace:souffle
GE	BinaryConstraintOps.h	/^    GE,             \/\/ greater-than-or-equal-to$/;"	m	class:souffle::BinaryConstraintOp
GREP	Makefile	/^GREP = \/usr\/bin\/grep$/;"	m
GT	BinaryConstraintOps.h	/^    GT,             \/\/ greater-than$/;"	m	class:souffle::BinaryConstraintOp
GT	parser.hh	/^        GT = 325,$/;"	e	enum:yy::parser::token::yytokentype
GenericRelation	CompiledRelation.h	/^class GenericRelation : public RelationBase<arity, GenericRelation<config, arity, Indices...>> {$/;"	c	namespace:souffle::ram::detail
GenericRelationGroup	CompiledRelation.h	/^class GenericRelationGroup<config, arity, First, Rest...> {$/;"	c	namespace:souffle::ram::detail
GenericRelationGroup	CompiledRelation.h	/^class GenericRelationGroup<config, arity> {$/;"	c	namespace:souffle::ram::detail
GenericSetup	CompiledRelation.h	/^struct GenericSetup {$/;"	s	namespace:souffle::ram
Global	Global.h	/^class Global {$/;"	c	namespace:souffle
Graph	GraphUtils.h	/^class Graph {$/;"	c	namespace:souffle
HASH_SIZE	StringPool.h	/^#define HASH_SIZE /;"	d
HEADERS	Makefile	/^HEADERS = $(souffleprofile_HEADERS) $(soufflepublic_HEADERS)$/;"	m
HtmlGenerator	profile/HtmlGenerator.h	/^class HtmlGenerator {$/;"	c	namespace:souffle::profile
ID	profile/DataComparator.h	/^    static bool ID(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
IDENT	parser.hh	/^        IDENT = 260,$/;"	e	enum:yy::parser::token::yytokentype
IF	parser.hh	/^        IF = 286,$/;"	e	enum:yy::parser::token::yytokentype
INDEX_MASK	Brie.h	/^    static const key_type INDEX_MASK = NUM_CELLS - 1;$/;"	m	class:souffle::SparseArray
INF	IndexSetAnalysis.h	/^#define INF /;"	d
INITIAL	scanner.cc	/^#define INITIAL /;"	d	file:
INITIALBLOCKSIZE	PiggyList.h	/^    const size_t INITIALBLOCKSIZE = (1ul << BLOCKBITS);$/;"	m	class:souffle::RandomInsertPiggyList
INLINE_QUALIFIER	parser.hh	/^        INLINE_QUALIFIER = 271,$/;"	e	enum:yy::parser::token::yytokentype
INLINE_RELATION	AstRelation.h	/^#define INLINE_RELATION /;"	d
INPUT_DECL	parser.hh	/^        INPUT_DECL = 289,$/;"	e	enum:yy::parser::token::yytokentype
INPUT_QUALIFIER	parser.hh	/^        INPUT_QUALIFIER = 265,$/;"	e	enum:yy::parser::token::yytokentype
INPUT_RELATION	AstRelation.h	/^#define INPUT_RELATION /;"	d
INSERT_STRING	SymbolTable.h	/^        INSERT_STRING = 1,$/;"	e	enum:souffle::SymbolTable::__anon65
INSERT_VECTOR_STRING	SymbolTable.h	/^        INSERT_VECTOR_STRING = 2,$/;"	e	enum:souffle::SymbolTable::__anon65
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTANTIATE	parser.hh	/^        INSTANTIATE = 295,$/;"	e	enum:yy::parser::token::yytokentype
INT16_MAX	scanner.cc	/^#define INT16_MAX /;"	d	file:
INT16_MIN	scanner.cc	/^#define INT16_MIN /;"	d	file:
INT32_MAX	scanner.cc	/^#define INT32_MAX /;"	d	file:
INT32_MIN	scanner.cc	/^#define INT32_MIN /;"	d	file:
INT8_MAX	scanner.cc	/^#define INT8_MAX /;"	d	file:
INT8_MIN	scanner.cc	/^#define INT8_MIN /;"	d	file:
IODirectives	IODirectives.h	/^    IODirectives(const std::map<std::string, std::string>& directiveMap) {$/;"	f	class:souffle::IODirectives
IODirectives	IODirectives.h	/^class IODirectives {$/;"	c	namespace:souffle
IODirectivesCounter	Interpreter.h	/^       size_t IODirectivesCounter = 0;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
IODirectivesPool	Interpreter.h	/^       std::vector<std::vector<IODirectives>> IODirectivesPool;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
IOSystem	IOSystem.h	/^    IOSystem() {$/;"	f	class:souffle::IOSystem
IOSystem	IOSystem.h	/^class IOSystem {$/;"	c	namespace:souffle
IOType	AstIOTypeAnalysis.h	/^class IOType : public AstAnalysis {$/;"	c	namespace:souffle
IS_PARALLEL	ParallelUtils.h	/^#define IS_PARALLEL$/;"	d
IS_SEQUENTIAL	ParallelUtils.h	/^#define IS_SEQUENTIAL$/;"	d
IndexSet	IndexSetAnalysis.h	/^    IndexSet(const RamRelation& rel) : relation(rel) {}$/;"	f	class:souffle::IndexSet
IndexSet	IndexSetAnalysis.h	/^class IndexSet {$/;"	c	namespace:souffle
IndexSetAnalysis	IndexSetAnalysis.h	/^class IndexSetAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
Indices	CompiledIndexUtils.h	/^class Indices<T, IndexFactory, First, Rest...> {$/;"	c	namespace:souffle::ram::index_utils
Indices	CompiledIndexUtils.h	/^class Indices<T, IndexFactory> {$/;"	c	namespace:souffle::ram::index_utils
IndirectIndex	CompiledIndexUtils.h	/^struct IndirectIndex {$/;"	s	namespace:souffle::ram::index_utils
InlineRelationsTransformer	AstTransforms.h	/^class InlineRelationsTransformer : public AstTransformer {$/;"	c	namespace:souffle
InnerNode	ExplainTree.h	/^    InnerNode(const std::string& nodeText = "", std::string label = "")$/;"	f	class:souffle::InnerNode
InnerNode	ExplainTree.h	/^class InnerNode : public TreeNode {$/;"	c	namespace:souffle
InputReader	profile/UserInputReader.h	/^    InputReader() {$/;"	f	class:souffle::profile::InputReader
InputReader	profile/UserInputReader.h	/^class InputReader {$/;"	c	namespace:souffle::profile
Interpreter	Interpreter.h	/^    Interpreter(RamTranslationUnit& tUnit) : translationUnit(tUnit), counter(0), iteration(0), dll(nullptr) {}$/;"	f	class:souffle::Interpreter
Interpreter	Interpreter.h	/^class Interpreter {$/;"	c	namespace:souffle
InterpreterContext	InterpreterContext.h	/^    InterpreterContext(size_t size = 0) : data(size) {}$/;"	f	class:souffle::InterpreterContext
InterpreterContext	InterpreterContext.h	/^class InterpreterContext {$/;"	c	namespace:souffle
InterpreterEqRelation	InterpreterRelation.h	/^    InterpreterEqRelation(size_t relArity) : InterpreterRelation(relArity) {}$/;"	f	class:souffle::InterpreterEqRelation
InterpreterEqRelation	InterpreterRelation.h	/^class InterpreterEqRelation : public InterpreterRelation {$/;"	c	namespace:souffle
InterpreterIndex	InterpreterIndex.h	/^    InterpreterIndex(InterpreterIndexOrder order)$/;"	f	class:souffle::InterpreterIndex
InterpreterIndex	InterpreterIndex.h	/^class InterpreterIndex {$/;"	c	namespace:souffle
InterpreterIndexOrder	InterpreterIndex.h	/^    InterpreterIndexOrder(std::vector<unsigned char> order = std::vector<unsigned char>())$/;"	f	class:souffle::InterpreterIndexOrder
InterpreterIndexOrder	InterpreterIndex.h	/^class InterpreterIndexOrder {$/;"	c	namespace:souffle
InterpreterProgInterface	InterpreterInterface.h	/^    InterpreterProgInterface(Interpreter& interp)$/;"	f	class:souffle::InterpreterProgInterface
InterpreterProgInterface	InterpreterInterface.h	/^class InterpreterProgInterface : public SouffleProgram {$/;"	c	namespace:souffle
InterpreterRelInterface	InterpreterInterface.h	/^    InterpreterRelInterface(InterpreterRelation& r, SymbolTable& s, std::string n, std::vector<std::string> t,$/;"	f	class:souffle::InterpreterRelInterface
InterpreterRelInterface	InterpreterInterface.h	/^class InterpreterRelInterface : public Relation {$/;"	c	namespace:souffle
InterpreterRelation	InterpreterRelation.h	/^    InterpreterRelation(size_t relArity) : arity(relArity), num_tuples(0), totalIndex(nullptr) {}$/;"	f	class:souffle::InterpreterRelation
InterpreterRelation	InterpreterRelation.h	/^class InterpreterRelation {$/;"	c	namespace:souffle
IterDerefWrapper	IterUtils.h	/^    IterDerefWrapper(const Iter& iter) : iter(iter) {}$/;"	f	struct:souffle::IterDerefWrapper
IterDerefWrapper	IterUtils.h	/^struct IterDerefWrapper : public std::iterator<std::forward_iterator_tag, T> {$/;"	s	namespace:souffle
IterType	EquivalenceRelation.h	/^        enum IterType { ALL, ANTERIOR, ANTPOST, WITHIN };$/;"	g	class:souffle::EquivalenceRelation::iterator
Iteration	profile/Iteration.h	/^    Iteration() : rules() {}$/;"	f	class:souffle::profile::Iteration
Iteration	profile/Iteration.h	/^class Iteration {$/;"	c	namespace:souffle::profile
IterationVisitor	profile/Reader.h	/^    IterationVisitor(Iteration& iteration, Relation& relation) : DSNVisitor(iteration), relation(relation) {}$/;"	f	class:souffle::profile::__anon72::IterationVisitor
IterationVisitor	profile/Reader.h	/^class IterationVisitor : public DSNVisitor<Iteration> {$/;"	c	namespace:souffle::profile::__anon72
IterationsVisitor	profile/Reader.h	/^    IterationsVisitor(Relation& relation) : relation(relation) {}$/;"	f	class:souffle::profile::__anon72::IterationsVisitor
IterationsVisitor	profile/Reader.h	/^class IterationsVisitor : public Visitor {$/;"	c	namespace:souffle::profile::__anon72
Json	json11.h	/^    Json(const T& t) : Json(t.to_json()) {}$/;"	f	class:json11::final
Json	json11.h	/^inline Json::Json(Json::array&& values) : m_ptr(make_shared<JsonArray>(move(values))) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(Json::object&& values) : m_ptr(make_shared<JsonObject>(move(values))) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(bool value) : m_ptr(value ? statics().t : statics().f) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(const Json::array& values) : m_ptr(make_shared<JsonArray>(values)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(const Json::object& values) : m_ptr(make_shared<JsonObject>(values)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(const char* value) : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(const string& value) : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(double value) : m_ptr(make_shared<JsonDouble>(value)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(long long value) : m_ptr(make_shared<JsonInt>(value)) {}$/;"	f	class:json11::Json
Json	json11.h	/^inline Json::Json(string&& value) : m_ptr(make_shared<JsonString>(move(value))) {}$/;"	f	class:json11::Json
JsonArray	json11.h	/^    explicit JsonArray(Json::array&& value) : Value(move(value)) {}$/;"	f	class:json11::final
JsonArray	json11.h	/^    explicit JsonArray(const Json::array& value) : Value(value) {}$/;"	f	class:json11::final
JsonBoolean	json11.h	/^    explicit JsonBoolean(bool value) : Value(value) {}$/;"	f	class:json11::final
JsonDouble	json11.h	/^    explicit JsonDouble(double value) : Value(value) {}$/;"	f	class:json11::final
JsonInt	json11.h	/^    explicit JsonInt(int value) : Value(value) {}$/;"	f	class:json11::final
JsonNull	json11.h	/^    JsonNull() : Value({}) {}$/;"	f	class:json11::final
JsonObject	json11.h	/^    explicit JsonObject(Json::object&& value) : Value(move(value)) {}$/;"	f	class:json11::final
JsonObject	json11.h	/^    explicit JsonObject(const Json::object& value) : Value(value) {}$/;"	f	class:json11::final
JsonParse	json11.h	/^enum JsonParse { STANDARD, COMMENTS };$/;"	g	namespace:json11
JsonString	json11.h	/^    explicit JsonString(const string& value) : Value(value) {}$/;"	f	class:json11::final
JsonString	json11.h	/^    explicit JsonString(string&& value) : Value(move(value)) {}$/;"	f	class:json11::final
JsonValue	json11.h	/^class JsonValue {$/;"	c	namespace:json11
LAND	FunctorOps.h	/^    LAND,  \/\/ logical and$/;"	m	class:souffle::FunctorOp
LBRACE	parser.hh	/^        LBRACE = 322,$/;"	e	enum:yy::parser::token::yytokentype
LBRACKET	parser.hh	/^        LBRACKET = 303,$/;"	e	enum:yy::parser::token::yytokentype
LD	Makefile	/^LD = \/Applications\/Xcode.app\/Contents\/Developer\/Toolchains\/XcodeDefault.xctoolchain\/usr\/bin\/ld$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = -L\/usr\/local\/opt\/libffi\/lib$/;"	m
LE	BinaryConstraintOps.h	/^    LE,             \/\/ less-than-or-equal-to$/;"	m	class:souffle::BinaryConstraintOp
LEAF_INDEX_MASK	Brie.h	/^    static const uint64_t LEAF_INDEX_MASK = BITS_PER_ENTRY - 1;$/;"	m	class:souffle::SparseBitMap
LEAF_INDEX_WIDTH	Brie.h	/^    static const short LEAF_INDEX_WIDTH = __builtin_ctz(BITS_PER_ENTRY);$/;"	m	class:souffle::SparseBitMap
LEX	Makefile	/^LEX = flex$/;"	m
LEXLIB	Makefile	/^LEXLIB = -ll$/;"	m
LEX_OUTPUT_ROOT	Makefile	/^LEX_OUTPUT_ROOT = lex.yy$/;"	m
LIBOBJS	Makefile	/^LIBOBJS =  ${LIBOBJDIR}error$U.o$/;"	m
LIBS	Makefile	/^LIBS = -ldl -lpthread -lsqlite3 -lz -lncurses$/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LINK	AstVisitor.h	/^#define LINK(/;"	d
LINK	AstVisitor.h	/^#undef LINK$/;"	d
LINK	Makefile	/^LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LINK	RamVisitor.h	/^#define LINK(/;"	d
LINK	RamVisitor.h	/^#undef LINK$/;"	d
LIPO	Makefile	/^LIPO = lipo$/;"	m
LNOT	FunctorOps.h	/^    LNOT,      \/\/ logical negation$/;"	m	class:souffle::FunctorOp
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LOC	test/test.h	/^#define LOC /;"	d
LOG_COMPILE	Makefile	/^LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)$/;"	m
LOG_DRIVER	Makefile	/^LOG_DRIVER = $(SHELL) $(top_srcdir)\/test-driver$/;"	m
LOOKUP	SymbolTable.h	/^        LOOKUP = 3,$/;"	e	enum:souffle::SymbolTable::__anon65
LOOKUP_EXISTING	SymbolTable.h	/^        LOOKUP_EXISTING = 4,$/;"	e	enum:souffle::SymbolTable::__anon65
LOR	FunctorOps.h	/^    LOR,   \/\/ logical or$/;"	m	class:souffle::FunctorOp
LPAREN	parser.hh	/^        LPAREN = 310,$/;"	e	enum:yy::parser::token::yytokentype
LSB_RELEASE	Makefile	/^LSB_RELEASE = $/;"	m
LT	BinaryConstraintOps.h	/^    LT,             \/\/ less-than$/;"	m	class:souffle::BinaryConstraintOp
LT	parser.hh	/^        LT = 324,$/;"	e	enum:yy::parser::token::yytokentype
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LTCXXCOMPILE	Makefile	/^LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS =  ${LIBOBJDIR}error$U.lo$/;"	m
LTLIBRARIES	Makefile	/^LTLIBRARIES = $(noinst_LTLIBRARIES)$/;"	m
LT_SYS_LIBRARY_PATH	Makefile	/^LT_SYS_LIBRARY_PATH = $/;"	m
LVMGenerator	Interpreter.h	/^       LVMGenerator(SymbolTable& symbolTable) : symbolTable(symbolTable) {}$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
LVMGenerator	Interpreter.h	/^    class LVMGenerator : public RamVisitor<void, size_t> {$/;"	c	class:souffle::LowLevelMachine
LVM_Aggregate	Interpreter.h	/^    LVM_Aggregate,$/;"	e	enum:souffle::LVM_Type
LVM_Aggregate_COUNT	Interpreter.h	/^    LVM_Aggregate_COUNT,$/;"	e	enum:souffle::LVM_Type
LVM_Aggregate_MAX	Interpreter.h	/^    LVM_Aggregate_MAX,$/;"	e	enum:souffle::LVM_Type
LVM_Aggregate_MIN	Interpreter.h	/^    LVM_Aggregate_MIN,$/;"	e	enum:souffle::LVM_Type
LVM_Aggregate_Return	Interpreter.h	/^    LVM_Aggregate_Return,$/;"	e	enum:souffle::LVM_Type
LVM_Aggregate_SUM	Interpreter.h	/^    LVM_Aggregate_SUM,$/;"	e	enum:souffle::LVM_Type
LVM_Argument	Interpreter.h	/^    LVM_Argument,$/;"	e	enum:souffle::LVM_Type
LVM_AutoIncrement	Interpreter.h	/^    LVM_AutoIncrement,$/;"	e	enum:souffle::LVM_Type
LVM_BRIE	Interpreter.h	/^    LVM_BRIE,$/;"	e	enum:souffle::LVM_Type
LVM_BTREE	Interpreter.h	/^    LVM_BTREE,$/;"	e	enum:souffle::LVM_Type
LVM_Clear	Interpreter.h	/^    LVM_Clear,$/;"	e	enum:souffle::LVM_Type
LVM_Conjunction	Interpreter.h	/^    LVM_Conjunction,$/;"	e	enum:souffle::LVM_Type
LVM_Constraint	Interpreter.h	/^    LVM_Constraint,$/;"	e	enum:souffle::LVM_Type
LVM_Create	Interpreter.h	/^    LVM_Create,$/;"	e	enum:souffle::LVM_Type
LVM_DEFAULT	Interpreter.h	/^    LVM_DEFAULT,$/;"	e	enum:souffle::LVM_Type
LVM_DebugInfo	Interpreter.h	/^    LVM_DebugInfo,$/;"	e	enum:souffle::LVM_Type
LVM_Drop	Interpreter.h	/^    LVM_Drop,$/;"	e	enum:souffle::LVM_Type
LVM_EQREL	Interpreter.h	/^    LVM_EQREL,$/;"	e	enum:souffle::LVM_Type
LVM_ElementAccess	Interpreter.h	/^    LVM_ElementAccess,$/;"	e	enum:souffle::LVM_Type
LVM_EmptinessCheck	Interpreter.h	/^    LVM_EmptinessCheck,$/;"	e	enum:souffle::LVM_Type
LVM_ExistenceCheck	Interpreter.h	/^    LVM_ExistenceCheck,$/;"	e	enum:souffle::LVM_Type
LVM_Exit	Interpreter.h	/^    LVM_Exit,$/;"	e	enum:souffle::LVM_Type
LVM_Fact	Interpreter.h	/^    LVM_Fact,$/;"	e	enum:souffle::LVM_Type
LVM_Filter	Interpreter.h	/^    LVM_Filter,$/;"	e	enum:souffle::LVM_Type
LVM_Goto	Interpreter.h	/^    LVM_Goto,               \/\/ LVM_Goto  <address>  $/;"	e	enum:souffle::LVM_Type
LVM_ITER_Inc	Interpreter.h	/^    LVM_ITER_Inc,           \/\/ <Inc> <IterType> <Idx> TODO$/;"	e	enum:souffle::LVM_Type
LVM_ITER_NotAtEnd	Interpreter.h	/^    LVM_ITER_NotAtEnd,         \/\/ <AtEnd> <IterType> <Idx> TODO$/;"	e	enum:souffle::LVM_Type
LVM_ITER_Select	Interpreter.h	/^    LVM_ITER_Select,        \/\/ <Select> <IterType> <Idx> TODO$/;"	e	enum:souffle::LVM_Type
LVM_ITER_TypeIndexScan	Interpreter.h	/^    LVM_ITER_TypeIndexScan,$/;"	e	enum:souffle::LVM_Type
LVM_ITER_TypeScan	Interpreter.h	/^    LVM_ITER_TypeScan,$/;"	e	enum:souffle::LVM_Type
LVM_IndexScan	Interpreter.h	/^    LVM_IndexScan,$/;"	e	enum:souffle::LVM_Type
LVM_Jmpez	Interpreter.h	/^    LVM_Jmpez,              \/\/ LVM_Jmpez <address>$/;"	e	enum:souffle::LVM_Type
LVM_Jmpnz	Interpreter.h	/^    LVM_Jmpnz,              \/\/ LVM_Jmpnz <address>$/;"	e	enum:souffle::LVM_Type
LVM_LT	Interpreter.h	/^    LVM_LT,$/;"	e	enum:souffle::LVM_Type
LVM_Load	Interpreter.h	/^    LVM_Load,$/;"	e	enum:souffle::LVM_Type
LVM_LogSize	Interpreter.h	/^    LVM_LogSize,$/;"	e	enum:souffle::LVM_Type
LVM_LogTimer	Interpreter.h	/^    LVM_LogTimer,$/;"	e	enum:souffle::LVM_Type
LVM_Loop	Interpreter.h	/^    LVM_Loop,$/;"	e	enum:souffle::LVM_Type
LVM_Match	Interpreter.h	/^    LVM_Match,              $/;"	e	enum:souffle::LVM_Type
LVM_Merge	Interpreter.h	/^    LVM_Merge,$/;"	e	enum:souffle::LVM_Type
LVM_Negation	Interpreter.h	/^    LVM_Negation,$/;"	e	enum:souffle::LVM_Type
LVM_Number	Interpreter.h	/^    LVM_Number,$/;"	e	enum:souffle::LVM_Type
LVM_OP_ADD	Interpreter.h	/^    LVM_OP_ADD,$/;"	e	enum:souffle::LVM_Type
LVM_OP_BAND	Interpreter.h	/^    LVM_OP_BAND,$/;"	e	enum:souffle::LVM_Type
LVM_OP_BNOT	Interpreter.h	/^    LVM_OP_BNOT,$/;"	e	enum:souffle::LVM_Type
LVM_OP_BOR	Interpreter.h	/^    LVM_OP_BOR,$/;"	e	enum:souffle::LVM_Type
LVM_OP_BXOR	Interpreter.h	/^    LVM_OP_BXOR,$/;"	e	enum:souffle::LVM_Type
LVM_OP_CAT	Interpreter.h	/^    LVM_OP_CAT,$/;"	e	enum:souffle::LVM_Type
LVM_OP_CONTAINS	Interpreter.h	/^    LVM_OP_CONTAINS,$/;"	e	enum:souffle::LVM_Type
LVM_OP_DIV	Interpreter.h	/^    LVM_OP_DIV,$/;"	e	enum:souffle::LVM_Type
LVM_OP_EQ	Interpreter.h	/^    LVM_OP_EQ,$/;"	e	enum:souffle::LVM_Type
LVM_OP_EXP	Interpreter.h	/^    LVM_OP_EXP,$/;"	e	enum:souffle::LVM_Type
LVM_OP_GE	Interpreter.h	/^    LVM_OP_GE,$/;"	e	enum:souffle::LVM_Type
LVM_OP_GT	Interpreter.h	/^    LVM_OP_GT,$/;"	e	enum:souffle::LVM_Type
LVM_OP_LAND	Interpreter.h	/^    LVM_OP_LAND,$/;"	e	enum:souffle::LVM_Type
LVM_OP_LE	Interpreter.h	/^    LVM_OP_LE,$/;"	e	enum:souffle::LVM_Type
LVM_OP_LNOT	Interpreter.h	/^    LVM_OP_LNOT,$/;"	e	enum:souffle::LVM_Type
LVM_OP_LOR	Interpreter.h	/^    LVM_OP_LOR,$/;"	e	enum:souffle::LVM_Type
LVM_OP_LT	Interpreter.h	/^    LVM_OP_LT,$/;"	e	enum:souffle::LVM_Type
LVM_OP_MATCH	Interpreter.h	/^    LVM_OP_MATCH,$/;"	e	enum:souffle::LVM_Type
LVM_OP_MAX	Interpreter.h	/^    LVM_OP_MAX,$/;"	e	enum:souffle::LVM_Type
LVM_OP_MIN	Interpreter.h	/^    LVM_OP_MIN,$/;"	e	enum:souffle::LVM_Type
LVM_OP_MOD	Interpreter.h	/^    LVM_OP_MOD,$/;"	e	enum:souffle::LVM_Type
LVM_OP_MUL	Interpreter.h	/^    LVM_OP_MUL,$/;"	e	enum:souffle::LVM_Type
LVM_OP_NE	Interpreter.h	/^    LVM_OP_NE,$/;"	e	enum:souffle::LVM_Type
LVM_OP_NEG	Interpreter.h	/^    LVM_OP_NEG,$/;"	e	enum:souffle::LVM_Type
LVM_OP_NOT_CONTAINS	Interpreter.h	/^    LVM_OP_NOT_CONTAINS,$/;"	e	enum:souffle::LVM_Type
LVM_OP_NOT_MATCH	Interpreter.h	/^    LVM_OP_NOT_MATCH,$/;"	e	enum:souffle::LVM_Type
LVM_OP_ORD	Interpreter.h	/^    LVM_OP_ORD,$/;"	e	enum:souffle::LVM_Type
LVM_OP_STRLEN	Interpreter.h	/^    LVM_OP_STRLEN,$/;"	e	enum:souffle::LVM_Type
LVM_OP_SUB	Interpreter.h	/^    LVM_OP_SUB,$/;"	e	enum:souffle::LVM_Type
LVM_OP_SUBSTR	Interpreter.h	/^    LVM_OP_SUBSTR,$/;"	e	enum:souffle::LVM_Type
LVM_OP_TONUMBER	Interpreter.h	/^    LVM_OP_TONUMBER,$/;"	e	enum:souffle::LVM_Type
LVM_OP_TOSTRING	Interpreter.h	/^    LVM_OP_TOSTRING,$/;"	e	enum:souffle::LVM_Type
LVM_POP	Interpreter.h	/^    LVM_POP$/;"	e	enum:souffle::LVM_Type
LVM_PackRecord	Interpreter.h	/^    LVM_PackRecord,$/;"	e	enum:souffle::LVM_Type
LVM_Parallel	Interpreter.h	/^    LVM_Parallel,$/;"	e	enum:souffle::LVM_Type
LVM_Project	Interpreter.h	/^    LVM_Project,$/;"	e	enum:souffle::LVM_Type
LVM_ProvenanceExistenceCheck	Interpreter.h	/^    LVM_ProvenanceExistenceCheck,$/;"	e	enum:souffle::LVM_Type
LVM_Query	Interpreter.h	/^    LVM_Query,$/;"	e	enum:souffle::LVM_Type
LVM_Return	Interpreter.h	/^    LVM_Return,$/;"	e	enum:souffle::LVM_Type
LVM_STOP	Interpreter.h	/^    LVM_STOP,$/;"	e	enum:souffle::LVM_Type
LVM_Scan	Interpreter.h	/^    LVM_Scan,$/;"	e	enum:souffle::LVM_Type
LVM_Sequence	Interpreter.h	/^    LVM_Sequence,$/;"	e	enum:souffle::LVM_Type
LVM_Stop_Parallel	Interpreter.h	/^    LVM_Stop_Parallel,$/;"	e	enum:souffle::LVM_Type
LVM_Store	Interpreter.h	/^    LVM_Store,$/;"	e	enum:souffle::LVM_Type
LVM_Stratum	Interpreter.h	/^    LVM_Stratum,$/;"	e	enum:souffle::LVM_Type
LVM_Swap	Interpreter.h	/^    LVM_Swap,$/;"	e	enum:souffle::LVM_Type
LVM_Type	Interpreter.h	/^enum LVM_Type {$/;"	g	namespace:souffle
LVM_UnpackRecord	Interpreter.h	/^    LVM_UnpackRecord,$/;"	e	enum:souffle::LVM_Type
LVM_UserDefinedOperator	Interpreter.h	/^    LVM_UserDefinedOperator,$/;"	e	enum:souffle::LVM_Type
L_AND	parser.hh	/^        L_AND = 330,$/;"	e	enum:yy::parser::token::yytokentype
L_NOT	parser.hh	/^        L_NOT = 332,$/;"	e	enum:yy::parser::token::yytokentype
L_OR	parser.hh	/^        L_OR = 331,$/;"	e	enum:yy::parser::token::yytokentype
LambdaAstVisitor	AstVisitor.h	/^    LambdaAstVisitor(std::function<R(const N&)> lambda) : lambda(std::move(lambda)) {}$/;"	f	struct:souffle::detail::LambdaAstVisitor
LambdaAstVisitor	AstVisitor.h	/^struct LambdaAstVisitor : public AstVisitor<void> {$/;"	s	namespace:souffle::detail
LambdaBTree	LambdaBTree.h	/^    LambdaBTree(const Comparator& comp = Comparator(), const WeakComparator& weak_comp = WeakComparator())$/;"	f	class:souffle::detail::LambdaBTree
LambdaBTree	LambdaBTree.h	/^class LambdaBTree : public btree<Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator,$/;"	c	namespace:souffle::detail
LambdaBTreeSet	LambdaBTree.h	/^    LambdaBTreeSet(LambdaBTreeSet&& other) : super(std::move(other)) {}$/;"	f	class:souffle::LambdaBTreeSet
LambdaBTreeSet	LambdaBTree.h	/^    LambdaBTreeSet(const Comparator& comp = Comparator()) : super(comp) {}$/;"	f	class:souffle::LambdaBTreeSet
LambdaBTreeSet	LambdaBTree.h	/^    LambdaBTreeSet(const Iter& a, const Iter& b) {$/;"	f	class:souffle::LambdaBTreeSet
LambdaBTreeSet	LambdaBTree.h	/^    LambdaBTreeSet(const LambdaBTreeSet& other) : super(other) {}$/;"	f	class:souffle::LambdaBTreeSet
LambdaBTreeSet	LambdaBTree.h	/^    LambdaBTreeSet(s size, n* root, l* leftmost) : super::parenttype(size, root, leftmost) {}$/;"	f	class:souffle::LambdaBTreeSet
LambdaBTreeSet	LambdaBTree.h	/^class LambdaBTreeSet$/;"	c	namespace:souffle
LambdaNodeMapper	AstNode.h	/^    LambdaNodeMapper(const Lambda& lambda) : lambda(lambda) {}$/;"	f	class:souffle::detail::LambdaNodeMapper
LambdaNodeMapper	AstNode.h	/^class LambdaNodeMapper : public AstNodeMapper {$/;"	c	namespace:souffle::detail
LambdaRamNodeMapper	RamNode.h	/^    LambdaRamNodeMapper(const Lambda& lambda) : lambda(lambda) {}$/;"	f	class:souffle::detail::LambdaRamNodeMapper
LambdaRamNodeMapper	RamNode.h	/^class LambdaRamNodeMapper : public RamNodeMapper {$/;"	c	namespace:souffle::detail
LambdaRamVisitor	RamVisitor.h	/^    LambdaRamVisitor(std::function<R(const N&)> lambda) : lambda(std::move(lambda)) {}$/;"	f	struct:souffle::detail::LambdaRamVisitor
LambdaRamVisitor	RamVisitor.h	/^struct LambdaRamVisitor : public RamVisitor<void> {$/;"	s	namespace:souffle::detail
LeafNode	ExplainTree.h	/^    LeafNode(const std::string& t = "") : TreeNode(t) {}$/;"	f	class:souffle::LeafNode
LeafNode	ExplainTree.h	/^class LeafNode : public TreeNode {$/;"	c	namespace:souffle
Lease	ParallelUtils.h	/^        Lease(Lease&& other) : mux(other.mux) {$/;"	f	struct:souffle::Lock::Lease
Lease	ParallelUtils.h	/^        Lease(int version = 0) : version(version) {}$/;"	f	class:souffle::OptimisticReadWriteLock::Lease
Lease	ParallelUtils.h	/^        Lease(std::mutex& mux) : mux(&mux) {$/;"	f	struct:souffle::Lock::Lease
Lease	ParallelUtils.h	/^    class Lease {$/;"	c	class:souffle::OptimisticReadWriteLock
Lease	ParallelUtils.h	/^    class Lease {};$/;"	c	class:souffle::souffle::OptimisticReadWriteLock
Lease	ParallelUtils.h	/^    class Lease {};$/;"	c	struct:souffle::souffle::Lock
Lease	ParallelUtils.h	/^    struct Lease {$/;"	s	class:souffle::Lock
LevelConditionsTransformer	RamTransforms.h	/^class LevelConditionsTransformer : public RamTransformer {$/;"	c	namespace:souffle
Location	AstTranslator.h	/^        Location(const Location& l) : identifier(l.identifier), element(l.element) {$/;"	f	struct:souffle::AstTranslator::Location
Location	AstTranslator.h	/^        Location(int ident, int elem, std::unique_ptr<RamRelationReference> rel = nullptr)$/;"	f	struct:souffle::AstTranslator::Location
Location	AstTranslator.h	/^    struct Location {$/;"	s	class:souffle::AstTranslator
Lock	ParallelUtils.h	/^class Lock {$/;"	c	namespace:souffle
Lock	ParallelUtils.h	/^struct Lock {$/;"	s	namespace:souffle::souffle
LogStatement	LogStatement.h	/^class LogStatement {$/;"	c	namespace:souffle
Logger	Logger.h	/^    Logger(std::string label, size_t iteration) : Logger(label, iteration, []() { return 0; }) {}$/;"	f	class:souffle::Logger
Logger	Logger.h	/^    Logger(std::string label, size_t iteration, std::function<size_t()> size)$/;"	f	class:souffle::Logger
Logger	Logger.h	/^class Logger {$/;"	c	namespace:souffle
LogicbloxConverter	souffle2lb.cpp	/^    LogicbloxConverter(std::ostream& imOut, std::ostream& exOut, std::ostream& decOut)$/;"	f	class:souffle::LogicbloxConverter
LogicbloxConverter	souffle2lb.cpp	/^class LogicbloxConverter : private AstVisitor<void, std::ostream&> {$/;"	c	namespace:souffle	file:
LowLevelMachine	Interpreter.h	/^   LowLevelMachine(RamTranslationUnit& tUnit) : translationUnit(tUnit), generator(tUnit.getSymbolTable()){}$/;"	f	class:souffle::LowLevelMachine
LowLevelMachine	Interpreter.h	/^class LowLevelMachine {$/;"	c	namespace:souffle
MAINT	Makefile	/^MAINT = #$/;"	m
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/missing makeinfo$/;"	m
MANIFEST_TOOL	Makefile	/^MANIFEST_TOOL = :$/;"	m
MATCH	BinaryConstraintOps.h	/^    MATCH,          \/\/ matching string$/;"	m	class:souffle::BinaryConstraintOp
MAX	FunctorOps.h	/^    MAX,   \/\/ max of two numbers$/;"	m	class:souffle::FunctorOp
MAX	RamOperation.h	/^    enum Function { MAX, MIN, COUNT, SUM };$/;"	e	enum:souffle::RamAggregate::Function
MAX	parser.hh	/^        MAX = 279,$/;"	e	enum:yy::parser::token::yytokentype
MAX_AST_DOMAIN	AstTypes.h	/^#define MAX_AST_DOMAIN /;"	d
MAX_INSTANTIATION_DEPTH	ComponentModel.cpp	/^static const unsigned int MAX_INSTANTIATION_DEPTH = 1000;$/;"	m	namespace:souffle::__anon73	file:
MAX_RAM_DOMAIN	RamTypes.h	/^#define MAX_RAM_DOMAIN /;"	d
MAX_THREADS	ParallelUtils.h	/^#define MAX_THREADS /;"	d
MAX_TREE_HEIGHT	Explain.h	/^#define MAX_TREE_HEIGHT /;"	d
MAX_TREE_WIDTH	Explain.h	/^#define MAX_TREE_WIDTH /;"	d
MCPP	Makefile	/^MCPP = mcpp$/;"	m
MIN	FunctorOps.h	/^    MIN,   \/\/ min of two numbers$/;"	m	class:souffle::FunctorOp
MIN	RamOperation.h	/^    enum Function { MAX, MIN, COUNT, SUM };$/;"	e	enum:souffle::RamAggregate::Function
MIN	parser.hh	/^        MIN = 278,$/;"	e	enum:yy::parser::token::yytokentype
MINUS	parser.hh	/^        MINUS = 308,$/;"	e	enum:yy::parser::token::yytokentype
MIN_AST_DOMAIN	AstTypes.h	/^#define MIN_AST_DOMAIN /;"	d
MIN_RAM_DOMAIN	RamTypes.h	/^#define MIN_RAM_DOMAIN /;"	d
MKDIR_P	Makefile	/^MKDIR_P = ..\/.\/install-sh -c -d$/;"	m
MOD	FunctorOps.h	/^    MOD,   \/\/ modulus$/;"	m	class:souffle::FunctorOp
MUL	FunctorOps.h	/^    MUL,   \/\/ multiplication$/;"	m	class:souffle::FunctorOp
M_UNIT_TEST	IndexSetAnalysis.h	/^#define M_UNIT_TEST$/;"	d
MagicSetTransformer	AstTransforms.h	/^class MagicSetTransformer : public AstTransformer {$/;"	c	namespace:souffle
MainConfig	Global.h	/^    MainConfig() : BaseTable<std::string, std::string>() {}$/;"	f	class:souffle::MainConfig
MainConfig	Global.h	/^class MainConfig : public BaseTable<std::string, std::string> {$/;"	c	namespace:souffle
MainOption	Global.h	/^struct MainOption {$/;"	s	namespace:souffle
MaterializeAggregationQueriesTransformer	AstTransforms.h	/^class MaterializeAggregationQueriesTransformer : public AstTransformer {$/;"	c	namespace:souffle
MaxMatching	IndexSetAnalysis.h	/^class MaxMatching {$/;"	c	namespace:souffle
MetaTransformer	AstTransformer.h	/^class MetaTransformer : public AstTransformer {$/;"	c	namespace:souffle
MinimiseProgramTransformer	AstTransforms.h	/^class MinimiseProgramTransformer : public AstTransformer {$/;"	c	namespace:souffle
NAME	profile/DataComparator.h	/^    static bool NAME(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
NE	BinaryConstraintOps.h	/^    NE,             \/\/ whether two values are different$/;"	m	class:souffle::BinaryConstraintOp
NEG	FunctorOps.h	/^    NEG,       \/\/ numeric negation$/;"	m	class:souffle::FunctorOp
NEG	parser.hh	/^        NEG = 333$/;"	e	enum:yy::parser::token::yytokentype
NIL	IndexSetAnalysis.h	/^#define NIL /;"	d
NIL	parser.hh	/^        NIL = 301,$/;"	e	enum:yy::parser::token::yytokentype
NM	Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = nmedit$/;"	m
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NOT_MATCH	BinaryConstraintOps.h	/^    NOT_MATCH,      \/\/ not matching string$/;"	m	class:souffle::BinaryConstraintOp
NR_T	profile/DataComparator.h	/^    static bool NR_T(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
NUL	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
NUMBER	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
NUMBER	parser.hh	/^        NUMBER = 261,$/;"	e	enum:yy::parser::token::yytokentype
NUMBER_TYPE	parser.hh	/^        NUMBER_TYPE = 296,$/;"	e	enum:yy::parser::token::yytokentype
NUM_CELLS	Brie.h	/^    static const int NUM_CELLS = 1 << BIT_PER_STEP;$/;"	m	class:souffle::SparseArray
Node	Brie.h	/^    struct Node {$/;"	s	class:souffle::SparseArray
NonRecursiveRelationNumberProcessor	EventProcessor.h	/^    NonRecursiveRelationNumberProcessor() {$/;"	f	class:souffle::profile::NonRecursiveRelationNumberProcessor
NonRecursiveRelationNumberProcessor	EventProcessor.h	/^const class NonRecursiveRelationNumberProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
NonRecursiveRelationTimingProcessor	EventProcessor.h	/^    NonRecursiveRelationTimingProcessor() {$/;"	f	class:souffle::profile::NonRecursiveRelationTimingProcessor
NonRecursiveRelationTimingProcessor	EventProcessor.h	/^const class NonRecursiveRelationTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
NonRecursiveRuleNumberProcessor	EventProcessor.h	/^    NonRecursiveRuleNumberProcessor() {$/;"	f	class:souffle::profile::NonRecursiveRuleNumberProcessor
NonRecursiveRuleNumberProcessor	EventProcessor.h	/^const class NonRecursiveRuleNumberProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
NonRecursiveRuleTimingProcessor	EventProcessor.h	/^    NonRecursiveRuleTimingProcessor() {$/;"	f	class:souffle::profile::NonRecursiveRuleTimingProcessor
NonRecursiveRuleTimingProcessor	EventProcessor.h	/^const class NonRecursiveRuleTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
NonRecursiveRuleVisitor	profile/Reader.h	/^    NonRecursiveRuleVisitor(Rule& rule) : DSNVisitor(rule) {}$/;"	f	class:souffle::profile::__anon72::NonRecursiveRuleVisitor
NonRecursiveRuleVisitor	profile/Reader.h	/^class NonRecursiveRuleVisitor : public DSNVisitor<Rule> {$/;"	c	namespace:souffle::profile::__anon72
NonRecursiveRulesVisitor	profile/Reader.h	/^    NonRecursiveRulesVisitor(Relation& relation) : relation(relation) {}$/;"	f	class:souffle::profile::__anon72::NonRecursiveRulesVisitor
NonRecursiveRulesVisitor	profile/Reader.h	/^class NonRecursiveRulesVisitor : public Visitor {$/;"	c	namespace:souffle::profile::__anon72
NormaliseConstraintsTransformer	AstTransforms.h	/^class NormaliseConstraintsTransformer : public AstTransformer {$/;"	c	namespace:souffle
NullBuffer	Util.h	/^    struct NullBuffer : public std::streambuf {$/;"	s	class:souffle::NullStream
NullStream	Util.h	/^    NullStream() : std::ostream(&buffer) {}$/;"	f	class:souffle::NullStream
NullStream	Util.h	/^class NullStream : public std::ostream {$/;"	c	namespace:souffle
NullStruct	json11.h	/^struct NullStruct {$/;"	s	namespace:json11
NullTransformer	AstTransformer.h	/^class NullTransformer : public MetaTransformer {$/;"	c	namespace:souffle
NullableVector	InlineRelationsTransformer.cpp	/^    NullableVector(std::vector<T> vector) : vector(std::move(vector)), valid(true) {}$/;"	f	class:souffle::NullableVector
NullableVector	InlineRelationsTransformer.cpp	/^class NullableVector {$/;"	c	namespace:souffle	file:
OBJDUMP	Makefile	/^OBJDUMP = objdump$/;"	m
OBJECT	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
OPENMP_CFLAGS	Makefile	/^OPENMP_CFLAGS = $/;"	m
ORD	FunctorOps.h	/^    ORD,       \/\/ ordinal number of a string$/;"	m	class:souffle::FunctorOp
ORD	parser.hh	/^        ORD = 275,$/;"	e	enum:yy::parser::token::yytokentype
OTOOL	Makefile	/^OTOOL = otool$/;"	m
OTOOL64	Makefile	/^OTOOL64 = :$/;"	m
OUTPUT_DECL	parser.hh	/^        OUTPUT_DECL = 290,$/;"	e	enum:yy::parser::token::yytokentype
OUTPUT_QUALIFIER	parser.hh	/^        OUTPUT_QUALIFIER = 264,$/;"	e	enum:yy::parser::token::yytokentype
OUTPUT_RELATION	AstRelation.h	/^#define OUTPUT_RELATION /;"	d
OVERRIDABLE_QUALIFIER	parser.hh	/^        OVERRIDABLE_QUALIFIER = 270,$/;"	e	enum:yy::parser::token::yytokentype
OVERRIDABLE_RELATION	AstRelation.h	/^#define OVERRIDABLE_RELATION /;"	d
OVERRIDE	parser.hh	/^        OVERRIDE = 292,$/;"	e	enum:yy::parser::token::yytokentype
Op	AstArgument.h	/^    enum Op { min, max, count, sum };$/;"	g	class:souffle::AstAggregator
OptimisticReadWriteLock	ParallelUtils.h	/^    OptimisticReadWriteLock() : version(0) {}$/;"	f	class:souffle::OptimisticReadWriteLock
OptimisticReadWriteLock	ParallelUtils.h	/^class OptimisticReadWriteLock {$/;"	c	namespace:souffle
OptimisticReadWriteLock	ParallelUtils.h	/^class OptimisticReadWriteLock {$/;"	c	namespace:souffle::souffle
OutputProcessor	profile/OutputProcessor.h	/^    OutputProcessor() {$/;"	f	class:souffle::profile::OutputProcessor
OutputProcessor	profile/OutputProcessor.h	/^class OutputProcessor {$/;"	c	namespace:souffle::profile
PACKAGE	Makefile	/^PACKAGE = souffle$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = souffle-talk@googlegroups.com$/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = souffle$/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = souffle 1.0.0-3315-g27d34e2$/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = souffle$/;"	m
PACKAGE_URL	Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = 1.0.0-3315-g27d34e2$/;"	m
PARALLEL_END	ParallelUtils.h	/^#define PARALLEL_END /;"	d
PARALLEL_START	ParallelUtils.h	/^#define PARALLEL_START /;"	d
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
PERCENT	parser.hh	/^        PERCENT = 321,$/;"	e	enum:yy::parser::token::yytokentype
PIPE	parser.hh	/^        PIPE = 302,$/;"	e	enum:yy::parser::token::yytokentype
PKGBUILD	Makefile	/^PKGBUILD = $/;"	m
PKG_CONFIG	Makefile	/^PKG_CONFIG = \/usr\/local\/bin\/pkg-config$/;"	m
PKG_CONFIG_LIBDIR	Makefile	/^PKG_CONFIG_LIBDIR = $/;"	m
PKG_CONFIG_PATH	Makefile	/^PKG_CONFIG_PATH = \/usr\/local\/opt\/libffi\/lib\/pkgconfig$/;"	m
PLAN	parser.hh	/^        PLAN = 285,$/;"	e	enum:yy::parser::token::yytokentype
PLUS	parser.hh	/^        PLUS = 307,$/;"	e	enum:yy::parser::token::yytokentype
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
PRAGMA	parser.hh	/^        PRAGMA = 263,$/;"	e	enum:yy::parser::token::yytokentype
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
PRINT	SymbolTable.h	/^        PRINT = 5,$/;"	e	enum:souffle::SymbolTable::__anon65
PRINTSIZE_DECL	parser.hh	/^        PRINTSIZE_DECL = 291,$/;"	e	enum:yy::parser::token::yytokentype
PRINTSIZE_QUALIFIER	parser.hh	/^        PRINTSIZE_QUALIFIER = 266,$/;"	e	enum:yy::parser::token::yytokentype
PRINTSIZE_RELATION	AstRelation.h	/^#define PRINTSIZE_RELATION /;"	d
PRINT_BEGIN_COMMENT	Synthesiser.cpp	/^#define PRINT_BEGIN_COMMENT(/;"	d	file:
PRINT_END_COMMENT	Synthesiser.cpp	/^#define PRINT_END_COMMENT(/;"	d	file:
PROGRAMS	Makefile	/^PROGRAMS = $(bin_PROGRAMS)$/;"	m
ParserDriver	ParserDriver.h	/^class ParserDriver {$/;"	c	namespace:souffle
PartitionBodyLiteralsTransformer	AstTransforms.h	/^class PartitionBodyLiteralsTransformer : public AstTransformer {$/;"	c	namespace:souffle
PiggyList	PiggyList.h	/^    PiggyList() : num_containers(0), container_size(0), m_size(0) {}$/;"	f	class:souffle::PiggyList
PiggyList	PiggyList.h	/^    PiggyList(const PiggyList& other) : BLOCKBITS(other.BLOCKBITS) {$/;"	f	class:souffle::PiggyList
PiggyList	PiggyList.h	/^    PiggyList(size_t initialbitsize)$/;"	f	class:souffle::PiggyList
PiggyList	PiggyList.h	/^class PiggyList {$/;"	c	namespace:souffle
PipelineTransformer	AstTransforms.h	/^    PipelineTransformer(Args... args) {$/;"	f	class:souffle::PipelineTransformer
PipelineTransformer	AstTransforms.h	/^class PipelineTransformer : public MetaTransformer {$/;"	c	namespace:souffle
Point	SrcLocation.h	/^    struct Point {$/;"	s	class:souffle::SrcLocation
PrecedenceGraph	PrecedenceGraph.h	/^class PrecedenceGraph : public AstAnalysis {$/;"	c	namespace:souffle
PredefinedType	TypeSystem.cpp	/^    PredefinedType(const TypeEnvironment& environment, const AstTypeIdentifier& name)$/;"	f	struct:souffle::PredefinedType
PredefinedType	TypeSystem.cpp	/^struct PredefinedType : public Type {$/;"	s	namespace:souffle	file:
PrimitiveType	TypeSystem.h	/^    PrimitiveType(const TypeEnvironment& environment, const AstTypeIdentifier& name, const Type& base)$/;"	f	class:souffle::PrimitiveType
PrimitiveType	TypeSystem.h	/^class PrimitiveType : public Type {$/;"	c	namespace:souffle
Problem	Constraints.h	/^class Problem {$/;"	c	namespace:souffle
ProfileEventSingleton	ProfileEvent.h	/^class ProfileEventSingleton {$/;"	c	namespace:souffle
ProfileTimer	ProfileEvent.h	/^        ProfileTimer(uint32_t interval = 10) : t(interval) {}$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
ProfileTimer	ProfileEvent.h	/^    class ProfileTimer {$/;"	c	class:souffle::ProfileEventSingleton
ProgramFactory	SouffleInterface.h	/^    ProgramFactory(std::string name) : name(std::move(name)) {$/;"	f	class:souffle::ProgramFactory
ProgramFactory	SouffleInterface.h	/^class ProgramFactory {$/;"	c	namespace:souffle
ProgramResourceUtilisationProcessor	EventProcessor.h	/^    ProgramResourceUtilisationProcessor() {$/;"	f	class:souffle::profile::ProgramResourceUtilisationProcessor
ProgramResourceUtilisationProcessor	EventProcessor.h	/^const class ProgramResourceUtilisationProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
ProgramRun	profile/ProgramRun.h	/^    ProgramRun() : relationMap() {}$/;"	f	class:souffle::profile::ProgramRun
ProgramRun	profile/ProgramRun.h	/^class ProgramRun {$/;"	c	namespace:souffle::profile
ProgramRuntimeProcessor	EventProcessor.h	/^    ProgramRuntimeProcessor() {$/;"	f	class:souffle::profile::ProgramRuntimeProcessor
ProgramRuntimeProcessor	EventProcessor.h	/^const class ProgramRuntimeProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
ProgramTimepointProcessor	EventProcessor.h	/^    ProgramTimepointProcessor() {$/;"	f	class:souffle::profile::ProgramTimepointProcessor
ProgramTimepointProcessor	EventProcessor.h	/^const class ProgramTimepointProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
ProvenanceClauseTranslator	AstTranslator.h	/^        ProvenanceClauseTranslator(AstTranslator& translator) : ClauseTranslator(translator) {}$/;"	f	class:souffle::AstTranslator::ProvenanceClauseTranslator
ProvenanceClauseTranslator	AstTranslator.h	/^    class ProvenanceClauseTranslator : public ClauseTranslator {$/;"	c	class:souffle::AstTranslator
ProvenanceTransformer	AstTransforms.h	/^class ProvenanceTransformer : public AstTransformer {$/;"	c	namespace:souffle
RAM_DOMAIN_SIZE	RamTypes.h	/^#define RAM_DOMAIN_SIZE /;"	d
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RBRACE	parser.hh	/^        RBRACE = 323,$/;"	e	enum:yy::parser::token::yytokentype
RBRACKET	parser.hh	/^        RBRACKET = 304,$/;"	e	enum:yy::parser::token::yytokentype
READ_OP_CONTEXT	ParallelUtils.h	/^#define READ_OP_CONTEXT(/;"	d
RECHECK_LOGS	Makefile	/^RECHECK_LOGS = $(TEST_LOGS)$/;"	m
REJECT	scanner.cc	/^#define REJECT /;"	d	file:
RELOP	parser.hh	/^        RELOP = 262,$/;"	e	enum:yy::parser::token::yytokentype
RESERVED	parser.hh	/^        RESERVED = 258,$/;"	e	enum:yy::parser::token::yytokentype
RESOLVE	SymbolTable.h	/^        RESOLVE = 6,$/;"	e	enum:souffle::SymbolTable::__anon65
RN_Aggregate	RamNode.h	/^    RN_Aggregate,$/;"	e	enum:souffle::RamNodeType
RN_Argument	RamNode.h	/^    RN_Argument,$/;"	e	enum:souffle::RamNodeType
RN_AutoIncrement	RamNode.h	/^    RN_AutoIncrement,$/;"	e	enum:souffle::RamNodeType
RN_Clear	RamNode.h	/^    RN_Clear,$/;"	e	enum:souffle::RamNodeType
RN_Conjunction	RamNode.h	/^    RN_Conjunction,$/;"	e	enum:souffle::RamNodeType
RN_Constraint	RamNode.h	/^    RN_Constraint,$/;"	e	enum:souffle::RamNodeType
RN_Create	RamNode.h	/^    RN_Create,$/;"	e	enum:souffle::RamNodeType
RN_DebugInfo	RamNode.h	/^    RN_DebugInfo,$/;"	e	enum:souffle::RamNodeType
RN_Drop	RamNode.h	/^    RN_Drop,$/;"	e	enum:souffle::RamNodeType
RN_ElementAccess	RamNode.h	/^    RN_ElementAccess,$/;"	e	enum:souffle::RamNodeType
RN_EmptinessCheck	RamNode.h	/^    RN_EmptinessCheck,$/;"	e	enum:souffle::RamNodeType
RN_ExistenceCheck	RamNode.h	/^    RN_ExistenceCheck,$/;"	e	enum:souffle::RamNodeType
RN_Exit	RamNode.h	/^    RN_Exit,$/;"	e	enum:souffle::RamNodeType
RN_Fact	RamNode.h	/^    RN_Fact,$/;"	e	enum:souffle::RamNodeType
RN_Filter	RamNode.h	/^    RN_Filter,$/;"	e	enum:souffle::RamNodeType
RN_IndexScan	RamNode.h	/^    RN_IndexScan,$/;"	e	enum:souffle::RamNodeType
RN_IntrinsicOperator	RamNode.h	/^    RN_IntrinsicOperator,$/;"	e	enum:souffle::RamNodeType
RN_Load	RamNode.h	/^    RN_Load,$/;"	e	enum:souffle::RamNodeType
RN_LogSize	RamNode.h	/^    RN_LogSize,$/;"	e	enum:souffle::RamNodeType
RN_LogTimer	RamNode.h	/^    RN_LogTimer,$/;"	e	enum:souffle::RamNodeType
RN_Loop	RamNode.h	/^    RN_Loop,$/;"	e	enum:souffle::RamNodeType
RN_Merge	RamNode.h	/^    RN_Merge,$/;"	e	enum:souffle::RamNodeType
RN_Negation	RamNode.h	/^    RN_Negation,$/;"	e	enum:souffle::RamNodeType
RN_Notify	RamNode.h	/^    RN_Notify,$/;"	e	enum:souffle::RamNodeType
RN_Number	RamNode.h	/^    RN_Number,$/;"	e	enum:souffle::RamNodeType
RN_PackRecord	RamNode.h	/^    RN_PackRecord,$/;"	e	enum:souffle::RamNodeType
RN_Parallel	RamNode.h	/^    RN_Parallel,$/;"	e	enum:souffle::RamNodeType
RN_Program	RamNode.h	/^    RN_Program,$/;"	e	enum:souffle::RamNodeType
RN_Project	RamNode.h	/^    RN_Project,$/;"	e	enum:souffle::RamNodeType
RN_ProvenanceExistenceCheck	RamNode.h	/^    RN_ProvenanceExistenceCheck,$/;"	e	enum:souffle::RamNodeType
RN_Query	RamNode.h	/^    RN_Query,$/;"	e	enum:souffle::RamNodeType
RN_Recv	RamNode.h	/^    RN_Recv,$/;"	e	enum:souffle::RamNodeType
RN_Relation	RamNode.h	/^    RN_Relation,$/;"	e	enum:souffle::RamNodeType
RN_RelationReference	RamNode.h	/^    RN_RelationReference,$/;"	e	enum:souffle::RamNodeType
RN_Return	RamNode.h	/^    RN_Return,$/;"	e	enum:souffle::RamNodeType
RN_Scan	RamNode.h	/^    RN_Scan,$/;"	e	enum:souffle::RamNodeType
RN_Send	RamNode.h	/^    RN_Send,$/;"	e	enum:souffle::RamNodeType
RN_Sequence	RamNode.h	/^    RN_Sequence,$/;"	e	enum:souffle::RamNodeType
RN_Store	RamNode.h	/^    RN_Store,$/;"	e	enum:souffle::RamNodeType
RN_Stratum	RamNode.h	/^    RN_Stratum$/;"	e	enum:souffle::RamNodeType
RN_Swap	RamNode.h	/^    RN_Swap,$/;"	e	enum:souffle::RamNodeType
RN_UnpackRecord	RamNode.h	/^    RN_UnpackRecord,$/;"	e	enum:souffle::RamNodeType
RN_UserDefinedOperator	RamNode.h	/^    RN_UserDefinedOperator,$/;"	e	enum:souffle::RamNodeType
RN_Wait	RamNode.h	/^    RN_Wait,$/;"	e	enum:souffle::RamNodeType
RPAREN	parser.hh	/^        RPAREN = 311,$/;"	e	enum:yy::parser::token::yytokentype
R_T	profile/DataComparator.h	/^    static bool R_T(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
RamAbstractExistenceCheck	RamCondition.h	/^    RamAbstractExistenceCheck(RamNodeType type, std::unique_ptr<RamRelationReference> relRef,$/;"	f	class:souffle::RamAbstractExistenceCheck
RamAbstractExistenceCheck	RamCondition.h	/^class RamAbstractExistenceCheck : public RamCondition {$/;"	c	namespace:souffle
RamAggregate	RamOperation.h	/^    RamAggregate(std::unique_ptr<RamOperation> nested, Function fun,$/;"	f	class:souffle::RamAggregate
RamAggregate	RamOperation.h	/^class RamAggregate : public RamSearch {$/;"	c	namespace:souffle
RamAnalysis	RamAnalysis.h	/^class RamAnalysis {$/;"	c	namespace:souffle
RamArgument	RamExpression.h	/^    RamArgument(size_t number) : RamExpression(RN_Argument), number(number) {}$/;"	f	class:souffle::RamArgument
RamArgument	RamExpression.h	/^class RamArgument : public RamExpression {$/;"	c	namespace:souffle
RamAutoIncrement	RamExpression.h	/^    RamAutoIncrement() : RamExpression(RN_AutoIncrement) {}$/;"	f	class:souffle::RamAutoIncrement
RamAutoIncrement	RamExpression.h	/^class RamAutoIncrement : public RamExpression {$/;"	c	namespace:souffle
RamClear	RamStatement.h	/^    RamClear(std::unique_ptr<RamRelationReference> relRef)$/;"	f	class:souffle::RamClear
RamClear	RamStatement.h	/^class RamClear : public RamRelationStatement {$/;"	c	namespace:souffle
RamCondition	RamCondition.h	/^    RamCondition(RamNodeType type) : RamNode(type) {}$/;"	f	class:souffle::RamCondition
RamCondition	RamCondition.h	/^class RamCondition : public RamNode {$/;"	c	namespace:souffle
RamConditionLevelAnalysis	RamConditionLevel.h	/^class RamConditionLevelAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamConjunction	RamCondition.h	/^    RamConjunction(std::unique_ptr<RamCondition> l, std::unique_ptr<RamCondition> r)$/;"	f	class:souffle::RamConjunction
RamConjunction	RamCondition.h	/^class RamConjunction : public RamCondition {$/;"	c	namespace:souffle
RamConstValueAnalysis	RamConstValue.h	/^class RamConstValueAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamConstraint	RamCondition.h	/^    RamConstraint(BinaryConstraintOp op, std::unique_ptr<RamExpression> l, std::unique_ptr<RamExpression> r)$/;"	f	class:souffle::RamConstraint
RamConstraint	RamCondition.h	/^class RamConstraint : public RamCondition {$/;"	c	namespace:souffle
RamCreate	RamStatement.h	/^    RamCreate(std::unique_ptr<RamRelationReference> relRef)$/;"	f	class:souffle::RamCreate
RamCreate	RamStatement.h	/^class RamCreate : public RamRelationStatement {$/;"	c	namespace:souffle
RamDebugInfo	RamStatement.h	/^    RamDebugInfo(std::unique_ptr<RamStatement> stmt, std::string msg)$/;"	f	class:souffle::RamDebugInfo
RamDebugInfo	RamStatement.h	/^class RamDebugInfo : public RamStatement {$/;"	c	namespace:souffle
RamDrop	RamStatement.h	/^    RamDrop(std::unique_ptr<RamRelationReference> relRef)$/;"	f	class:souffle::RamDrop
RamDrop	RamStatement.h	/^class RamDrop : public RamRelationStatement {$/;"	c	namespace:souffle
RamElementAccess	RamExpression.h	/^    RamElementAccess(size_t ident, size_t elem, std::unique_ptr<RamRelationReference> relRef = nullptr)$/;"	f	class:souffle::RamElementAccess
RamElementAccess	RamExpression.h	/^class RamElementAccess : public RamExpression {$/;"	c	namespace:souffle
RamEmptinessCheck	RamCondition.h	/^    RamEmptinessCheck(std::unique_ptr<RamRelationReference> relRef)$/;"	f	class:souffle::RamEmptinessCheck
RamEmptinessCheck	RamCondition.h	/^class RamEmptinessCheck : public RamCondition {$/;"	c	namespace:souffle
RamExistenceCheck	RamCondition.h	/^    RamExistenceCheck($/;"	f	class:souffle::RamExistenceCheck
RamExistenceCheck	RamCondition.h	/^class RamExistenceCheck : public RamAbstractExistenceCheck {$/;"	c	namespace:souffle
RamExistenceCheckAnalysis	RamExistenceCheckAnalysis.h	/^class RamExistenceCheckAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamExit	RamStatement.h	/^    RamExit(std::unique_ptr<RamCondition> c) : RamStatement(RN_Exit), condition(std::move(c)) {}$/;"	f	class:souffle::RamExit
RamExit	RamStatement.h	/^class RamExit : public RamStatement {$/;"	c	namespace:souffle
RamExpression	RamExpression.h	/^    RamExpression(RamNodeType type) : RamNode(type) {}$/;"	f	class:souffle::RamExpression
RamExpression	RamExpression.h	/^class RamExpression : public RamNode {$/;"	c	namespace:souffle
RamExpressionLevelAnalysis	RamExpressionLevel.h	/^class RamExpressionLevelAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamFact	RamStatement.h	/^    RamFact(std::unique_ptr<RamRelationReference> relRef, std::vector<std::unique_ptr<RamExpression>>&& v)$/;"	f	class:souffle::RamFact
RamFact	RamStatement.h	/^class RamFact : public RamRelationStatement {$/;"	c	namespace:souffle
RamFilter	RamOperation.h	/^    RamFilter(std::unique_ptr<RamCondition> cond, std::unique_ptr<RamOperation> nested,$/;"	f	class:souffle::RamFilter
RamFilter	RamOperation.h	/^class RamFilter : public RamNestedOperation {$/;"	c	namespace:souffle
RamIndexScan	RamOperation.h	/^    RamIndexScan(std::unique_ptr<RamRelationReference> r, size_t ident,$/;"	f	class:souffle::RamIndexScan
RamIndexScan	RamOperation.h	/^class RamIndexScan : public RamRelationSearch {$/;"	c	namespace:souffle
RamIndexScanKeysAnalysis	RamIndexScanKeys.h	/^class RamIndexScanKeysAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamIntrinsicOperator	RamExpression.h	/^    RamIntrinsicOperator(FunctorOp op, Args... args) : RamExpression(RN_IntrinsicOperator), operation(op) {$/;"	f	class:souffle::RamIntrinsicOperator
RamIntrinsicOperator	RamExpression.h	/^    RamIntrinsicOperator(FunctorOp op, std::vector<std::unique_ptr<RamExpression>> args)$/;"	f	class:souffle::RamIntrinsicOperator
RamIntrinsicOperator	RamExpression.h	/^class RamIntrinsicOperator : public RamExpression {$/;"	c	namespace:souffle
RamLoad	RamStatement.h	/^    RamLoad(std::unique_ptr<RamRelationReference> relRef, std::vector<IODirectives> ioDirectives)$/;"	f	class:souffle::RamLoad
RamLoad	RamStatement.h	/^class RamLoad : public RamRelationStatement {$/;"	c	namespace:souffle
RamLogSize	RamStatement.h	/^    RamLogSize(std::unique_ptr<RamRelationReference> relRef, std::string message)$/;"	f	class:souffle::RamLogSize
RamLogSize	RamStatement.h	/^class RamLogSize : public RamRelationStatement {$/;"	c	namespace:souffle
RamLogTimer	RamStatement.h	/^    RamLogTimer($/;"	f	class:souffle::RamLogTimer
RamLogTimer	RamStatement.h	/^class RamLogTimer : public RamStatement {$/;"	c	namespace:souffle
RamLoop	RamStatement.h	/^    RamLoop(std::unique_ptr<RamStatement> b) : RamStatement(RN_Loop), body(std::move(b)) {}$/;"	f	class:souffle::RamLoop
RamLoop	RamStatement.h	/^    RamLoop(std::unique_ptr<RamStatement> f, std::unique_ptr<RamStatement> s, std::unique_ptr<Stmts>... rest)$/;"	f	class:souffle::RamLoop
RamLoop	RamStatement.h	/^class RamLoop : public RamStatement {$/;"	c	namespace:souffle
RamMerge	RamStatement.h	/^    RamMerge(std::unique_ptr<RamRelationReference> tRef, std::unique_ptr<RamRelationReference> sRef)$/;"	f	class:souffle::RamMerge
RamMerge	RamStatement.h	/^class RamMerge : public RamStatement {$/;"	c	namespace:souffle
RamNegation	RamCondition.h	/^    RamNegation(std::unique_ptr<RamCondition> operand)$/;"	f	class:souffle::RamNegation
RamNegation	RamCondition.h	/^class RamNegation : public RamCondition {$/;"	c	namespace:souffle
RamNestedOperation	RamOperation.h	/^    RamNestedOperation(RamNodeType type, std::unique_ptr<RamOperation> nested, std::string profileText = "")$/;"	f	class:souffle::RamNestedOperation
RamNestedOperation	RamOperation.h	/^class RamNestedOperation : public RamOperation {$/;"	c	namespace:souffle
RamNode	RamNode.h	/^    RamNode(RamNodeType type) : type(type) {}$/;"	f	class:souffle::RamNode
RamNode	RamNode.h	/^class RamNode {$/;"	c	namespace:souffle
RamNodeMapper	RamNode.h	/^class RamNodeMapper {$/;"	c	namespace:souffle
RamNodeType	RamNode.h	/^enum RamNodeType {$/;"	g	namespace:souffle
RamNotify	RamStatement.h	/^    RamNotify() : RamStatement(RN_Notify) {}$/;"	f	class:souffle::RamNotify
RamNotify	RamStatement.h	/^class RamNotify : public RamStatement {$/;"	c	namespace:souffle
RamNumber	RamExpression.h	/^    RamNumber(RamDomain c) : RamExpression(RN_Number), constant(c) {}$/;"	f	class:souffle::RamNumber
RamNumber	RamExpression.h	/^class RamNumber : public RamExpression {$/;"	c	namespace:souffle
RamOperation	RamOperation.h	/^    RamOperation(RamNodeType type) : RamNode(type) {}$/;"	f	class:souffle::RamOperation
RamOperation	RamOperation.h	/^class RamOperation : public RamNode {$/;"	c	namespace:souffle
RamOperationDepthAnalysis	RamOperationDepth.h	/^class RamOperationDepthAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamPackRecord	RamExpression.h	/^    RamPackRecord(std::vector<std::unique_ptr<RamExpression>> args)$/;"	f	class:souffle::RamPackRecord
RamPackRecord	RamExpression.h	/^class RamPackRecord : public RamExpression {$/;"	c	namespace:souffle
RamParallel	RamStatement.h	/^    RamParallel() : RamStatement(RN_Parallel) {}$/;"	f	class:souffle::RamParallel
RamParallel	RamStatement.h	/^class RamParallel : public RamStatement {$/;"	c	namespace:souffle
RamProgram	RamProgram.h	/^    RamProgram() : RamNode(RN_Program) {}$/;"	f	class:souffle::RamProgram
RamProgram	RamProgram.h	/^    RamProgram(std::unique_ptr<RamStatement> main) : RamNode(RN_Program), main(std::move(main)) {}$/;"	f	class:souffle::RamProgram
RamProgram	RamProgram.h	/^class RamProgram : public RamNode {$/;"	c	namespace:souffle
RamProject	RamOperation.h	/^    RamProject(std::unique_ptr<RamRelationReference> relRef,$/;"	f	class:souffle::RamProject
RamProject	RamOperation.h	/^class RamProject : public RamOperation {$/;"	c	namespace:souffle
RamProvenanceExistenceCheck	RamCondition.h	/^    RamProvenanceExistenceCheck($/;"	f	class:souffle::RamProvenanceExistenceCheck
RamProvenanceExistenceCheck	RamCondition.h	/^class RamProvenanceExistenceCheck : public RamAbstractExistenceCheck {$/;"	c	namespace:souffle
RamProvenanceExistenceCheckAnalysis	RamProvenanceExistenceCheckAnalysis.h	/^class RamProvenanceExistenceCheckAnalysis : public RamAnalysis {$/;"	c	namespace:souffle
RamQuery	RamStatement.h	/^    RamQuery(std::unique_ptr<RamOperation> o, std::unique_ptr<RamCondition> c = nullptr)$/;"	f	class:souffle::RamQuery
RamQuery	RamStatement.h	/^class RamQuery : public RamStatement {$/;"	c	namespace:souffle
RamRecv	RamStatement.h	/^    RamRecv(std::unique_ptr<RamRelationReference> r, const int s)$/;"	f	class:souffle::RamRecv
RamRecv	RamStatement.h	/^class RamRecv : public RamRelationStatement {$/;"	c	namespace:souffle
RamRelation	RamRelation.h	/^    RamRelation(const std::string name, const size_t arity, const std::vector<std::string> attributeNames,$/;"	f	class:souffle::RamRelation
RamRelation	RamRelation.h	/^class RamRelation : public RamNode {$/;"	c	namespace:souffle
RamRelationReference	RamRelation.h	/^    RamRelationReference(const RamRelation* relation) : RamNode(RN_RelationReference), relation(relation) {$/;"	f	class:souffle::RamRelationReference
RamRelationReference	RamRelation.h	/^class RamRelationReference : public RamNode {$/;"	c	namespace:souffle
RamRelationSearch	RamOperation.h	/^    RamRelationSearch(RamNodeType type, std::unique_ptr<RamRelationReference> relRef, size_t ident,$/;"	f	class:souffle::RamRelationSearch
RamRelationSearch	RamOperation.h	/^class RamRelationSearch : public RamSearch {$/;"	c	namespace:souffle
RamRelationStatement	RamStatement.h	/^    RamRelationStatement(RamNodeType type, std::unique_ptr<RamRelationReference> relRef)$/;"	f	class:souffle::RamRelationStatement
RamRelationStatement	RamStatement.h	/^class RamRelationStatement : public RamStatement {$/;"	c	namespace:souffle
RamReturn	RamOperation.h	/^    RamReturn(std::vector<std::unique_ptr<RamExpression>> vals)$/;"	f	class:souffle::RamReturn
RamReturn	RamOperation.h	/^class RamReturn : public RamOperation {$/;"	c	namespace:souffle
RamScan	RamOperation.h	/^    RamScan(std::unique_ptr<RamRelationReference> rel, size_t ident, std::unique_ptr<RamOperation> nested,$/;"	f	class:souffle::RamScan
RamScan	RamOperation.h	/^class RamScan : public RamRelationSearch {$/;"	c	namespace:souffle
RamSearch	RamOperation.h	/^    RamSearch(RamNodeType type, size_t ident, std::unique_ptr<RamOperation> nested,$/;"	f	class:souffle::RamSearch
RamSearch	RamOperation.h	/^class RamSearch : public RamNestedOperation {$/;"	c	namespace:souffle
RamSend	RamStatement.h	/^    RamSend(std::unique_ptr<RamRelationReference> r, const std::set<size_t> s)$/;"	f	class:souffle::RamSend
RamSend	RamStatement.h	/^class RamSend : public RamRelationStatement {$/;"	c	namespace:souffle
RamSequence	RamStatement.h	/^    RamSequence() : RamStatement(RN_Sequence) {}$/;"	f	class:souffle::RamSequence
RamSequence	RamStatement.h	/^    RamSequence(std::unique_ptr<Stmts>&&... stmts) : RamStatement(RN_Sequence) {$/;"	f	class:souffle::RamSequence
RamSequence	RamStatement.h	/^class RamSequence : public RamStatement {$/;"	c	namespace:souffle
RamStatement	RamStatement.h	/^    RamStatement(RamNodeType type) : RamNode(type) {}$/;"	f	class:souffle::RamStatement
RamStatement	RamStatement.h	/^class RamStatement : public RamNode {$/;"	c	namespace:souffle
RamStore	RamStatement.h	/^    RamStore(std::unique_ptr<RamRelationReference> relRef, std::vector<IODirectives> ioDirectives)$/;"	f	class:souffle::RamStore
RamStore	RamStatement.h	/^class RamStore : public RamRelationStatement {$/;"	c	namespace:souffle
RamStratum	RamStatement.h	/^    RamStratum(std::unique_ptr<RamStatement> b, const int i)$/;"	f	class:souffle::RamStratum
RamStratum	RamStatement.h	/^class RamStratum : public RamStatement {$/;"	c	namespace:souffle
RamSwap	RamStatement.h	/^    RamSwap(std::unique_ptr<RamRelationReference> f, std::unique_ptr<RamRelationReference> s)$/;"	f	class:souffle::RamSwap
RamSwap	RamStatement.h	/^class RamSwap : public RamStatement {$/;"	c	namespace:souffle
RamTransformer	RamTransformer.h	/^class RamTransformer {$/;"	c	namespace:souffle
RamTranslationUnit	RamTranslationUnit.h	/^    RamTranslationUnit(std::unique_ptr<RamProgram> program, SymbolTable& sym, ErrorReport& e, DebugReport& d)$/;"	f	class:souffle::RamTranslationUnit
RamTranslationUnit	RamTranslationUnit.h	/^class RamTranslationUnit {$/;"	c	namespace:souffle
RamUnpackRecord	RamOperation.h	/^    RamUnpackRecord(std::unique_ptr<RamOperation> nested, size_t ident, size_t ref_level, size_t ref_pos,$/;"	f	class:souffle::RamUnpackRecord
RamUnpackRecord	RamOperation.h	/^class RamUnpackRecord : public RamSearch {$/;"	c	namespace:souffle
RamUserDefinedOperator	RamExpression.h	/^    RamUserDefinedOperator(std::string n, std::string t, std::vector<std::unique_ptr<RamExpression>> args)$/;"	f	class:souffle::RamUserDefinedOperator
RamUserDefinedOperator	RamExpression.h	/^class RamUserDefinedOperator : public RamExpression {$/;"	c	namespace:souffle
RamVisitor	RamVisitor.h	/^struct RamVisitor : public ram_visitor_tag {$/;"	s	namespace:souffle
RamWait	RamStatement.h	/^    RamWait(const size_t c) : RamStatement(RN_Wait), count(c) {}$/;"	f	class:souffle::RamWait
RamWait	RamStatement.h	/^class RamWait : public RamStatement {$/;"	c	namespace:souffle
RandomInsertPiggyList	PiggyList.h	/^    RandomInsertPiggyList(const RandomInsertPiggyList& other) : BLOCKBITS(other.BLOCKBITS) {$/;"	f	class:souffle::RandomInsertPiggyList
RandomInsertPiggyList	PiggyList.h	/^    RandomInsertPiggyList(size_t initialbitsize) : BLOCKBITS(initialbitsize) {}$/;"	f	class:souffle::RandomInsertPiggyList
RandomInsertPiggyList	PiggyList.h	/^class RandomInsertPiggyList {$/;"	c	namespace:souffle
ReadCinCSVFactory	ReadStreamCSV.h	/^class ReadCinCSVFactory : public ReadStreamFactory {$/;"	c	namespace:souffle
ReadFileCSV	ReadStreamCSV.h	/^    ReadFileCSV(const std::vector<bool>& symbolMask, SymbolTable& symbolTable,$/;"	f	class:souffle::ReadFileCSV
ReadFileCSV	ReadStreamCSV.h	/^class ReadFileCSV : public ReadStreamCSV {$/;"	c	namespace:souffle
ReadFileCSVFactory	ReadStreamCSV.h	/^class ReadFileCSVFactory : public ReadStreamFactory {$/;"	c	namespace:souffle
ReadSQLiteFactory	ReadStreamSQLite.h	/^class ReadSQLiteFactory : public ReadStreamFactory {$/;"	c	namespace:souffle
ReadStream	ReadStream.h	/^    ReadStream(const std::vector<bool>& symbolMask, SymbolTable& symbolTable, const bool prov)$/;"	f	class:souffle::ReadStream
ReadStream	ReadStream.h	/^class ReadStream {$/;"	c	namespace:souffle
ReadStreamCSV	ReadStreamCSV.h	/^    ReadStreamCSV(std::istream& file, const std::vector<bool>& symbolMask, SymbolTable& symbolTable,$/;"	f	class:souffle::ReadStreamCSV
ReadStreamCSV	ReadStreamCSV.h	/^class ReadStreamCSV : public ReadStream {$/;"	c	namespace:souffle
ReadStreamFactory	ReadStream.h	/^class ReadStreamFactory {$/;"	c	namespace:souffle
ReadStreamSQLite	ReadStreamSQLite.h	/^    ReadStreamSQLite(const std::string& dbFilename, const std::string& relationName,$/;"	f	class:souffle::ReadStreamSQLite
ReadStreamSQLite	ReadStreamSQLite.h	/^class ReadStreamSQLite : public ReadStream {$/;"	c	namespace:souffle
ReadWriteLock	ParallelUtils.h	/^    ReadWriteLock() : lck(0) {}$/;"	f	class:souffle::ReadWriteLock
ReadWriteLock	ParallelUtils.h	/^class ReadWriteLock {$/;"	c	namespace:souffle
ReadWriteLock	ParallelUtils.h	/^class ReadWriteLock {$/;"	c	namespace:souffle::souffle
Reader	profile/Reader.h	/^    Reader(std::shared_ptr<ProgramRun> run) : run(std::move(run)) {}$/;"	f	class:souffle::profile::Reader
Reader	profile/Reader.h	/^    Reader(std::string filename, std::shared_ptr<ProgramRun> run)$/;"	f	class:souffle::profile::Reader
Reader	profile/Reader.h	/^class Reader {$/;"	c	namespace:souffle::profile
RecordMap	CompiledRecord.h	/^class RecordMap {$/;"	c	namespace:souffle::detail
RecordMap	InterpreterRecords.cpp	/^    RecordMap(int arity) : arity(arity), i2r(1) {}  \/\/ note: index 0 element left free$/;"	f	class:souffle::__anon67::RecordMap
RecordMap	InterpreterRecords.cpp	/^class RecordMap {$/;"	c	namespace:souffle::__anon67	file:
RecordType	TypeSystem.h	/^    RecordType(const TypeEnvironment& environment, const AstTypeIdentifier& name) : Type(environment, name) {}$/;"	f	struct:souffle::RecordType
RecordType	TypeSystem.h	/^struct RecordType : public Type {$/;"	s	namespace:souffle
RecursiveClauses	PrecedenceGraph.h	/^class RecursiveClauses : public AstAnalysis {$/;"	c	namespace:souffle
RecursiveRelationCopyTimingProcessor	EventProcessor.h	/^    RecursiveRelationCopyTimingProcessor() {$/;"	f	class:souffle::profile::RecursiveRelationCopyTimingProcessor
RecursiveRelationCopyTimingProcessor	EventProcessor.h	/^const class RecursiveRelationCopyTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RecursiveRelationNumberProcessor	EventProcessor.h	/^    RecursiveRelationNumberProcessor() {$/;"	f	class:souffle::profile::RecursiveRelationNumberProcessor
RecursiveRelationNumberProcessor	EventProcessor.h	/^const class RecursiveRelationNumberProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RecursiveRelationTimingProcessor	EventProcessor.h	/^    RecursiveRelationTimingProcessor() {$/;"	f	class:souffle::profile::RecursiveRelationTimingProcessor
RecursiveRelationTimingProcessor	EventProcessor.h	/^const class RecursiveRelationTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RecursiveRuleNumberProcessor	EventProcessor.h	/^    RecursiveRuleNumberProcessor() {$/;"	f	class:souffle::profile::RecursiveRuleNumberProcessor
RecursiveRuleNumberProcessor	EventProcessor.h	/^const class RecursiveRuleNumberProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RecursiveRuleTimingProcessor	EventProcessor.h	/^    RecursiveRuleTimingProcessor() {$/;"	f	class:souffle::profile::RecursiveRuleTimingProcessor
RecursiveRuleTimingProcessor	EventProcessor.h	/^const class RecursiveRuleTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RecursiveRuleVisitor	profile/Reader.h	/^    RecursiveRuleVisitor(Rule& rule) : DSNVisitor(rule) {}$/;"	f	class:souffle::profile::__anon72::RecursiveRuleVisitor
RecursiveRuleVisitor	profile/Reader.h	/^class RecursiveRuleVisitor : public DSNVisitor<Rule> {$/;"	c	namespace:souffle::profile::__anon72
RecursiveRulesVisitor	profile/Reader.h	/^    RecursiveRulesVisitor(Iteration& iteration, Relation& relation)$/;"	f	class:souffle::profile::__anon72::RecursiveRulesVisitor
RecursiveRulesVisitor	profile/Reader.h	/^class RecursiveRulesVisitor : public Visitor {$/;"	c	namespace:souffle::profile::__anon72
ReduceExistentialsTransformer	AstTransforms.h	/^class ReduceExistentialsTransformer : public AstTransformer {$/;"	c	namespace:souffle
RedundantRelations	PrecedenceGraph.h	/^class RedundantRelations : public AstAnalysis {$/;"	c	namespace:souffle
Relation	CompiledRelation.h	/^class Relation : public Setup::template relation<arity, Indices...> {};$/;"	c	namespace:souffle::ram
Relation	SouffleInterface.h	/^class Relation {$/;"	c	namespace:souffle
Relation	profile/Relation.h	/^    Relation(std::string name, std::string id) : name(std::move(name)), id(std::move(id)) {$/;"	f	class:souffle::profile::Relation
Relation	profile/Relation.h	/^class Relation {$/;"	c	namespace:souffle::profile
RelationBase	CompiledRelation.h	/^struct RelationBase {$/;"	s	namespace:souffle::ram::detail
RelationIOTimingProcessor	EventProcessor.h	/^    RelationIOTimingProcessor() {$/;"	f	class:souffle::profile::RelationIOTimingProcessor
RelationIOTimingProcessor	EventProcessor.h	/^const class RelationIOTimingProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RelationReadsProcessor	EventProcessor.h	/^    RelationReadsProcessor() {$/;"	f	class:souffle::profile::RelationReadsProcessor
RelationReadsProcessor	EventProcessor.h	/^const class RelationReadsProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
RelationRepresentation	RelationRepresentation.h	/^enum class RelationRepresentation {$/;"	c	namespace:souffle
RelationSchedule	PrecedenceGraph.h	/^class RelationSchedule : public AstAnalysis {$/;"	c	namespace:souffle
RelationScheduleStep	PrecedenceGraph.h	/^    RelationScheduleStep(std::set<const AstRelation*> computedRelations,$/;"	f	class:souffle::RelationScheduleStep
RelationScheduleStep	PrecedenceGraph.h	/^class RelationScheduleStep {$/;"	c	namespace:souffle
RelationVisitor	profile/Reader.h	/^    RelationVisitor(Relation& relation) : DSNVisitor(relation) {}$/;"	f	class:souffle::profile::__anon72::RelationVisitor
RelationVisitor	profile/Reader.h	/^class RelationVisitor : public DSNVisitor<Relation> {$/;"	c	namespace:souffle::profile::__anon72
RelationWrapper	CompiledSouffle.h	/^    RelationWrapper(RelType& r, SymbolTable& s, std::string name, const std::array<const char*, Arity>& t,$/;"	f	class:souffle::RelationWrapper
RelationWrapper	CompiledSouffle.h	/^class RelationWrapper : public Relation {$/;"	c	namespace:souffle
RelationcreateId	profile/Reader.h	/^    std::string RelationcreateId() {$/;"	f	class:souffle::profile::Reader
RemoveBooleanConstraintsTransformer	AstTransforms.h	/^class RemoveBooleanConstraintsTransformer : public AstTransformer {$/;"	c	namespace:souffle
RemoveEmptyRelationsTransformer	AstTransforms.h	/^class RemoveEmptyRelationsTransformer : public AstTransformer {$/;"	c	namespace:souffle
RemoveRedundantRelationsTransformer	AstTransforms.h	/^class RemoveRedundantRelationsTransformer : public AstTransformer {$/;"	c	namespace:souffle
RemoveRelationCopiesTransformer	AstTransforms.h	/^class RemoveRelationCopiesTransformer : public AstTransformer {$/;"	c	namespace:souffle
ReorderLiteralsTransformer	AstTransforms.h	/^class ReorderLiteralsTransformer : public AstTransformer {$/;"	c	namespace:souffle
ReplaceSingletonVariablesTransformer	AstTransforms.h	/^class ReplaceSingletonVariablesTransformer : public AstTransformer {$/;"	c	namespace:souffle
ResolveAliasesTransformer	AstTransforms.h	/^class ResolveAliasesTransformer : public AstTransformer {$/;"	c	namespace:souffle
RootInfo	Brie.h	/^    struct RootInfo {$/;"	s	class:souffle::SparseArray
RootInfoSnapshot	Brie.h	/^    struct RootInfoSnapshot {$/;"	s	class:souffle::SparseArray
Row	profile/Row.h	/^    Row(unsigned long size) : cells() {$/;"	f	class:souffle::profile::Row
Row	profile/Row.h	/^class Row {$/;"	c	namespace:souffle::profile
Rule	profile/Rule.h	/^    Rule(std::string name, int version, std::string id)$/;"	f	class:souffle::profile::Rule
Rule	profile/Rule.h	/^    Rule(std::string name, std::string id) : name(std::move(name)), identifier(std::move(id)) {}$/;"	f	class:souffle::profile::Rule
Rule	profile/Rule.h	/^class Rule {$/;"	c	namespace:souffle::profile
RuleBody	AstParserUtils.h	/^class RuleBody {$/;"	c	namespace:souffle
S	test/test.h	/^#define S(/;"	d
SCCGraph	PrecedenceGraph.h	/^class SCCGraph : public AstAnalysis {$/;"	c	namespace:souffle
SCRIPTS	Makefile	/^SCRIPTS = $(dist_bin_SCRIPTS)$/;"	m
SECTIONS_END	ParallelUtils.h	/^#define SECTIONS_END /;"	d
SECTIONS_START	ParallelUtils.h	/^#define SECTIONS_START /;"	d
SECTION_END	ParallelUtils.h	/^#define SECTION_END /;"	d
SECTION_START	ParallelUtils.h	/^#define SECTION_START /;"	d
SED	Makefile	/^SED = \/usr\/bin\/sed$/;"	m
SEMICOLON	parser.hh	/^        SEMICOLON = 314,$/;"	e	enum:yy::parser::token::yytokentype
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SIZE	SymbolTable.h	/^        SIZE = 7,$/;"	e	enum:souffle::SymbolTable::__anon65
SLASH	parser.hh	/^        SLASH = 319,$/;"	e	enum:yy::parser::token::yytokentype
SLOOKUP	StringPool.h	/^#define SLOOKUP(/;"	d
SOUFFLE_CXXFLAGS	Makefile	/^SOUFFLE_CXXFLAGS =  -Wall -std=c++11 -DUSE_PROVENANCE  -O3 -DUSE_LIBZ  -DUSE_SQLITE   $/;"	m
SOUFFLE_DLL	Interpreter.h	/^#define SOUFFLE_DLL /;"	d
SOURCES	Makefile	/^SOURCES = $(libsouffle_la_SOURCES) $(souffle_SOURCES) \\$/;"	m
STANDARD	json11.h	/^enum JsonParse { STANDARD, COMMENTS };$/;"	e	enum:json11::JsonParse
STAR	parser.hh	/^        STAR = 317,$/;"	e	enum:yy::parser::token::yytokentype
STRICT	parser.hh	/^        STRICT = 284,$/;"	e	enum:yy::parser::token::yytokentype
STRING	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	e	enum:json11::final::Type
STRING	parser.hh	/^        STRING = 259,$/;"	e	enum:yy::parser::token::yytokentype
STRIP	Makefile	/^STRIP = strip$/;"	m
STRLEN	FunctorOps.h	/^    STRLEN,    \/\/ length of a string$/;"	m	class:souffle::FunctorOp
STRLEN	parser.hh	/^        STRLEN = 276,$/;"	e	enum:yy::parser::token::yytokentype
SUB	FunctorOps.h	/^    SUB,   \/\/ subtraction$/;"	m	class:souffle::FunctorOp
SUBSTR	FunctorOps.h	/^    SUBSTR,  \/\/ addition$/;"	m	class:souffle::FunctorOp
SUBSTR	parser.hh	/^        SUBSTR = 277,$/;"	e	enum:yy::parser::token::yytokentype
SUFFIXES	Makefile	/^SUFFIXES = .cpp .h .yy .ll .cc .hh .h$/;"	m
SUM	RamOperation.h	/^    enum Function { MAX, MIN, COUNT, SUM };$/;"	e	enum:souffle::RamAggregate::Function
SUM	parser.hh	/^        SUM = 281,$/;"	e	enum:yy::parser::token::yytokentype
SUPPRESSED_RELATION	AstRelation.h	/^#define SUPPRESSED_RELATION /;"	d
SYMBOL_TYPE	parser.hh	/^        SYMBOL_TYPE = 297,$/;"	e	enum:yy::parser::token::yytokentype
S_	test/test.h	/^#define S_(/;"	d
S__LINE__	test/test.h	/^#define S__LINE__ /;"	d
ScreenBuffer	ExplainTree.h	/^    ScreenBuffer(uint32_t w, uint32_t h) : width(w), height(h), buffer(nullptr) {$/;"	f	class:souffle::ScreenBuffer
ScreenBuffer	ExplainTree.h	/^class ScreenBuffer {$/;"	c	namespace:souffle
SignalHandler	SignalHandler.h	/^    SignalHandler() : msg(nullptr) {}$/;"	f	class:souffle::SignalHandler
SignalHandler	SignalHandler.h	/^class SignalHandler {$/;"	c	namespace:souffle
SingleIndexRelation	CompiledRelation.h	/^class SingleIndexRelation : public RelationBase<arity, SingleIndexRelation<arity, Index, table_factory>> {$/;"	c	namespace:souffle::ram::detail
SingleIndexTypeRelation	CompiledRelation.h	/^class SingleIndexTypeRelation : public DirectIndexedRelation<IndexFactory, arity, Indices...> {};$/;"	c	namespace:souffle::ram::detail
SingleIndexTypeRelation	CompiledRelation.h	/^class SingleIndexTypeRelation<IndexFactory, 0> : public AutoRelation<0> {};$/;"	c	namespace:souffle::ram::detail
SingleIndexTypeRelation	CompiledRelation.h	/^class SingleIndexTypeRelation<IndexFactory, arity, Index>$/;"	c	namespace:souffle::ram::detail
SingleIndexTypeRelation	CompiledRelation.h	/^class SingleIndexTypeRelation<IndexFactory, arity>$/;"	c	namespace:souffle::ram::detail
SingleValueIterator	IterUtils.h	/^    SingleValueIterator(const T& value) : value(value), end(false) {}$/;"	f	class:souffle::SingleValueIterator
SingleValueIterator	IterUtils.h	/^class SingleValueIterator : public std::iterator<std::forward_iterator_tag, T> {$/;"	c	namespace:souffle
SizeEntry	ProfileDatabase.h	/^    SizeEntry(const std::string& key, size_t size) : Entry(key), size(size) {}$/;"	f	class:souffle::profile::SizeEntry
SizeEntry	ProfileDatabase.h	/^class SizeEntry : public Entry {$/;"	c	namespace:souffle::profile
SouffleProgram	SouffleInterface.h	/^class SouffleProgram {$/;"	c	namespace:souffle
SparseArray	Brie.h	/^    SparseArray() : unsynced(RootInfo{nullptr, 0, 0, nullptr, std::numeric_limits<index_type>::max()}) {}$/;"	f	class:souffle::SparseArray
SparseArray	Brie.h	/^    SparseArray(SparseArray&& other)$/;"	f	class:souffle::SparseArray
SparseArray	Brie.h	/^    SparseArray(const SparseArray& other)$/;"	f	class:souffle::SparseArray
SparseArray	Brie.h	/^class SparseArray {$/;"	c	namespace:souffle
SparseBitMap	Brie.h	/^class SparseBitMap {$/;"	c	namespace:souffle
SparseDisjointSet	UnionFind.h	/^class SparseDisjointSet {$/;"	c	namespace:souffle
SpinLock	ParallelUtils.h	/^    SpinLock() : lck(0) {}$/;"	f	class:souffle::SpinLock
SpinLock	ParallelUtils.h	/^class SpinLock {$/;"	c	namespace:souffle
SpinLock	ParallelUtils.h	/^class SpinLock {$/;"	c	namespace:souffle::souffle
SplitStream	Util.h	/^    SplitStream(std::ostream* stream1, std::ostream* stream2) : std::ostream(this) {$/;"	f	class:souffle::SplitStream
SplitStream	Util.h	/^    SplitStream(std::vector<std::ostream*> streams) : std::ostream(this), streams(std::move(streams)) {}$/;"	f	class:souffle::SplitStream
SplitStream	Util.h	/^class SplitStream : public std::ostream, public std::streambuf {$/;"	c	namespace:souffle
SrcLocation	SrcLocation.h	/^class SrcLocation {$/;"	c	namespace:souffle
Statics	json11.h	/^struct Statics {$/;"	s	namespace:json11
Status	Mpi.h	/^typedef std::unique_ptr<MPI_Status> Status;$/;"	t	namespace:souffle::mpi::__anon52
StringPool	StringPool.h	/^class StringPool {$/;"	c	namespace:souffle
Substitution	ResolveAliasesTransformer.cpp	/^    Substitution(const std::string& var, const AstArgument* arg) {$/;"	f	class:souffle::__anon71::Substitution
Substitution	ResolveAliasesTransformer.cpp	/^class Substitution {$/;"	c	namespace:souffle::__anon71	file:
SymbolTable	SymbolTable.h	/^    SymbolTable(const SymbolTable& other) : numToStr(other.numToStr), strToNum(other.strToNum) {}$/;"	f	class:souffle::SymbolTable
SymbolTable	SymbolTable.h	/^    SymbolTable(std::initializer_list<std::string> symbols) {$/;"	f	class:souffle::SymbolTable
SymbolTable	SymbolTable.h	/^class SymbolTable {$/;"	c	namespace:souffle
Synthesiser	Synthesiser.h	/^    Synthesiser(RamTranslationUnit& tUnit) : translationUnit(tUnit) {}$/;"	f	class:souffle::Synthesiser
Synthesiser	Synthesiser.h	/^class Synthesiser {$/;"	c	namespace:souffle
SynthesiserBrieRelation	SynthesiserRelation.h	/^    SynthesiserBrieRelation(const RamRelation& ramRel, const IndexSet& indexSet, bool isProvenance)$/;"	f	class:souffle::SynthesiserBrieRelation
SynthesiserBrieRelation	SynthesiserRelation.h	/^class SynthesiserBrieRelation : public SynthesiserRelation {$/;"	c	namespace:souffle
SynthesiserDirectRelation	SynthesiserRelation.h	/^    SynthesiserDirectRelation(const RamRelation& ramRel, const IndexSet& indexSet, bool isProvenance)$/;"	f	class:souffle::SynthesiserDirectRelation
SynthesiserDirectRelation	SynthesiserRelation.h	/^class SynthesiserDirectRelation : public SynthesiserRelation {$/;"	c	namespace:souffle
SynthesiserEqrelRelation	SynthesiserRelation.h	/^    SynthesiserEqrelRelation(const RamRelation& ramRel, const IndexSet& indexSet, bool isProvenance)$/;"	f	class:souffle::SynthesiserEqrelRelation
SynthesiserEqrelRelation	SynthesiserRelation.h	/^class SynthesiserEqrelRelation : public SynthesiserRelation {$/;"	c	namespace:souffle
SynthesiserIndirectRelation	SynthesiserRelation.h	/^    SynthesiserIndirectRelation(const RamRelation& ramRel, const IndexSet& indexSet, bool isProvenance)$/;"	f	class:souffle::SynthesiserIndirectRelation
SynthesiserIndirectRelation	SynthesiserRelation.h	/^class SynthesiserIndirectRelation : public SynthesiserRelation {$/;"	c	namespace:souffle
SynthesiserNullaryRelation	SynthesiserRelation.h	/^    SynthesiserNullaryRelation(const RamRelation& ramRel, const IndexSet& indexSet, bool isProvenance)$/;"	f	class:souffle::SynthesiserNullaryRelation
SynthesiserNullaryRelation	SynthesiserRelation.h	/^class SynthesiserNullaryRelation : public SynthesiserRelation {$/;"	c	namespace:souffle
SynthesiserRelation	SynthesiserRelation.h	/^    SynthesiserRelation(const RamRelation& rel, const IndexSet& indices, const bool isProvenance = false)$/;"	f	class:souffle::SynthesiserRelation
SynthesiserRelation	SynthesiserRelation.h	/^class SynthesiserRelation {$/;"	c	namespace:souffle
TCONTAINS	parser.hh	/^        TCONTAINS = 273,$/;"	e	enum:yy::parser::token::yytokentype
TEST	test/ast_parser_utils_test.cpp	/^TEST(RuleBody, Basic) {$/;"	f	namespace:souffle::test
TEST	test/ast_parser_utils_test.cpp	/^TEST(RuleBody, ClauseBodyExtraction) {$/;"	f	namespace:souffle::test
TEST	test/ast_parser_utils_test.cpp	/^TEST(RuleBody, Negation) {$/;"	f	namespace:souffle::test
TEST	test/ast_program_test.cpp	/^TEST(AstProgram, Parse) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(Ast, CloneAndEquals) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, FactTypes) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, GroundTermPropagation) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, GroundTermPropagation2) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, Grounded) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, GroundedRecords) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, NestedFunctions) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, NumericTypes) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, RemoveRelationCopies) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, RemoveRelationCopiesOutput) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, ResolveAliasesWithTermsInAtoms) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, ResolveGroundedAliases) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, SimpleTypes) {$/;"	f	namespace:souffle::test
TEST	test/ast_utils_test.cpp	/^TEST(AstUtils, SubtypeChain) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Basic) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Clear) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Duplicates) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Extend) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, IterBasic) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, IterEmpty) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, IterPartition) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, IterRange) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Merge) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, PairwiseDecremental) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, PairwiseIncremental) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, ParallelScaling) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Scaling) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, Shuffled) {$/;"	f	namespace:souffle::test
TEST	test/binary_relation_test.cpp	/^TEST(EqRelTest, TransitivityTest) {$/;"	f	namespace:souffle::test
TEST	test/brie_test.cpp	/^TEST(SparseArray, Basic) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Copy) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Find) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Find2) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Iterator) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, IteratorStress) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, IteratorStress2) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Limits) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, LowerBound) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, MemoryUsage) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseArray, Merge) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, Basic) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, CopyAndMerge) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, Find) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, Iterator) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, IteratorStress2) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, Size) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(SparseBitMap, Stress) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Basic) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Iterator) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, IteratorStress_0D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, IteratorStress_1D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, IteratorStress_2D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, IteratorStress_3D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, IteratorStress_4D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Limits) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_0D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_1D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_2D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_3D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_Bug) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Merge_Stress) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Parallel) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQuery) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQueryStress) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQuery_0D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQuery_1D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQuery_2D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, RangeQuery_3D) {$/;"	f
TEST	test/brie_test.cpp	/^TEST(Trie, Size) {$/;"	f
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Basic) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, BoundaryEmpty) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, BoundaryTest) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Clear) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Decremental) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Duplicates) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Incremental) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, IteratorBasic) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, IteratorEmpty) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, IteratorStress) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Load) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(BTreeMultiSet, Shuffled) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(Performance, Basic) {$/;"	f	namespace:souffle::test
TEST	test/btree_multiset_test.cpp	/^TEST(Performance, Load) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Basic) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, BoundaryEmpty) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, BoundaryTest) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, ChunkSplit) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, ChunkSplitStress) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Clear) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Copy) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Decremental) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Duplicates) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Incremental) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, IteratorBasic) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, IteratorEmpty) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, IteratorStress) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Load) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Merge) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Parallel) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, ParallelScaling) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(BTreeSet, Shuffled) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(Performance, Basic) {$/;"	f	namespace:souffle::test
TEST	test/btree_set_test.cpp	/^TEST(Performance, Load) {$/;"	f	namespace:souffle::test
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, AllIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, Arity) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, Contains) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, ExtendToFullIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, FullIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, GetPrefix) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, IsCompatibleWith) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, IsPermutation) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, IsPrefix) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_index_utils_test.cpp	/^TEST(IndicesTools, Unique) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, AllIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, Arity) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, Contains) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, ExtendToFullIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, FullIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, GetPrefix) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, IsCompatibleWith) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, IsPermutation) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, IsPrefix) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(IndicesTools, Unique) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Basic) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, BigTuple) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, EqualRange) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Indices) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, NullArity) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, PartitionBug_InsertAll) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Partition_0D) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Partition_1D) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Partition_2D) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, SingleIndex) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, SingleIndexEqualRange) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, SingleIndexLowerUpperBound) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Structure_Auto) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Structure_BTree) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_relation_test.cpp	/^TEST(Relation, Structure_Brie) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_tuple_test.cpp	/^TEST(Tuple, Assign) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_tuple_test.cpp	/^TEST(Tuple, Basic) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_tuple_test.cpp	/^TEST(Tuple, Compare) {$/;"	f	namespace:souffle::ram
TEST	test/compiled_tuple_test.cpp	/^TEST(Tuple, CompareSpeed) {$/;"	f	namespace:souffle::ram
TEST	test/constraints_test.cpp	/^TEST(Constraints, Basic) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(DjTest, Clear) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(DjTest, MakeNode) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(DjTest, ParallelScaling) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(DjTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(DjTest, TestUnion) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(LambdaBTree, ContendParallel) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(LambdaBTreeTest, Insert) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(LambdaBTreeTest, ParallelInsert) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(LambdaBTreeTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, Append) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, CopyCtor) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, DoubleClear) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, ElementCreation) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, Iteration) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, ParallelAppend) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, ParallelElementSpawning) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(PiggyTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(RandomInsertPiggyTest, DoubleClear) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(RandomInsertPiggyTest, Insertion) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(RandomInsertPiggyTest, ParallelInsert) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(RandomInsertPiggyTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, MakeNode) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, ParallelDense) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, ParallelScaling) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, ParallelTest) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, Scoping) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, SignedData) {$/;"	f	namespace:souffle::test
TEST	test/eqrel_datastructure_test.cpp	/^TEST(SparseDjTest, TestUnion) {$/;"	f	namespace:souffle::test
TEST	test/graph_utils_test.cpp	/^TEST(Graph, Basic) {$/;"	f	namespace:souffle::test
TEST	test/matching_test.cpp	/^TEST(Matching, StaticTest_1) {$/;"	f
TEST	test/matching_test.cpp	/^TEST(Matching, StaticTest_2) {$/;"	f
TEST	test/mpi_test.cpp	/^TEST(mpi, mpi) {$/;"	f	namespace:souffle::test
TEST	test/parallel_utils_test.cpp	/^TEST(ParallelUtils, OptimisticReadWriteLock) {$/;"	f	namespace:souffle::test
TEST	test/parallel_utils_test.cpp	/^TEST(ParallelUtils, ReadWriteLock) {$/;"	f	namespace:souffle::test
TEST	test/parallel_utils_test.cpp	/^TEST(ParallelUtils, SpinLock) {$/;"	f	namespace:souffle::test
TEST	test/ram_executor_test.cpp	/^TEST(Ast, CloneAndEquals) {$/;"	f	namespace:souffle::test
TEST	test/ram_relation_stats_test.cpp	/^TEST(Stats, Basic) {$/;"	f	namespace:test
TEST	test/ram_relation_stats_test.cpp	/^TEST(Stats, Convergence) {$/;"	f	namespace:test
TEST	test/ram_relation_stats_test.cpp	/^TEST(Stats, Function) {$/;"	f	namespace:test
TEST	test/symbol_table_test.cpp	/^TEST(SymbolTable, Assign) {$/;"	f	namespace:test
TEST	test/symbol_table_test.cpp	/^TEST(SymbolTable, Basics) {$/;"	f	namespace:test
TEST	test/symbol_table_test.cpp	/^TEST(SymbolTable, Copy) {$/;"	f	namespace:test
TEST	test/symbol_table_test.cpp	/^TEST(SymbolTable, Inserts) {$/;"	f	namespace:test
TEST	test/table_test.cpp	/^TEST(Table, Basic) {$/;"	f	namespace:souffle::test
TEST	test/table_test.cpp	/^TEST(Table, Stress) {$/;"	f	namespace:souffle::test
TEST	test/test.h	/^#define TEST(/;"	d
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, Basic) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, GreatestCommonSubtype) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, LeastCommonSupertype) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, MultipleLeastCommonSupertype) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, isNumberType) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, isRecursiveType) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, isSubtypeOf_Basic) {$/;"	f	namespace:souffle::test
TEST	test/type_system_test.cpp	/^TEST(TypeSystem, isSubtypeOf_Records) {$/;"	f	namespace:souffle::test
TEST	test/util_test.cpp	/^TEST(Util, LRUCache) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, LRUCache_S0) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, LRUCache_S1) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, LRUCache_S2) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, LambdaTraits) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, NullStream) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, Range) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, printMap) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, printSet) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, printVector) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, toString) {$/;"	f
TEST	test/util_test.cpp	/^TEST(Util, toVector) {$/;"	f
TESTS	Makefile	/^TESTS = $(check_PROGRAMS)$/;"	m
TEST_EXTENSIONS	Makefile	/^TEST_EXTENSIONS =  .test$/;"	m
TEST_LOGS	Makefile	/^TEST_LOGS = $(am__test_logs2:.test.log=.log)$/;"	m
TEST_LOG_COMPILE	Makefile	/^TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \\$/;"	m
TEST_LOG_DRIVER	Makefile	/^TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)\/test-driver$/;"	m
TEST_SUITE_LOG	Makefile	/^TEST_SUITE_LOG = test-suite.log$/;"	m
TIME	profile/DataComparator.h	/^    static bool TIME(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
TMATCH	parser.hh	/^        TMATCH = 272,$/;"	e	enum:yy::parser::token::yytokentype
TONUMBER	FunctorOps.h	/^    TONUMBER,  \/\/ convert string to number$/;"	m	class:souffle::FunctorOp
TONUMBER	parser.hh	/^        TONUMBER = 298,$/;"	e	enum:yy::parser::token::yytokentype
TOSTRING	FunctorOps.h	/^    TOSTRING,  \/\/ convert number to string$/;"	m	class:souffle::FunctorOp
TOSTRING	parser.hh	/^        TOSTRING = 299,$/;"	e	enum:yy::parser::token::yytokentype
TRUE	parser.hh	/^        TRUE = 282,$/;"	e	enum:yy::parser::token::yytokentype
TUP	profile/DataComparator.h	/^    static bool TUP(const std::shared_ptr<Row>& a, const std::shared_ptr<Row>& b) {$/;"	f	class:souffle::profile::DataComparator
TYPE	parser.hh	/^        TYPE = 293,$/;"	e	enum:yy::parser::token::yytokentype
Table	Table.h	/^    Table() : head(nullptr), tail(nullptr) {}$/;"	f	class:souffle::Table
Table	Table.h	/^class Table {$/;"	c	namespace:souffle
Table	profile/Table.h	/^    Table() : rows() {}$/;"	f	class:souffle::profile::Table
Table	profile/Table.h	/^class Table {$/;"	c	namespace:souffle::profile
TestAutoIndex	test/matching_test.cpp	/^    TestAutoIndex() : IndexSet(rel) {}$/;"	f	class:TestAutoIndex
TestAutoIndex	test/matching_test.cpp	/^class TestAutoIndex : public IndexSet {$/;"	c	file:
TestCase	test/test.h	/^    TestCase(std::string g, std::string t)$/;"	f	class:TestCase
TestCase	test/test.h	/^class TestCase {$/;"	c
TestLambdaTree	test/eqrel_datastructure_test.cpp	/^        TestLambdaTree;$/;"	t	namespace:souffle::test	file:
TestPair	test/eqrel_datastructure_test.cpp	/^typedef std::pair<size_t, size_t> TestPair;$/;"	t	namespace:souffle::test	file:
TextEntry	ProfileDatabase.h	/^    TextEntry(const std::string& key, std::string text) : Entry(key), text(std::move(text)) {}$/;"	f	class:souffle::profile::TextEntry
TextEntry	ProfileDatabase.h	/^class TextEntry : public Entry {$/;"	c	namespace:souffle::profile
TextProcessor	EventProcessor.h	/^    TextProcessor() {$/;"	f	class:souffle::profile::TextProcessor
TextProcessor	EventProcessor.h	/^const class TextProcessor : public EventProcessor {$/;"	c	namespace:souffle::profile
TimeEntry	ProfileDatabase.h	/^    TimeEntry(const std::string& key, microseconds time) : Entry(key), time(time) {}$/;"	f	class:souffle::profile::DurationEntry::TimeEntry
TimeEntry	ProfileDatabase.h	/^class TimeEntry : public Entry {$/;"	c	class:souffle::profile::DurationEntry
Tools	profile/StringUtils.h	/^namespace Tools {$/;"	n	namespace:souffle::profile
TopologicallySortedSCCGraph	PrecedenceGraph.h	/^class TopologicallySortedSCCGraph : public AstAnalysis {$/;"	c	namespace:souffle
TreeNode	ExplainTree.h	/^    TreeNode(std::string t = "") : txt(std::move(t)) {}$/;"	f	class:souffle::TreeNode
TreeNode	ExplainTree.h	/^class TreeNode {$/;"	c	namespace:souffle
Trie	Brie.h	/^class Trie : public detail::TrieBase<Dim, Trie<Dim>> {$/;"	c	namespace:souffle
Trie	Brie.h	/^class Trie<0u> : public detail::TrieBase<0u, Trie<0u>> {$/;"	c	namespace:souffle
Trie	Brie.h	/^class Trie<1u> : public detail::TrieBase<1u, Trie<1u>> {$/;"	c	namespace:souffle
TrieBase	Brie.h	/^class TrieBase {$/;"	c	namespace:souffle::detail
TrieIndex	CompiledIndexUtils.h	/^class TrieIndex {$/;"	c	namespace:souffle::ram::index_utils
Tui	profile/Tui.h	/^    Tui() {$/;"	f	class:souffle::profile::Tui
Tui	profile/Tui.h	/^    Tui(std::string filename, bool live, bool gui) {$/;"	f	class:souffle::profile::Tui
Tui	profile/Tui.h	/^class Tui {$/;"	c	namespace:souffle::profile
Tuple	CompiledTuple.h	/^struct Tuple {$/;"	s	namespace:souffle::ram
Type	ErrorReport.h	/^    enum Type { ERROR, WARNING };$/;"	g	class:souffle::Diagnostic
Type	TypeSystem.h	/^    Type(const TypeEnvironment& environment, AstTypeIdentifier name)$/;"	f	class:souffle::Type
Type	TypeSystem.h	/^class Type {$/;"	c	namespace:souffle
Type	json11.h	/^    enum Type { NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT };$/;"	g	class:json11::final
TypeAnalysis	AstTypeAnalysis.h	/^class TypeAnalysis : public AstAnalysis {$/;"	c	namespace:souffle
TypeBinding	ComponentModel.h	/^class TypeBinding {$/;"	c	namespace:souffle
TypeEnvironment	TypeSystem.cpp	/^TypeEnvironment::TypeEnvironment() {$/;"	f	class:souffle::TypeEnvironment
TypeEnvironment	TypeSystem.h	/^class TypeEnvironment {$/;"	c	namespace:souffle
TypeEnvironmentAnalysis	AstTypeEnvironmentAnalysis.h	/^class TypeEnvironmentAnalysis : public AstAnalysis {$/;"	c	namespace:souffle
TypeSet	TypeSystem.h	/^    TypeSet(bool all = false) : all(all) {}$/;"	f	struct:souffle::TypeSet
TypeSet	TypeSystem.h	/^    TypeSet(const Types&... types) : all(false) {$/;"	f	struct:souffle::TypeSet
TypeSet	TypeSystem.h	/^struct TypeSet {$/;"	s	namespace:souffle
TypeVisitor	TypeSystem.cpp	/^struct TypeVisitor {$/;"	s	namespace:souffle::__anon75	file:
UINT16_MAX	scanner.cc	/^#define UINT16_MAX /;"	d	file:
UINT32_MAX	scanner.cc	/^#define UINT32_MAX /;"	d	file:
UINT8_MAX	scanner.cc	/^#define UINT8_MAX /;"	d	file:
UNDERSCORE	parser.hh	/^        UNDERSCORE = 305,$/;"	e	enum:yy::parser::token::yytokentype
UNSAFE_LOOKUP	SymbolTable.h	/^        UNSAFE_LOOKUP = 8,$/;"	e	enum:souffle::SymbolTable::__anon65
UNSAFE_RESOLVE	SymbolTable.h	/^        UNSAFE_RESOLVE = 9$/;"	e	enum:souffle::SymbolTable::__anon65
UnionType	TypeSystem.h	/^    UnionType(const TypeEnvironment& environment, const AstTypeIdentifier& name) : Type(environment, name) {}$/;"	f	class:souffle::UnionType
UnionType	TypeSystem.h	/^class UnionType : public Type {$/;"	c	namespace:souffle
UniqueAggregationVariablesTransformer	AstTransforms.h	/^class UniqueAggregationVariablesTransformer : public AstTransformer {$/;"	c	namespace:souffle
UnsupportedConstructException	souffle2bdd.cpp	/^    UnsupportedConstructException(std::string msg) : msg(std::move(msg)) {}$/;"	f	class:souffle::UnsupportedConstructException
UnsupportedConstructException	souffle2bdd.cpp	/^class UnsupportedConstructException : public std::exception {$/;"	c	namespace:souffle	file:
UnsupportedConstructException	souffle2lb.cpp	/^    UnsupportedConstructException(std::string msg) : msg(std::move(msg)) {}$/;"	f	class:souffle::UnsupportedConstructException
UnsupportedConstructException	souffle2lb.cpp	/^class UnsupportedConstructException : public std::exception {$/;"	c	namespace:souffle	file:
Usage	profile/Tui.h	/^    struct Usage {$/;"	s	class:souffle::profile::Tui
VERSION	Makefile	/^VERSION = 1.0.0-3315-g27d34e2$/;"	m
Value	json11.h	/^    explicit Value(T&& value) : m_value(move(value)) {}$/;"	f	class:json11::Value
Value	json11.h	/^    explicit Value(const T& value) : m_value(value) {}$/;"	f	class:json11::Value
Value	json11.h	/^class Value : public JsonValue {$/;"	c	namespace:json11
ValueIndex	AstTranslator.h	/^    class ValueIndex {$/;"	c	class:souffle::AstTranslator
Variable	Constraints.h	/^    Variable(Id id) : id(std::move(id)) {}$/;"	f	struct:souffle::Variable
Variable	Constraints.h	/^struct Variable {$/;"	s	namespace:souffle
VisitOnceTypeVisitor	TypeSystem.cpp	/^class VisitOnceTypeVisitor : public TypeVisitor<R> {$/;"	c	namespace:souffle::__anon75	file:
Visitor	ProfileDatabase.h	/^class Visitor {$/;"	c	namespace:souffle::profile
WARNING	ErrorReport.h	/^    enum Type { ERROR, WARNING };$/;"	e	enum:souffle::Diagnostic::Type
WITHIN	EquivalenceRelation.h	/^        enum IterType { ALL, ANTERIOR, ANTPOST, WITHIN };$/;"	e	enum:souffle::EquivalenceRelation::iterator::IterType
Waiter	ParallelUtils.h	/^    Waiter() : i(0) {}$/;"	f	class:souffle::detail::Waiter
Waiter	ParallelUtils.h	/^class Waiter {$/;"	c	namespace:souffle::detail
WhileTransformer	AstTransforms.h	/^    WhileTransformer(bool cond, std::unique_ptr<AstTransformer> transformer)$/;"	f	class:souffle::WhileTransformer
WhileTransformer	AstTransforms.h	/^    WhileTransformer(std::function<bool()> cond, std::unique_ptr<AstTransformer> transformer)$/;"	f	class:souffle::WhileTransformer
WhileTransformer	AstTransforms.h	/^class WhileTransformer : public MetaTransformer {$/;"	c	namespace:souffle
WriteCoutCSV	WriteStreamCSV.h	/^    WriteCoutCSV(const std::vector<bool>& symbolMask, const SymbolTable& symbolTable,$/;"	f	class:souffle::WriteCoutCSV
WriteCoutCSV	WriteStreamCSV.h	/^class WriteCoutCSV : public WriteStreamCSV, public WriteStream {$/;"	c	namespace:souffle
WriteCoutCSVFactory	WriteStreamCSV.h	/^class WriteCoutCSVFactory : public WriteStreamFactory {$/;"	c	namespace:souffle
WriteCoutPrintSize	WriteStreamCSV.h	/^    WriteCoutPrintSize(const IODirectives& ioDirectives)$/;"	f	class:souffle::WriteCoutPrintSize
WriteCoutPrintSize	WriteStreamCSV.h	/^class WriteCoutPrintSize : public WriteStream {$/;"	c	namespace:souffle
WriteCoutPrintSizeFactory	WriteStreamCSV.h	/^class WriteCoutPrintSizeFactory : public WriteStreamFactory {$/;"	c	namespace:souffle
WriteFileCSV	WriteStreamCSV.h	/^    WriteFileCSV(const std::vector<bool>& symbolMask, const SymbolTable& symbolTable,$/;"	f	class:souffle::WriteFileCSV
WriteFileCSV	WriteStreamCSV.h	/^class WriteFileCSV : public WriteStreamCSV, public WriteStream {$/;"	c	namespace:souffle
WriteFileCSVFactory	WriteStreamCSV.h	/^class WriteFileCSVFactory : public WriteStreamFactory {$/;"	c	namespace:souffle
WriteGZipFileCSV	WriteStreamCSV.h	/^    WriteGZipFileCSV(const std::vector<bool>& symbolMask, const SymbolTable& symbolTable,$/;"	f	class:souffle::WriteGZipFileCSV
WriteGZipFileCSV	WriteStreamCSV.h	/^class WriteGZipFileCSV : public WriteStreamCSV, public WriteStream {$/;"	c	namespace:souffle
WriteSQLiteFactory	WriteStreamSQLite.h	/^class WriteSQLiteFactory : public WriteStreamFactory {$/;"	c	namespace:souffle
WriteStream	WriteStream.h	/^    WriteStream(const std::vector<bool>& symbolMask, const SymbolTable& symbolTable, const bool prov,$/;"	f	class:souffle::WriteStream
WriteStream	WriteStream.h	/^class WriteStream {$/;"	c	namespace:souffle
WriteStreamCSV	WriteStreamCSV.h	/^class WriteStreamCSV {$/;"	c	namespace:souffle
WriteStreamFactory	WriteStream.h	/^class WriteStreamFactory {$/;"	c	namespace:souffle
WriteStreamSQLite	WriteStreamSQLite.h	/^    WriteStreamSQLite(const std::string& dbFilename, const std::string& relationName,$/;"	f	class:souffle::WriteStreamSQLite
WriteStreamSQLite	WriteStreamSQLite.h	/^class WriteStreamSQLite : public WriteStream {$/;"	c	namespace:souffle
YACC	Makefile	/^YACC = bison -y$/;"	m
YFLAGS	Makefile	/^YFLAGS = $/;"	m
YYABORT	parser.cc	/^#define YYABORT /;"	d	file:
YYACCEPT	parser.cc	/^#define YYACCEPT /;"	d	file:
YYASSERT	parser.hh	/^# define YYASSERT /;"	d
YYCASE_	parser.cc	/^#define YYCASE_(/;"	d	file:
YYCASE_	parser.cc	/^#undef YYCASE_$/;"	d	file:
YYCDEBUG	parser.cc	/^# define YYCDEBUG /;"	d	file:
YYDEBUG	parser.hh	/^# define YYDEBUG /;"	d
YYERROR	parser.cc	/^#define YYERROR /;"	d	file:
YYLLOC_DEFAULT	parser.cc	/^#  define YYLLOC_DEFAULT(/;"	d	file:
YYLLOC_DEFAULT	parser.hh	/^    # define YYLLOC_DEFAULT(/;"	d
YYLTYPE	scanner.cc	/^    #define YYLTYPE /;"	d	file:
YYRECOVERING	parser.cc	/^#define YYRECOVERING(/;"	d	file:
YYRHSLOC	parser.cc	/^#define YYRHSLOC(/;"	d	file:
YYSTATE	scanner.cc	/^#define YYSTATE /;"	d	file:
YYTABLES_NAME	scanner.cc	/^#define YYTABLES_NAME /;"	d	file:
YYUSE	parser.cc	/^#define YYUSE(/;"	d	file:
YYUSE	parser.hh	/^# define YYUSE(/;"	d
YY_	parser.cc	/^#   define YY_(/;"	d	file:
YY_	parser.cc	/^#  define YY_(/;"	d	file:
YY_ATTRIBUTE	parser.hh	/^#  define YY_ATTRIBUTE(/;"	d
YY_ATTRIBUTE_PURE	parser.hh	/^    debug_level_type debug_level () const YY_ATTRIBUTE_PURE;$/;"	m	class:yy::parser
YY_ATTRIBUTE_PURE	parser.hh	/^    std::ostream& debug_stream () const YY_ATTRIBUTE_PURE;$/;"	m	class:yy::parser
YY_ATTRIBUTE_PURE	parser.hh	/^# define YY_ATTRIBUTE_PURE /;"	d
YY_ATTRIBUTE_UNUSED	parser.hh	/^# define YY_ATTRIBUTE_UNUSED /;"	d
YY_AT_BOL	scanner.cc	/^#define YY_AT_BOL(/;"	d	file:
YY_BREAK	scanner.cc	/^#define YY_BREAK /;"	d	file:
YY_BUFFER_EOF_PENDING	scanner.cc	/^#define YY_BUFFER_EOF_PENDING /;"	d	file:
YY_BUFFER_NEW	scanner.cc	/^#define YY_BUFFER_NEW /;"	d	file:
YY_BUFFER_NORMAL	scanner.cc	/^#define YY_BUFFER_NORMAL /;"	d	file:
YY_BUFFER_STATE	scanner.cc	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	scanner.cc	/^#define YY_BUF_SIZE /;"	d	file:
YY_CHAR	scanner.cc	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CONSTEXPR	parser.hh	/^# define YY_CONSTEXPR /;"	d
YY_COPY	parser.hh	/^# define YY_COPY(/;"	d
YY_CPLUSPLUS	parser.hh	/^# define YY_CPLUSPLUS /;"	d
YY_CURRENT_BUFFER	scanner.cc	/^#define YY_CURRENT_BUFFER /;"	d	file:
YY_CURRENT_BUFFER_LVALUE	scanner.cc	/^#define YY_CURRENT_BUFFER_LVALUE /;"	d	file:
YY_DECL	ParserDriver.h	/^#define YY_DECL /;"	d
YY_DECL	scanner.cc	/^#define YY_DECL /;"	d	file:
YY_DECL_IS_OURS	scanner.cc	/^#define YY_DECL_IS_OURS /;"	d	file:
YY_DO_BEFORE_ACTION	scanner.cc	/^#define YY_DO_BEFORE_ACTION /;"	d	file:
YY_END_OF_BUFFER	scanner.cc	/^#define YY_END_OF_BUFFER /;"	d	file:
YY_END_OF_BUFFER_CHAR	scanner.cc	/^#define YY_END_OF_BUFFER_CHAR /;"	d	file:
YY_EXCEPTIONS	parser.cc	/^#  define YY_EXCEPTIONS /;"	d	file:
YY_EXIT_FAILURE	scanner.cc	/^#define YY_EXIT_FAILURE /;"	d	file:
YY_EXTRA_TYPE	scanner.cc	/^#define YY_EXTRA_TYPE /;"	d	file:
YY_FATAL_ERROR	scanner.cc	/^#define YY_FATAL_ERROR(/;"	d	file:
YY_FLEX_MAJOR_VERSION	scanner.cc	/^#define YY_FLEX_MAJOR_VERSION /;"	d	file:
YY_FLEX_MINOR_VERSION	scanner.cc	/^#define YY_FLEX_MINOR_VERSION /;"	d	file:
YY_FLEX_SUBMINOR_VERSION	scanner.cc	/^#define YY_FLEX_SUBMINOR_VERSION /;"	d	file:
YY_FLUSH_BUFFER	scanner.cc	/^#define YY_FLUSH_BUFFER /;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parser.hh	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN /;"	d
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parser.hh	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN$/;"	d
YY_IGNORE_MAYBE_UNINITIALIZED_END	parser.hh	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_END /;"	d
YY_IGNORE_MAYBE_UNINITIALIZED_END	parser.hh	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_END$/;"	d
YY_INITIAL_VALUE	parser.hh	/^# define YY_INITIAL_VALUE(/;"	d
YY_INPUT	scanner.cc	/^#define YY_INPUT(/;"	d	file:
YY_INT_ALIGNED	scanner.cc	/^#define  YY_INT_ALIGNED /;"	d	file:
YY_LESS_LINENO	scanner.cc	/^    #define  YY_LESS_LINENO(/;"	d	file:
YY_MORE_ADJ	scanner.cc	/^#define YY_MORE_ADJ /;"	d	file:
YY_MOVE	parser.cc	/^    : super_type (YY_MOVE (that.state), YY_MOVE (that.location))$/;"	f	namespace:yy
YY_MOVE	parser.hh	/^# define YY_MOVE /;"	d
YY_MOVE_OR_COPY	parser.hh	/^# define YY_MOVE_OR_COPY /;"	d
YY_MOVE_REF	parser.hh	/^# define YY_MOVE_REF(/;"	d
YY_NEW_FILE	scanner.cc	/^#define YY_NEW_FILE /;"	d	file:
YY_NOEXCEPT	parser.hh	/^      bool empty () const YY_NOEXCEPT;$/;"	m	struct:yy::parser::basic_symbol
YY_NOEXCEPT	parser.hh	/^      by_state () YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_state
YY_NOEXCEPT	parser.hh	/^      by_state (const by_state& that) YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_state
YY_NOEXCEPT	parser.hh	/^      by_state (kind_type s) YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_state
YY_NOEXCEPT	parser.hh	/^      symbol_number_type type_get () const YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_state
YY_NOEXCEPT	parser.hh	/^      symbol_number_type type_get () const YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_type
YY_NOEXCEPT	parser.hh	/^      token_type token () const YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_type
YY_NOEXCEPT	parser.hh	/^      void clear () YY_NOEXCEPT;$/;"	m	struct:yy::parser::by_state
YY_NOEXCEPT	parser.hh	/^# define YY_NOEXCEPT /;"	d
YY_NOTHROW	parser.hh	/^      ~syntax_error () YY_NOEXCEPT YY_NOTHROW;$/;"	m	struct:yy::parser::syntax_error
YY_NOTHROW	parser.hh	/^# define YY_NOTHROW$/;"	d
YY_NULL	scanner.cc	/^#define YY_NULL /;"	d	file:
YY_NULLPTR	parser.hh	/^    #define YY_NULLPTR /;"	d
YY_NULLPTR	parser.hh	/^#    define YY_NULLPTR /;"	d
YY_NUM_RULES	scanner.cc	/^#define YY_NUM_RULES /;"	d	file:
YY_READ_BUF_SIZE	scanner.cc	/^#define YY_READ_BUF_SIZE /;"	d	file:
YY_REDUCE_PRINT	parser.cc	/^# define YY_REDUCE_PRINT(/;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	scanner.cc	/^#define YY_RESTORE_YY_MORE_OFFSET$/;"	d	file:
YY_RULE_SETUP	scanner.cc	/^#define YY_RULE_SETUP /;"	d	file:
YY_RVREF	parser.hh	/^# define YY_RVREF(/;"	d
YY_SC_TO_UI	scanner.cc	/^#define YY_SC_TO_UI(/;"	d	file:
YY_SKIP_YYWRAP	scanner.cc	/^#define YY_SKIP_YYWRAP$/;"	d	file:
YY_STACK_PRINT	parser.cc	/^# define YY_STACK_PRINT(/;"	d	file:
YY_START	scanner.cc	/^#define YY_START /;"	d	file:
YY_START_STACK_INCR	scanner.cc	/^#define YY_START_STACK_INCR /;"	d	file:
YY_STATE_BUF_SIZE	scanner.cc	/^#define YY_STATE_BUF_SIZE /;"	d	file:
YY_STATE_EOF	scanner.cc	/^#define YY_STATE_EOF(/;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	scanner.cc	/^#define YY_STRUCT_YY_BUFFER_STATE$/;"	d	file:
YY_SYMBOL_PRINT	parser.cc	/^# define YY_SYMBOL_PRINT(/;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	scanner.cc	/^#define YY_TYPEDEF_YY_BUFFER_STATE$/;"	d	file:
YY_TYPEDEF_YY_SCANNER_T	scanner.cc	/^#define YY_TYPEDEF_YY_SCANNER_T$/;"	d	file:
YY_TYPEDEF_YY_SIZE_T	scanner.cc	/^#define YY_TYPEDEF_YY_SIZE_T$/;"	d	file:
YY_USER_ACTION	scanner.cc	/^#define YY_USER_ACTION /;"	d	file:
YY_USER_ACTION	scanner.cc	/^#define YY_USER_ACTION$/;"	d	file:
YY_USE_CONST	scanner.cc	/^#define YY_USE_CONST$/;"	d	file:
YY_YY_PARSER_HH_INCLUDED	parser.hh	/^# define YY_YY_PARSER_HH_INCLUDED$/;"	d
_EXPECT	test/test.h	/^#define _EXPECT(/;"	d
_Unique_if	Util.h	/^struct _Unique_if {$/;"	s	namespace:std
_Unique_if	Util.h	/^struct _Unique_if<T[N]> {$/;"	s	namespace:std
_Unique_if	Util.h	/^struct _Unique_if<T[]> {$/;"	s	namespace:std
__STDC_LIMIT_MACROS	scanner.cc	/^#define __STDC_LIMIT_MACROS /;"	d	file:
__UNDEFINED__	BinaryConstraintOps.h	/^    __UNDEFINED__,  \/\/ undefined operator$/;"	m	class:souffle::BinaryConstraintOp
__UNDEFINED__	FunctorOps.h	/^    __UNDEFINED__,  \/\/ undefined operator$/;"	m	class:souffle::FunctorOp
_data	Global.h	/^    std::map<K, V> _data;$/;"	m	class:souffle::BaseTable
_default	Global.h	/^    const V _default;$/;"	m	class:souffle::BaseTable
_help	Global.h	/^    std::string _help;$/;"	m	class:souffle::MainConfig
_predecessors	GraphUtils.h	/^    std::map<Vertex, std::set<Vertex, Compare>> _predecessors;  \/\/ all edges backward$/;"	m	class:souffle::Graph
_successors	GraphUtils.h	/^    std::map<Vertex, std::set<Vertex, Compare>> _successors;    \/\/ all edges forward directed$/;"	m	class:souffle::Graph
_vertices	GraphUtils.h	/^    std::set<Vertex, Compare> _vertices;                        \/\/ all the vertices in the graph$/;"	m	class:souffle::Graph
a	Util.h	/^    Iter a, b;$/;"	m	struct:souffle::range
a	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile
a_blocks	UnionFind.h	/^    PiggyList<std::atomic<block_t>> a_blocks;$/;"	m	class:souffle::DisjointSet
abort_write	ParallelUtils.h	/^    void abort_write() {$/;"	f	class:souffle::OptimisticReadWriteLock
abort_write	ParallelUtils.h	/^    void abort_write() {}$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
abs_builddir	Makefile	/^abs_builddir = \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/Users\/xiaowenhu\/Desktop\/lvm_souffle$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/Users\/xiaowenhu\/Desktop\/lvm_souffle$/;"	m
ac_ct_AR	Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CXX	Makefile	/^ac_ct_CXX = g++$/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
acceptsNumbers	AstArgument.h	/^    bool acceptsNumbers(size_t arg) const {$/;"	f	class:souffle::AstIntrinsicFunctor
acceptsNumbers	AstFunctorDeclaration.h	/^    bool acceptsNumbers(size_t idx) const {$/;"	f	class:souffle::AstFunctorDeclaration
acceptsSymbols	AstArgument.h	/^    bool acceptsSymbols(size_t arg) const {$/;"	f	class:souffle::AstIntrinsicFunctor
acceptsSymbols	AstFunctorDeclaration.h	/^    bool acceptsSymbols(size_t idx) const {$/;"	f	class:souffle::AstFunctorDeclaration
access	SymbolTable.h	/^    mutable Lock access;$/;"	m	class:souffle::SymbolTable
acquire	ParallelUtils.h	/^    Lease acquire() {$/;"	f	class:souffle::Lock
acquire	ParallelUtils.h	/^    Lease acquire() {$/;"	f	struct:souffle::souffle::Lock
acquireLock	SymbolTable.h	/^    Lock::Lease acquireLock() const {$/;"	f	class:souffle::SymbolTable
add	AstArgument.h	/^    void add(std::unique_ptr<AstArgument> arg) {$/;"	f	class:souffle::AstRecordInit
add	AstArgument.h	/^    void add(std::unique_ptr<AstArgument> arg) {$/;"	f	class:souffle::AstUserDefinedFunctor
add	AstType.h	/^    void add(const AstTypeIdentifier& type) {$/;"	f	class:souffle::AstUnionType
add	AstType.h	/^    void add(const std::string& name, const AstTypeIdentifier& type) {$/;"	f	class:souffle::AstRecordType
add	ComponentModel.cpp	/^    void add(std::unique_ptr<AstLoad>& directive, ErrorReport& report) {$/;"	f	struct:souffle::__anon73::ComponentContent
add	ComponentModel.cpp	/^    void add(std::unique_ptr<AstPrintSize>& directive, ErrorReport& report) {$/;"	f	struct:souffle::__anon73::ComponentContent
add	ComponentModel.cpp	/^    void add(std::unique_ptr<AstRelation>& rel, ErrorReport& report) {$/;"	f	struct:souffle::__anon73::ComponentContent
add	ComponentModel.cpp	/^    void add(std::unique_ptr<AstStore>& directive, ErrorReport& report) {$/;"	f	struct:souffle::__anon73::ComponentContent
add	ComponentModel.cpp	/^    void add(std::unique_ptr<AstType>& type, ErrorReport& report) {$/;"	f	struct:souffle::__anon73::ComponentContent
add	Constraints.h	/^    void add(const constraint_ptr& constraint) {$/;"	f	class:souffle::Problem
add	RamStatement.h	/^    void add(std::unique_ptr<RamStatement> stmt) {$/;"	f	class:souffle::RamParallel
add	RamStatement.h	/^    void add(std::unique_ptr<RamStatement> stmt) {$/;"	f	class:souffle::RamSequence
add	TypeSystem.cpp	/^void RecordType::add(const std::string& name, const Type& type) {$/;"	f	class:souffle::RecordType
add	TypeSystem.cpp	/^void UnionType::add(const Type& type) {$/;"	f	class:souffle::UnionType
addAggregators	MagicSet.cpp	/^std::set<AstRelationIdentifier> addAggregators($/;"	f	namespace:souffle
addAll	Brie.h	/^    void addAll(const SparseArray& other) {$/;"	f	class:souffle::SparseArray
addAll	Brie.h	/^    void addAll(const SparseBitMap& other) {$/;"	f	class:souffle::SparseBitMap
addArgument	AstLiteral.h	/^    void addArgument(std::unique_ptr<AstArgument> arg) {$/;"	f	class:souffle::AstAtom
addAtomFrequency	profile/Rule.h	/^    void addAtomFrequency(const std::string& subruleName, std::string atom, size_t level, size_t frequency) {$/;"	f	class:souffle::profile::Rule
addAttribute	AstRelation.h	/^    void addAttribute(std::unique_ptr<AstAttribute> attr) {$/;"	f	class:souffle::AstRelation
addAttributes	InterpreterRelation.h	/^    void addAttributes(const std::vector<std::string> attributeTypes) {$/;"	f	class:souffle::InterpreterRelation
addBackwardDependencies	MagicSet.cpp	/^std::set<AstRelationIdentifier> addBackwardDependencies($/;"	f	namespace:souffle
addBaseComponent	AstComponent.h	/^    void addBaseComponent(std::unique_ptr<AstComponentType> component) {$/;"	f	class:souffle::AstComponent
addBinding	MagicSet.h	/^    void addBinding(const std::string& newVariableName, const AstArgument* arg) {$/;"	f	class:souffle::BindingStore
addBodyLiteral	AstArgument.h	/^    void addBodyLiteral(std::unique_ptr<AstLiteral> lit) {$/;"	f	class:souffle::AstAggregator
addClause	AstComponent.h	/^    void addClause(std::unique_ptr<AstClause> c) {$/;"	f	class:souffle::AstComponent
addClause	AstProgram.cpp	/^void AstProgram::addClause(std::unique_ptr<AstClause> clause) {$/;"	f	class:souffle::AstProgram
addClause	AstRelation.h	/^    void addClause(std::unique_ptr<AstClause> clause) {$/;"	f	class:souffle::AstRelation
addClause	ParserDriver.cpp	/^void ParserDriver::addClause(std::unique_ptr<AstClause> c) {$/;"	f	class:souffle::ParserDriver
addComponent	AstComponent.h	/^    void addComponent(std::unique_ptr<AstComponent> c) {$/;"	f	class:souffle::AstComponent
addComponent	AstProgram.h	/^    void addComponent(std::unique_ptr<AstComponent> c) {$/;"	f	class:souffle::AstProgram
addComponent	ParserDriver.cpp	/^void ParserDriver::addComponent(std::unique_ptr<AstComponent> c) {$/;"	f	class:souffle::ParserDriver
addCondition	RamOperation.cpp	/^void RamAggregate::addCondition(std::unique_ptr<RamCondition> newCondition) {$/;"	f	class:souffle::RamAggregate
addConstraint	AstConstraintAnalysis.h	/^    void addConstraint(const constraint_type& constraint) {$/;"	f	class:souffle::__anon68::AstConstraintAnalysis
addDiagnostic	ErrorReport.h	/^    void addDiagnostic(const Diagnostic& diagnostic) {$/;"	f	class:souffle::ErrorReport
addEdge	IndexSetAnalysis.cpp	/^void MaxMatching::addEdge(SearchColumns u, SearchColumns v) {$/;"	f	class:souffle::MaxMatching
addError	ErrorReport.h	/^    void addError(const std::string& message, SrcLocation location) {$/;"	f	class:souffle::ErrorReport
addForwardDependencies	MagicSet.cpp	/^std::set<AstRelationIdentifier> addForwardDependencies($/;"	f	namespace:souffle
addFunctorDeclaration	AstProgram.cpp	/^void AstProgram::addFunctorDeclaration(std::unique_ptr<AstFunctorDeclaration> f) {$/;"	f	class:souffle::AstProgram
addFunctorDeclaration	ParserDriver.cpp	/^void ParserDriver::addFunctorDeclaration(std::unique_ptr<AstFunctorDeclaration> f) {$/;"	f	class:souffle::ParserDriver
addHistory	profile/UserInputReader.h	/^    void addHistory(std::string hist) {$/;"	f	class:souffle::profile::InputReader
addIgnoredRelations	MagicSet.cpp	/^std::set<AstRelationIdentifier> addIgnoredRelations($/;"	f	namespace:souffle
addInstantiation	AstComponent.h	/^    void addInstantiation(std::unique_ptr<AstComponentInit> i) {$/;"	f	class:souffle::AstComponent
addInstantiation	AstProgram.h	/^    void addInstantiation(std::unique_ptr<AstComponentInit> i) {$/;"	f	class:souffle::AstProgram
addInstantiation	ParserDriver.cpp	/^void ParserDriver::addInstantiation(std::unique_ptr<AstComponentInit> ci) {$/;"	f	class:souffle::ParserDriver
addIteration	profile/Relation.h	/^    void addIteration(std::shared_ptr<Iteration> iteration) {$/;"	f	class:souffle::profile::Relation
addKVP	AstIO.h	/^    void addKVP(const std::string& key, const std::string& value) {$/;"	f	class:souffle::AstIO
addLoad	AstComponent.h	/^    void addLoad(std::unique_ptr<AstLoad> load) {$/;"	f	class:souffle::AstComponent
addLoad	AstProgram.cpp	/^void AstProgram::addLoad(std::unique_ptr<AstLoad> directive) {$/;"	f	class:souffle::AstProgram
addLoad	AstRelation.h	/^    void addLoad(std::unique_ptr<AstLoad> directive) {$/;"	f	class:souffle::AstRelation
addLoad	ParserDriver.cpp	/^void ParserDriver::addLoad(std::unique_ptr<AstLoad> d) {$/;"	f	class:souffle::ParserDriver
addName	AstIO.h	/^    void addName(const AstRelationIdentifier& name) {$/;"	f	class:souffle::AstIO
addOverride	AstComponent.h	/^    void addOverride(const std::string& name) {$/;"	f	class:souffle::AstComponent
addPragma	AstProgram.cpp	/^void AstProgram::addPragma(std::unique_ptr<AstPragma> pragma) {$/;"	f	class:souffle::AstProgram
addPragma	ParserDriver.cpp	/^void ParserDriver::addPragma(std::unique_ptr<AstPragma> p) {$/;"	f	class:souffle::ParserDriver
addPrintSize	AstComponent.h	/^    void addPrintSize(std::unique_ptr<AstPrintSize> printSize) {$/;"	f	class:souffle::AstComponent
addReads	profile/Relation.h	/^    void addReads(size_t tuplesRead) {$/;"	f	class:souffle::profile::Relation
addRelation	AstComponent.h	/^    void addRelation(std::unique_ptr<AstRelation> r) {$/;"	f	class:souffle::AstComponent
addRelation	AstProgram.cpp	/^void AstProgram::addRelation(std::unique_ptr<AstRelation> r) {$/;"	f	class:souffle::AstProgram
addRelation	ParserDriver.cpp	/^void ParserDriver::addRelation(std::unique_ptr<AstRelation> r) {$/;"	f	class:souffle::ParserDriver
addRelation	RamProgram.h	/^    void addRelation(std::unique_ptr<RamRelation> rel) {$/;"	f	class:souffle::RamProgram
addRelation	SouffleInterface.h	/^    void addRelation(const std::string& name, Relation* rel, bool isInput, bool isOutput) {$/;"	f	class:souffle::SouffleProgram
addRelation	profile/Reader.h	/^    void addRelation(const DirectoryEntry& relation) {$/;"	f	class:souffle::profile::Reader
addReturnValue	InterpreterContext.h	/^    void addReturnValue(RamDomain val, bool err = false) {$/;"	f	class:souffle::InterpreterContext
addRow	profile/Table.h	/^    void addRow(std::shared_ptr<Row> row) {$/;"	f	class:souffle::profile::Table
addRule	profile/Iteration.h	/^    void addRule(const std::string& ruleKey, std::shared_ptr<Rule>& rule) {$/;"	f	class:souffle::profile::Iteration
addRule	profile/Relation.h	/^    void addRule(std::shared_ptr<Rule> rule) {$/;"	f	class:souffle::profile::Relation
addSearch	IndexSetAnalysis.h	/^    inline void addSearch(SearchColumns cols) {$/;"	f	class:souffle::IndexSet
addSection	DebugReport.h	/^    void addSection(const DebugReportSection& section) {$/;"	f	class:souffle::DebugReport
addStore	AstComponent.h	/^    void addStore(std::unique_ptr<AstStore> store) {$/;"	f	class:souffle::AstComponent
addStore	AstProgram.cpp	/^void AstProgram::addStore(std::unique_ptr<AstStore> directive) {$/;"	f	class:souffle::AstProgram
addStore	AstRelation.h	/^    void addStore(std::unique_ptr<AstStore> directive) {$/;"	f	class:souffle::AstRelation
addStore	ParserDriver.cpp	/^void ParserDriver::addStore(std::unique_ptr<AstStore> d) {$/;"	f	class:souffle::ParserDriver
addSubroutine	RamProgram.h	/^    void addSubroutine(std::string name, std::unique_ptr<RamStatement> subroutine) {$/;"	f	class:souffle::RamProgram
addToBody	AstClause.cpp	/^void AstClause::addToBody(std::unique_ptr<AstLiteral> l) {$/;"	f	class:souffle::AstClause
addType	AstComponent.h	/^    void addType(std::unique_ptr<AstType> t) {$/;"	f	class:souffle::AstComponent
addType	AstProgram.cpp	/^void AstProgram::addType(std::unique_ptr<AstType> type) {$/;"	f	class:souffle::AstProgram
addType	ParserDriver.cpp	/^void ParserDriver::addType(std::unique_ptr<AstType> type) {$/;"	f	class:souffle::ParserDriver
addType	TypeSystem.cpp	/^void TypeEnvironment::addType(Type& type) {$/;"	f	class:souffle::TypeEnvironment
addVarReference	AstTranslator.h	/^        void addVarReference(const AstVariable& var, const Location& l) {$/;"	f	class:souffle::AstTranslator::ValueIndex
addVarReference	AstTranslator.h	/^        void addVarReference(const AstVariable& var, int ident, int pos,$/;"	f	class:souffle::AstTranslator::ValueIndex
addVariableBoundComposite	MagicSet.h	/^    void addVariableBoundComposite(const std::string& functorName) {$/;"	f	class:souffle::BindingStore
addWarning	ErrorReport.h	/^    void addWarning(const std::string& message, SrcLocation location) {$/;"	f	class:souffle::ErrorReport
add_child	ExplainTree.h	/^    void add_child(std::unique_ptr<TreeNode> child) {$/;"	f	class:souffle::InnerNode
additionalMessages	ErrorReport.h	/^    std::vector<DiagnosticMessage> additionalMessages;$/;"	m	class:souffle::Diagnostic
addressMap	Interpreter.h	/^       std::vector<size_t> addressMap;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
adornment	MagicSet.h	/^    std::string adornment;$/;"	m	class:souffle::AdornedPredicate
adornmentClauses	MagicSet.h	/^    std::vector<std::vector<AdornedClause>> adornmentClauses;$/;"	m	class:souffle::Adornment
adornmentEdb	MagicSet.h	/^    std::set<AstRelationIdentifier> adornmentEdb;$/;"	m	class:souffle::Adornment
adornmentIdb	MagicSet.h	/^    std::set<AstRelationIdentifier> adornmentIdb;$/;"	m	class:souffle::Adornment
adornmentRelations	MagicSet.h	/^    std::vector<AstRelationIdentifier> adornmentRelations;$/;"	m	class:souffle::Adornment
aggregator_locations	AstTranslator.h	/^        aggregator_location_map aggregator_locations;$/;"	m	class:souffle::AstTranslator::ValueIndex
alive	profile/Tui.h	/^    bool alive = false;$/;"	m	class:souffle::profile::Tui
all	TypeSystem.h	/^    bool all;$/;"	m	struct:souffle::TypeSet
all_indices	CompiledIndexUtils.h	/^struct all_indices {$/;"	s	namespace:souffle::ram::index_utils
all_indices	CompiledIndexUtils.h	/^struct all_indices<> {$/;"	s	namespace:souffle::ram::index_utils
all_indices	CompiledIndexUtils.h	/^struct all_indices<index<Columns...>, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
all_type_factory	AstTypeAnalysis.cpp	/^struct all_type_factory {$/;"	s	namespace:souffle::__anon77	file:
allocsize	PiggyList.h	/^    size_t allocsize = BLOCKSIZE;$/;"	m	class:souffle::PiggyList
am__DIST_COMMON	Makefile	/^am__DIST_COMMON = $(srcdir)\/BTree.h $(srcdir)\/BinaryConstraintOps.h \\$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ax_compare_version.m4 \\$/;"	m
am__base_list	Makefile	/^am__base_list = \\$/;"	m
am__can_run_installinfo	Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__check_pre	Makefile	/^am__check_pre = \\$/;"	m
am__common_driver_flags	Makefile	/^am__common_driver_flags = \\$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__copy_in_global_log_rx	Makefile	/^am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*$/;"	m
am__create_global_log	Makefile	/^am__create_global_log = $(AWK) ' \\$/;"	m
am__define_uniq_tagged_files	Makefile	/^am__define_uniq_tagged_files = \\$/;"	m
am__depfiles_remade	Makefile	/^am__depfiles_remade = .\/$(DEPDIR)\/libsouffle_la-AstArgument.Plo \\$/;"	m
am__dirstamp	Makefile	/^am__dirstamp = $(am__leading_dot)dirstamp$/;"	m
am__global_test_result_rx	Makefile	/^am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__install_max	Makefile	/^am__install_max = 40$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(bindir)" \\$/;"	m
am__is_gnu_make	Makefile	/^am__is_gnu_make = { \\$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__libsouffle_la_SOURCES_DIST	Makefile	/^am__libsouffle_la_SOURCES_DIST = AstAnalysis.h AstArgument.cpp \\$/;"	m
am__list_recheck_tests	Makefile	/^am__list_recheck_tests = $(AWK) '{ \\$/;"	m
am__make_dryrun	Makefile	/^am__make_dryrun = (target_option=n; $(am__make_running_with_option))$/;"	m
am__make_keepgoing	Makefile	/^am__make_keepgoing = (target_option=k; $(am__make_running_with_option))$/;"	m
am__make_running_with_option	Makefile	/^am__make_running_with_option = \\$/;"	m
am__maybe_remake_depfiles	Makefile	/^am__maybe_remake_depfiles = depfiles$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__nobase_list	Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_strip	Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip_setup	Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__objects_1	Makefile	/^am__objects_1 =$/;"	m
am__objects_2	Makefile	/^am__objects_2 = libsouffle_la-AstArgument.lo \\$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__recheck_rx	Makefile	/^am__recheck_rx = ^[ 	]*:recheck:[ 	]*$/;"	m
am__rst_title	Makefile	/^am__rst_title = { sed 's\/.*\/   &   \/;h;s\/.\/=\/g;p;x;s\/ *$$\/\/;p;g' && echo; }$/;"	m
am__set_TESTS_bases	Makefile	/^am__set_TESTS_bases = \\$/;"	m
am__set_b	Makefile	/^am__set_b = \\$/;"	m
am__sh_e_setup	Makefile	/^am__sh_e_setup = case $$- in *e*) set +e;; esac$/;"	m
am__soufflepublic_HEADERS_DIST	Makefile	/^am__soufflepublic_HEADERS_DIST = CompiledOptions.h \\$/;"	m
am__strip_dir	Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tagged_files	Makefile	/^am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)$/;"	m
am__tar	Makefile	/^am__tar = tar --format=posix -chf - "$$tardir"$/;"	m
am__test_logs1	Makefile	/^am__test_logs1 = $(TESTS:=.log)$/;"	m
am__test_logs2	Makefile	/^am__test_logs2 = $(am__test_logs1:.log=.log)$/;"	m
am__test_mpi_test_SOURCES_DIST	Makefile	/^am__test_mpi_test_SOURCES_DIST = test\/mpi_test.cpp$/;"	m
am__tty_colors	Makefile	/^am__tty_colors = { \\$/;"	m
am__tty_colors_dummy	Makefile	/^am__tty_colors_dummy = \\$/;"	m
am__uninstall_files_from_dir	Makefile	/^am__uninstall_files_from_dir = { \\$/;"	m
am__uniquify_input	Makefile	/^am__uniquify_input = $(AWK) '\\$/;"	m
am__untar	Makefile	/^am__untar = tar -xf -$/;"	m
am__v_CCLD_	Makefile	/^am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CCLD_0	Makefile	/^am__v_CCLD_0 = @echo "  CCLD    " $@;$/;"	m
am__v_CCLD_1	Makefile	/^am__v_CCLD_1 = $/;"	m
am__v_CC_	Makefile	/^am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CC_0	Makefile	/^am__v_CC_0 = @echo "  CC      " $@;$/;"	m
am__v_CC_1	Makefile	/^am__v_CC_1 = $/;"	m
am__v_CXXLD_	Makefile	/^am__v_CXXLD_ = $(am__v_CXXLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CXXLD_0	Makefile	/^am__v_CXXLD_0 = @echo "  CXXLD   " $@;$/;"	m
am__v_CXXLD_1	Makefile	/^am__v_CXXLD_1 = $/;"	m
am__v_CXX_	Makefile	/^am__v_CXX_ = $(am__v_CXX_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CXX_0	Makefile	/^am__v_CXX_0 = @echo "  CXX     " $@;$/;"	m
am__v_CXX_1	Makefile	/^am__v_CXX_1 = $/;"	m
am__v_GEN_	Makefile	/^am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_GEN_0	Makefile	/^am__v_GEN_0 = @echo "  GEN     " $@;$/;"	m
am__v_GEN_1	Makefile	/^am__v_GEN_1 = $/;"	m
am__v_P_	Makefile	/^am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_P_0	Makefile	/^am__v_P_0 = false$/;"	m
am__v_P_1	Makefile	/^am__v_P_1 = :$/;"	m
am__v_at_	Makefile	/^am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_at_0	Makefile	/^am__v_at_0 = @$/;"	m
am__v_at_1	Makefile	/^am__v_at_1 = $/;"	m
am__v_lt_	Makefile	/^am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_lt_0	Makefile	/^am__v_lt_0 = --silent$/;"	m
am__v_lt_1	Makefile	/^am__v_lt_1 = $/;"	m
am__vpath_adj	Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am_libsouffle_la_OBJECTS	Makefile	/^am_libsouffle_la_OBJECTS = $(am__objects_2)$/;"	m
am_souffle2bdd_OBJECTS	Makefile	/^am_souffle2bdd_OBJECTS = souffle2bdd.$(OBJEXT)$/;"	m
am_souffle2lb_OBJECTS	Makefile	/^am_souffle2lb_OBJECTS = souffle2lb.$(OBJEXT)$/;"	m
am_souffle_OBJECTS	Makefile	/^am_souffle_OBJECTS = main.$(OBJEXT)$/;"	m
am_souffle_profile_OBJECTS	Makefile	/^am_souffle_profile_OBJECTS = souffle_profile-souffle_prof.$(OBJEXT)$/;"	m
am_test_ast_parser_utils_test_OBJECTS	Makefile	/^am_test_ast_parser_utils_test_OBJECTS =  \\$/;"	m
am_test_ast_program_test_OBJECTS	Makefile	/^am_test_ast_program_test_OBJECTS =  \\$/;"	m
am_test_ast_utils_test_OBJECTS	Makefile	/^am_test_ast_utils_test_OBJECTS =  \\$/;"	m
am_test_binary_relation_test_OBJECTS	Makefile	/^am_test_binary_relation_test_OBJECTS =  \\$/;"	m
am_test_brie_test_OBJECTS	Makefile	/^am_test_brie_test_OBJECTS = test\/brie_test-brie_test.$(OBJEXT)$/;"	m
am_test_btree_multiset_test_OBJECTS	Makefile	/^am_test_btree_multiset_test_OBJECTS =  \\$/;"	m
am_test_btree_set_test_OBJECTS	Makefile	/^am_test_btree_set_test_OBJECTS =  \\$/;"	m
am_test_compiled_index_utils_test_OBJECTS	Makefile	/^am_test_compiled_index_utils_test_OBJECTS = test\/compiled_index_utils_test-compiled_index_utils_test.$(OBJEXT)$/;"	m
am_test_compiled_relation_test_OBJECTS	Makefile	/^am_test_compiled_relation_test_OBJECTS =  \\$/;"	m
am_test_compiled_tuple_test_OBJECTS	Makefile	/^am_test_compiled_tuple_test_OBJECTS =  \\$/;"	m
am_test_constraints_test_OBJECTS	Makefile	/^am_test_constraints_test_OBJECTS =  \\$/;"	m
am_test_eqrel_datastructure_test_OBJECTS	Makefile	/^am_test_eqrel_datastructure_test_OBJECTS = test\/eqrel_datastructure_test-eqrel_datastructure_test.$(OBJEXT)$/;"	m
am_test_graph_utils_test_OBJECTS	Makefile	/^am_test_graph_utils_test_OBJECTS =  \\$/;"	m
am_test_matching_test_OBJECTS	Makefile	/^am_test_matching_test_OBJECTS =  \\$/;"	m
am_test_parallel_utils_test_OBJECTS	Makefile	/^am_test_parallel_utils_test_OBJECTS =  \\$/;"	m
am_test_symbol_table_test_OBJECTS	Makefile	/^am_test_symbol_table_test_OBJECTS =  \\$/;"	m
am_test_table_test_OBJECTS	Makefile	/^am_test_table_test_OBJECTS = test\/table_test-table_test.$(OBJEXT)$/;"	m
am_test_type_system_test_OBJECTS	Makefile	/^am_test_type_system_test_OBJECTS =  \\$/;"	m
am_test_util_test_OBJECTS	Makefile	/^am_test_util_test_OBJECTS = test\/util_test-util_test.$(OBJEXT)$/;"	m
analyse	AstConstraintAnalysis.h	/^    solution_type analyse(const AstClause& clause, std::ostream* debugOutput = nullptr) {$/;"	f	class:souffle::__anon68::AstConstraintAnalysis
analyseTypes	AstTypeAnalysis.cpp	/^std::map<const AstArgument*, TypeSet> TypeAnalysis::analyseTypes($/;"	f	class:souffle::TypeAnalysis
analyses	AstTranslationUnit.h	/^    mutable std::map<std::string, std::unique_ptr<AstAnalysis>> analyses;$/;"	m	class:souffle::AstTranslationUnit
analyses	RamTranslationUnit.h	/^    mutable std::map<std::string, std::unique_ptr<RamAnalysis>> analyses;$/;"	m	class:souffle::RamTranslationUnit
analysisLock	RamTranslationUnit.h	/^    mutable std::mutex analysisLock;$/;"	m	class:souffle::RamTranslationUnit
analysisLogs	AstTypeAnalysis.h	/^    std::stringstream analysisLogs;$/;"	m	class:souffle::TypeAnalysis
annotatedClauses	AstTypeAnalysis.h	/^    std::vector<std::unique_ptr<AstClause>> annotatedClauses;$/;"	m	class:souffle::TypeAnalysis
anteriorIt	EquivalenceRelation.h	/^    iterator anteriorIt(value_type anteriorVal) const {$/;"	f	class:souffle::EquivalenceRelation
antpostit	EquivalenceRelation.h	/^    iterator antpostit(value_type anteriorVal, value_type posteriorVal) const {$/;"	f	class:souffle::EquivalenceRelation
append	AstRelationIdentifier.h	/^    void append(const std::string& name) {$/;"	f	class:souffle::AstRelationIdentifier
append	AstType.h	/^    void append(const std::string& name) {$/;"	f	class:souffle::AstTypeIdentifier
append	InterpreterIndex.h	/^    void append(unsigned char column) {$/;"	f	class:souffle::InterpreterIndexOrder
append	PiggyList.h	/^    size_t append(T element) {$/;"	f	class:souffle::PiggyList
append	ResolveAliasesTransformer.cpp	/^    void append(const Substitution& sub) {$/;"	f	class:souffle::__anon71::Substitution
append	Table.h	/^        const T& append(const T& element) {$/;"	f	struct:souffle::Table::Block
appendAtomIndex	AstClause.h	/^    void appendAtomIndex(int index) {$/;"	f	class:souffle::AstExecutionOrder
appendClause	AstProgram.cpp	/^void AstProgram::appendClause(std::unique_ptr<AstClause> clause) {$/;"	f	class:souffle::AstProgram
appendRelation	AstProgram.cpp	/^void AstProgram::appendRelation(std::unique_ptr<AstRelation> r) {$/;"	f	class:souffle::AstProgram
appendStmt	AstTranslator.cpp	/^void AstTranslator::appendStmt(std::unique_ptr<RamStatement>& stmtList, std::unique_ptr<RamStatement> stmt) {$/;"	f	class:souffle::AstTranslator
appendTabCompletion	profile/UserInputReader.h	/^    void appendTabCompletion(std::string command) {$/;"	f	class:souffle::profile::InputReader
appendTabCompletion	profile/UserInputReader.h	/^    void appendTabCompletion(std::vector<std::string> commands) {$/;"	f	class:souffle::profile::InputReader
apply	AstProgram.cpp	/^void AstProgram::apply(const AstNodeMapper& map) {$/;"	f	class:souffle::AstProgram
apply	AstTransformer.cpp	/^bool AstTransformer::apply(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstTransformer
apply	RamTransformer.cpp	/^bool RamTransformer::apply(RamTranslationUnit& translationUnit) {$/;"	f	class:souffle::RamTransformer
apply	ResolveAliasesTransformer.cpp	/^    void apply(const Substitution& sub) {$/;"	f	class:souffle::__anon71::Equation
applySips	ReorderLiteralsTransformer.cpp	/^std::vector<unsigned int> applySips(sips_t sipsFunction, std::vector<AstAtom*> atoms) {$/;"	f	namespace:souffle
applySubtransformer	AstTransformer.cpp	/^bool MetaTransformer::applySubtransformer(AstTranslationUnit& translationUnit, AstTransformer* transformer) {$/;"	f	class:souffle::MetaTransformer
aptr	Brie.h	/^        std::atomic<Node*> aptr;$/;"	m	union:souffle::SparseArray::Cell
areBijectivelyEquivalent	MinimiseProgramTransformer.cpp	/^bool areBijectivelyEquivalent(const AstClause* left, const AstClause* right) {$/;"	f	namespace:souffle
areIndexesDisabled	Synthesiser.cpp	/^bool Synthesiser::areIndexesDisabled() {$/;"	f	class:souffle::Synthesiser
areSubtypesOf	TypeSystem.cpp	/^bool areSubtypesOf(const TypeSet& s, const Type& b) {$/;"	f	namespace:souffle
argSize	AstLiteral.h	/^    size_t argSize() const {$/;"	f	class:souffle::AstAtom
args	AstArgument.h	/^    std::vector<std::unique_ptr<AstArgument>> args;$/;"	m	class:souffle::AstIntrinsicFunctor
args	AstArgument.h	/^    std::vector<std::unique_ptr<AstArgument>> args;$/;"	m	class:souffle::AstRecordInit
args	AstArgument.h	/^    std::vector<std::unique_ptr<AstArgument>> args;$/;"	m	class:souffle::AstUserDefinedFunctor
args	InterpreterContext.h	/^    const std::vector<RamDomain>* args = nullptr;$/;"	m	class:souffle::InterpreterContext
args	profile/Cli.h	/^    std::map<char, std::string> args;$/;"	m	class:souffle::profile::Cli
argsToNums	ExplainProvenance.h	/^    std::vector<RamDomain> argsToNums(const std::string& relName, std::vector<std::string>& args) const {$/;"	f	class:souffle::ExplainProvenance
argument	Global.h	/^    std::string argument;  \/* The argument this option, e.g. if longName is 'option', shortName is 'o', and$/;"	m	struct:souffle::MainOption
argumentTypes	AstTypeAnalysis.h	/^    std::map<const AstArgument*, TypeSet> argumentTypes;$/;"	m	class:souffle::TypeAnalysis
arguments	AstLiteral.h	/^    std::vector<std::unique_ptr<AstArgument>> arguments;$/;"	m	class:souffle::AstAtom
arguments	RamExpression.h	/^    std::vector<std::unique_ptr<RamExpression>> arguments;$/;"	m	class:souffle::RamIntrinsicOperator
arguments	RamExpression.h	/^    std::vector<std::unique_ptr<RamExpression>> arguments;$/;"	m	class:souffle::RamPackRecord
arguments	RamExpression.h	/^    std::vector<std::unique_ptr<RamExpression>> arguments;$/;"	m	class:souffle::RamUserDefinedOperator
arity	CompiledIndexUtils.h	/^    enum { arity = T::arity };$/;"	e	enum:souffle::ram::index_utils::Indices::__anon48
arity	CompiledTuple.h	/^    enum { arity = _arity };$/;"	e	enum:souffle::ram::Tuple::__anon76
arity	InterpreterRecords.cpp	/^    int arity;$/;"	m	class:souffle::__anon67::RecordMap	file:
arity	InterpreterRelation.h	/^    const size_t arity;$/;"	m	class:souffle::InterpreterRelation
arity	RamOperation.h	/^    const size_t arity;$/;"	m	class:souffle::RamUnpackRecord
arity	RamRelation.h	/^    const size_t arity;$/;"	m	class:souffle::RamRelation
arity	ReadStream.h	/^    const uint8_t arity;$/;"	m	class:souffle::ReadStream
arity	WriteStream.h	/^    const size_t arity;$/;"	m	class:souffle::WriteStream
arr	profile/StringUtils.h	/^static const std::string arr[] = {"K", "M", "B", "t", "q", "Q", "s", "S", "o", "n", "d", "U"};$/;"	m	namespace:souffle::profile::Tools
array	SouffleInterface.h	/^    std::vector<RamDomain> array;$/;"	m	class:souffle::tuple
array_items	json11.h	/^inline const vector<Json>& Json::array_items() const {$/;"	f	class:json11::Json
array_items	json11.h	/^inline const vector<Json>& JsonValue::array_items() const {$/;"	f	class:json11::JsonValue
as	TypeSystem.cpp	/^const T& as(const Type& type) {$/;"	f	namespace:souffle::__anon75
asDerived	CompiledRelation.h	/^    Derived& asDerived() {$/;"	f	struct:souffle::ram::detail::RelationBase
asDerived	CompiledRelation.h	/^    const Derived& asDerived() const {$/;"	f	struct:souffle::ram::detail::RelationBase
asInnerNode	BTree.h	/^        const inner_node& asInnerNode() const {$/;"	f	struct:souffle::detail::btree::node
asInnerNode	BTree.h	/^        inner_node& asInnerNode() {$/;"	f	struct:souffle::detail::btree::node
ast_visitor_tag	AstVisitor.h	/^struct ast_visitor_tag {};$/;"	s	namespace:souffle
atom	AstLiteral.h	/^    std::unique_ptr<AstAtom> atom;$/;"	m	class:souffle::AstNegation
atom	AstLiteral.h	/^    std::unique_ptr<AstAtom> atom;$/;"	m	class:souffle::AstProvenanceNegation
atom	AstParserUtils.cpp	/^RuleBody RuleBody::atom(AstAtom* atom) {$/;"	f	class:souffle::RuleBody
atom	AstParserUtils.h	/^        std::unique_ptr<AstLiteral> atom;$/;"	m	struct:souffle::RuleBody::literal
atoms	AstClause.h	/^    std::vector<std::unique_ptr<AstAtom>> atoms;$/;"	m	class:souffle::AstClause
atoms	profile/Rule.h	/^    std::set<Atom> atoms;$/;"	m	class:souffle::profile::Rule
attrNames	InterpreterInterface.h	/^    std::vector<std::string> attrNames;$/;"	m	class:souffle::InterpreterRelInterface
attributeNames	RamRelation.h	/^    const std::vector<std::string> attributeNames;$/;"	m	class:souffle::RamRelation
attributeTypeQualifiers	InterpreterRelation.h	/^    std::vector<std::string> attributeTypeQualifiers;$/;"	m	class:souffle::InterpreterRelation
attributeTypeQualifiers	RamRelation.h	/^    const std::vector<std::string> attributeTypeQualifiers;$/;"	m	class:souffle::RamRelation
attributes	AstRelation.h	/^    std::vector<std::unique_ptr<AstAttribute>> attributes;$/;"	m	class:souffle::AstRelation
auto	profile/htmlMain.h	/^    <div id="Help" class="tabcontent" style="max-width:800px;margin-left: auto;margin-right: auto;">$/;"	m	namespace:souffle::profile::html
auto	profile/htmlMain.h	/^    <div id="Top" class="tabcontent" style="margin-left: auto;margin-right: auto;">$/;"	m	namespace:souffle::profile::html
aux_order	CompiledIndexUtils.h	/^struct aux_order<Pos, First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
aux_order	CompiledIndexUtils.h	/^struct aux_order<Pos> {$/;"	s	namespace:souffle::ram::index_utils
avalue	Brie.h	/^        atomic_value_type avalue;$/;"	m	union:souffle::SparseArray::Cell
b	Util.h	/^    Iter a, b;$/;"	m	struct:souffle::range
b2p	UnionFind.h	/^    static inline parent_t b2p(const block_t inblock) {$/;"	f	class:souffle::DisjointSet
b2r	UnionFind.h	/^    static inline rank_t b2r(const block_t inblock) {$/;"	f	class:souffle::DisjointSet
backingGraph	PrecedenceGraph.h	/^    Graph<const AstRelation*, AstNameComparison> backingGraph;$/;"	m	class:souffle::PrecedenceGraph
backspace	profile/UserInputReader.h	/^    void backspace() {$/;"	f	class:souffle::profile::InputReader
base	BTree.h	/^        base(bool inner) : parent(nullptr), numElements(0), position(0), inner(inner) {}$/;"	f	struct:souffle::detail::btree::base
base	BTree.h	/^    struct base {$/;"	s	class:souffle::detail::btree
base	profile/Reader.h	/^    T& base;$/;"	m	class:souffle::profile::__anon72::DSNVisitor
base	test/test.h	/^static class TestCase* base = nullptr;$/;"	v	typeref:class:TestCase
baseComponents	AstComponent.h	/^    std::vector<std::unique_ptr<AstComponentType>> baseComponents;$/;"	m	class:souffle::AstComponent
baseName	ReadStreamCSV.h	/^    std::string baseName;$/;"	m	class:souffle::ReadFileCSV
baseType	TypeSystem.h	/^    const Type& baseType;$/;"	m	class:souffle::PrimitiveType
basic_symbol	parser.hh	/^      basic_symbol ()$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstArgument *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstAtom *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstClause *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstComponent *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstComponentInit *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstComponentType *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstDomain&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstExecutionOrder *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstExecutionPlan *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstFunctorDeclaration *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstIO *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstPragma *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstRecordInit *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstRecordType *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstRelation *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstRelationIdentifier *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstType *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstTypeIdentifier *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstUnionType *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, AstUserDefinedFunctor *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, RuleBody *&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstArgument *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstAtom *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstClause *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstComponent *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstComponentInit *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstComponentType *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstDomain& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstExecutionOrder *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstExecutionPlan *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstFunctorDeclaration *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstIO *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstPragma *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstRecordInit *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstRecordType *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstRelation *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstRelationIdentifier *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstType *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstTypeIdentifier *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstUnionType *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const AstUserDefinedFunctor *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const RuleBody *& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::string& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstAtom*>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstClause*>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstIO *>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstLoad *>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstRelation *>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstStore *>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const std::vector<AstTypeIdentifier>& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, const uint32_t& v, const location_type& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::string&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstAtom*>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstClause*>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstIO *>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstLoad *>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstRelation *>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstStore *>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, std::vector<AstTypeIdentifier>&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^      basic_symbol (typename Base::kind_type t, uint32_t&& v, location_type&& l)$/;"	f	struct:yy::parser::basic_symbol
basic_symbol	parser.hh	/^    struct basic_symbol : Base$/;"	s	class:yy::parser
basic_symbol	parser.hh	/^  parser::basic_symbol<Base>::basic_symbol (basic_symbol&& that)$/;"	f	class:yy::parser::basic_symbol
basic_symbol	parser.hh	/^  parser::basic_symbol<Base>::basic_symbol (const basic_symbol& that)$/;"	f	class:yy::parser::basic_symbol
begin	AstClause.h	/^    const_iterator begin() const {$/;"	f	class:souffle::AstExecutionOrder
begin	BTree.h	/^    iterator begin() const {$/;"	f	class:souffle::detail::btree
begin	Brie.h	/^    iterator begin() const {$/;"	f	class:souffle::SparseArray
begin	Brie.h	/^    iterator begin() const {$/;"	f	class:souffle::SparseBitMap
begin	Brie.h	/^    iterator begin() const {$/;"	f	class:souffle::Trie
begin	CompiledIndexUtils.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
begin	CompiledIndexUtils.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
begin	CompiledIndexUtils.h	/^    iterator begin() const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
begin	CompiledIndexUtils.h	/^    iterator begin() const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
begin	CompiledRelation.h	/^        bool begin;$/;"	m	class:souffle::ram::detail::AutoRelation::iterator
begin	CompiledRelation.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::detail::AutoRelation
begin	CompiledRelation.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::detail::GenericRelation
begin	CompiledRelation.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
begin	CompiledRelation.h	/^    iterator begin() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
begin	CompiledSouffle.h	/^    iterator begin() const {$/;"	f	class:souffle::t_nullaries
begin	Constraints.h	/^    iterator begin() const {$/;"	f	class:souffle::Assignment
begin	EquivalenceRelation.h	/^    iterator begin() const {$/;"	f	class:souffle::EquivalenceRelation
begin	InterpreterRelation.h	/^    inline iterator begin() const {$/;"	f	class:souffle::InterpreterRelation
begin	PiggyList.h	/^    iterator begin() {$/;"	f	class:souffle::PiggyList
begin	Table.h	/^    iterator begin() const {$/;"	f	class:souffle::Table
begin	TypeSystem.h	/^    const_iterator begin() const {$/;"	f	struct:souffle::TypeSet
begin	Util.h	/^    Iter begin;$/;"	m	class:souffle::detail::joined_sequence
begin	Util.h	/^    Iter& begin() {$/;"	f	struct:souffle::range
begin	Util.h	/^    const Iter& begin() const {$/;"	f	struct:souffle::range
bfSearch	IndexSetAnalysis.cpp	/^bool MaxMatching::bfSearch() {$/;"	f	class:souffle::MaxMatching
bin_PROGRAMS	Makefile	/^bin_PROGRAMS = souffle$(EXEEXT) souffle-profile$(EXEEXT) \\$/;"	m
binary	BTree.h	/^struct binary : public strategy_selection<binary_search> {};$/;"	s	namespace:souffle::detail
binary_search	BTree.h	/^struct binary_search : public search_strategy {$/;"	s	namespace:souffle::detail
bindArguments	MagicSet.cpp	/^std::pair<std::string, std::set<std::string>> bindArguments($/;"	f	namespace:souffle
bindComposites	MagicSet.cpp	/^BindingStore bindComposites(const AstProgram* program) {$/;"	f	namespace:souffle
binding	ComponentModel.h	/^    std::map<AstTypeIdentifier, AstTypeIdentifier> binding;$/;"	m	class:souffle::TypeBinding
bindings	MagicSet.h	/^    BindingStore bindings;$/;"	m	class:souffle::Adornment
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bl	PiggyList.h	/^        PiggyList* bl;$/;"	m	class:souffle::PiggyList::iterator
block	Table.h	/^        Block* block;$/;"	m	class:souffle::Table::iterator
blockList	InterpreterRelation.h	/^    std::deque<std::unique_ptr<RamDomain[]>> blockList;$/;"	m	class:souffle::InterpreterRelation
blockLookupTable	PiggyList.h	/^    std::array<T*, max_conts> blockLookupTable = {};$/;"	m	class:souffle::PiggyList
blockLookupTable	PiggyList.h	/^    std::array<std::atomic<T*>, maxContainers> blockLookupTable = {};$/;"	m	class:souffle::RandomInsertPiggyList
body	AstArgument.h	/^    std::vector<std::unique_ptr<AstLiteral>> body;$/;"	m	class:souffle::AstAggregator
body	DebugReport.h	/^    std::string body;$/;"	m	class:souffle::DebugReportSection
body	RamStatement.h	/^    std::unique_ptr<RamStatement> body;$/;"	m	class:souffle::RamLoop
body	RamStatement.h	/^    std::unique_ptr<RamStatement> body;$/;"	m	class:souffle::RamStratum
bodyAdornment	MagicSet.h	/^    std::vector<std::string> bodyAdornment;$/;"	m	class:souffle::AdornedClause
bool_disjunct_lattic	AstGroundAnalysis.cpp	/^struct bool_disjunct_lattic : public property_space<bool, bool_or, false_factory> {};$/;"	s	namespace:souffle::__anon2	file:
bool_or	AstGroundAnalysis.cpp	/^struct bool_or {$/;"	s	namespace:souffle::__anon2	file:
bool_value	json11.h	/^inline bool Json::bool_value() const {$/;"	f	class:json11::Json
bool_value	json11.h	/^inline bool JsonValue::bool_value() const {$/;"	f	class:json11::JsonValue
br	EquivalenceRelation.h	/^        const EquivalenceRelation* br = nullptr;$/;"	m	class:souffle::EquivalenceRelation::iterator
brie_index_factory	CompiledRelation.h	/^    struct brie_index_factory {$/;"	s	struct:souffle::ram::Brie
btree	BTree.h	/^    btree(btree&& other)$/;"	f	class:souffle::detail::btree
btree	BTree.h	/^    btree(const Comparator& comp = Comparator(), const WeakComparator& weak_comp = WeakComparator())$/;"	f	class:souffle::detail::btree
btree	BTree.h	/^    btree(const Iter& a, const Iter& b) : root(nullptr), leftmost(nullptr) {$/;"	f	class:souffle::detail::btree
btree	BTree.h	/^    btree(const btree& set) : comp(set.comp), weak_comp(set.weak_comp), root(nullptr), leftmost(nullptr) {$/;"	f	class:souffle::detail::btree
btree	BTree.h	/^    btree(size_type size, node* root, leaf_node* leftmost) : root(root), leftmost(leftmost) {}$/;"	f	class:souffle::detail::btree
btree	BTree.h	/^class btree {$/;"	c	namespace:souffle::detail
btree_index_factory	CompiledRelation.h	/^    struct btree_index_factory {$/;"	s	struct:souffle::ram::BTree
btree_multiset	BTree.h	/^    btree_multiset(btree_multiset&& other) : super(std::move(other)) {}$/;"	f	class:souffle::btree_multiset
btree_multiset	BTree.h	/^    btree_multiset(const Comparator& comp = Comparator(), const WeakComparator& weak_comp = WeakComparator())$/;"	f	class:souffle::btree_multiset
btree_multiset	BTree.h	/^    btree_multiset(const Iter& a, const Iter& b) {$/;"	f	class:souffle::btree_multiset
btree_multiset	BTree.h	/^    btree_multiset(const btree_multiset& other) : super(other) {}$/;"	f	class:souffle::btree_multiset
btree_multiset	BTree.h	/^    btree_multiset(s size, n* root, l* leftmost) : super(size, root, leftmost) {}$/;"	f	class:souffle::btree_multiset
btree_multiset	BTree.h	/^class btree_multiset : public detail::btree<Key, Comparator, Allocator, blockSize, SearchStrategy, false,$/;"	c	namespace:souffle
btree_operation_hints	BTree.h	/^    struct btree_operation_hints {$/;"	s	class:souffle::detail::btree
btree_set	BTree.h	/^    btree_set(btree_set&& other) : super(std::move(other)) {}$/;"	f	class:souffle::btree_set
btree_set	BTree.h	/^    btree_set(const Comparator& comp = Comparator(), const WeakComparator& weak_comp = WeakComparator())$/;"	f	class:souffle::btree_set
btree_set	BTree.h	/^    btree_set(const Iter& a, const Iter& b) {$/;"	f	class:souffle::btree_set
btree_set	BTree.h	/^    btree_set(const btree_set& other) : super(other) {}$/;"	f	class:souffle::btree_set
btree_set	BTree.h	/^    btree_set(s size, n* root, l* leftmost) : super(size, root, leftmost) {}$/;"	f	class:souffle::btree_set
btree_set	BTree.h	/^class btree_set : public detail::btree<Key, Comparator, Allocator, blockSize, SearchStrategy, true,$/;"	c	namespace:souffle
buf	gzfstream.h	/^    mutable gzfstreambuf buf;$/;"	m	class:souffle::gzfstream::internal::gzfstream
buffer	ExplainTree.h	/^    char* buffer;     \/\/ screen contents$/;"	m	class:souffle::ScreenBuffer
buffer	Util.h	/^    NullBuffer buffer;$/;"	m	class:souffle::NullStream
buffer	gzfstream.h	/^    char buffer[bufferSize] = {};$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
bufferSize	gzfstream.h	/^    static constexpr unsigned int bufferSize = 65536;$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
build	Makefile	/^build = x86_64-apple-darwin18.5.0$/;"	m
build	parser.hh	/^    build ()$/;"	f	class:yy::parser::semantic_type
build	parser.hh	/^    build (const T& t)$/;"	f	class:yy::parser::semantic_type
buildSubTree	BTree.h	/^    static node* buildSubTree(const Iter& a, const Iter& b) {$/;"	f	class:souffle::detail::btree
build_alias	Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = x86_64$/;"	m
build_os	Makefile	/^build_os = darwin18.5.0$/;"	m
build_triplet	Makefile	/^build_triplet = x86_64-apple-darwin18.5.0$/;"	m
build_vendor	Makefile	/^build_vendor = apple$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
byDefault	Global.h	/^    std::string byDefault; \/* The default value for this option, used if no this option is not specified as a$/;"	m	struct:souffle::MainOption
by_state	parser.hh	/^    struct by_state$/;"	s	class:yy::parser
by_type	parser.hh	/^    struct by_type$/;"	s	class:yy::parser
by_type	parser.hh	/^  parser::by_type::by_type ()$/;"	f	class:yy::parser::by_type
by_type	parser.hh	/^  parser::by_type::by_type (by_type&& that)$/;"	f	class:yy::parser::by_type
by_type	parser.hh	/^  parser::by_type::by_type (const by_type& that)$/;"	f	class:yy::parser::by_type
by_type	parser.hh	/^  parser::by_type::by_type (token_type t)$/;"	f	class:yy::parser::by_type
cAnteriorIndex	EquivalenceRelation.h	/^        size_t cAnteriorIndex = 0;$/;"	m	class:souffle::EquivalenceRelation::iterator
cIndex	PiggyList.h	/^        size_t cIndex = 0;$/;"	m	class:souffle::PiggyList::iterator
cPair	EquivalenceRelation.h	/^        TupleType cPair;$/;"	m	class:souffle::EquivalenceRelation::iterator
cPosteriorIndex	EquivalenceRelation.h	/^        size_t cPosteriorIndex = 0;$/;"	m	class:souffle::EquivalenceRelation::iterator
cRecursiveRelation	LogStatement.h	/^    static const std::string cRecursiveRelation($/;"	f	class:souffle::LogStatement
cacheLookup	SymbolTable.h	/^    RamDomain cacheLookup(const std::string& symbol, const int tag) const {$/;"	f	class:souffle::SymbolTable
cacheResolve	SymbolTable.h	/^    const std::string& cacheResolve(const RamDomain index, const int tag) const {$/;"	f	class:souffle::SymbolTable
came_from	profile/htmlMain.h	/^        <li><a class="tablinks" id="rel_tab" onclick="changeTab(event, 'Relations');came_from = 'rel';">Relations<\/a><\/li>$/;"	m	namespace:souffle::profile::html
came_from	profile/htmlMain.h	/^        <li><a class="tablinks" id="rul_tab" onclick="changeTab(event, 'Rules');came_from = 'rul';">Rules<\/a><\/li>$/;"	m	namespace:souffle::profile::html
card	IndexSetAnalysis.h	/^    static size_t card(SearchColumns cols) {$/;"	f	class:souffle::IndexSet
card	test/brie_test.cpp	/^int card(const Container& c) {$/;"	f	namespace:__anon5
card	test/brie_test.cpp	/^int card(const range<Iter>& r) {$/;"	f	namespace:__anon5
cell	Brie.h	/^        Cell cell[NUM_CELLS];$/;"	m	struct:souffle::SparseArray::Node
cells	profile/Row.h	/^    std::vector<std::shared_ptr<CellInterface>> cells;$/;"	m	class:souffle::profile::Row
chainToOrder	IndexSetAnalysis.h	/^    ChainOrderMap chainToOrder;   \/\/ maps order index to set of searches covered by chain$/;"	m	class:souffle::IndexSet
check	BTree.h	/^        bool check(Comp& comp, const node* root) const {$/;"	f	struct:souffle::detail::btree::node
check	BTree.h	/^    bool check() {$/;"	f	class:souffle::detail::btree
check	CompiledIndexUtils.h	/^struct check {$/;"	s	namespace:souffle::ram::index_utils
checkAggregator	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkAggregator($/;"	f	class:souffle::AstSemanticChecker
checkArgument	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkArgument($/;"	f	class:souffle::AstSemanticChecker
checkAtom	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkAtom(ErrorReport& report, const AstProgram& program, const AstAtom& atom) {$/;"	f	class:souffle::AstSemanticChecker
checkClause	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkClause(ErrorReport& report, const AstProgram& program, const AstClause& clause,$/;"	f	class:souffle::AstSemanticChecker
checkComponent	AstComponentChecker.cpp	/^void AstComponentChecker::checkComponent(ErrorReport& report, const AstComponent* enclosingComponent,$/;"	f	class:souffle::AstComponentChecker
checkComponentInit	AstComponentChecker.cpp	/^void AstComponentChecker::checkComponentInit(ErrorReport& report, const AstComponent* enclosingComponent,$/;"	f	class:souffle::AstComponentChecker
checkComponentNameReference	AstComponentChecker.cpp	/^const AstComponent* AstComponentChecker::checkComponentNameReference(ErrorReport& report,$/;"	f	class:souffle::AstComponentChecker
checkComponentNamespaces	AstComponentChecker.cpp	/^void AstComponentChecker::checkComponentNamespaces(ErrorReport& report, const AstProgram& program) {$/;"	f	class:souffle::AstComponentChecker
checkComponentReference	AstComponentChecker.cpp	/^void AstComponentChecker::checkComponentReference(ErrorReport& report, const AstComponent* enclosingComponent,$/;"	f	class:souffle::AstComponentChecker
checkComponents	AstComponentChecker.cpp	/^void AstComponentChecker::checkComponents($/;"	f	class:souffle::AstComponentChecker
checkConstant	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkConstant(ErrorReport& report, const AstArgument& argument) {$/;"	f	class:souffle::AstSemanticChecker
checkFact	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkFact(ErrorReport& report, const AstProgram& program, const AstClause& fact) {$/;"	f	class:souffle::AstSemanticChecker
checkIODirectives	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkIODirectives(ErrorReport& report, const AstProgram& program) {$/;"	f	class:souffle::AstSemanticChecker
checkInlining	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkInlining(ErrorReport& report, const AstProgram& program,$/;"	f	class:souffle::AstSemanticChecker
checkLiteral	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkLiteral($/;"	f	class:souffle::AstSemanticChecker
checkNamespaces	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkNamespaces(ErrorReport& report, const AstProgram& program) {$/;"	f	class:souffle::AstSemanticChecker
checkPerformance	test/btree_multiset_test.cpp	/^#define checkPerformance(/;"	d	file:
checkPerformance	test/btree_set_test.cpp	/^#define checkPerformance(/;"	d	file:
checkProgram	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkProgram(ErrorReport& report, const AstProgram& program,$/;"	f	class:souffle::AstSemanticChecker
checkRecordType	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkRecordType($/;"	f	class:souffle::AstSemanticChecker
checkRelation	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkRelation(ErrorReport& report, const TypeEnvironment& typeEnv,$/;"	f	class:souffle::AstSemanticChecker
checkRelationDeclaration	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkRelationDeclaration(ErrorReport& report, const TypeEnvironment& typeEnv,$/;"	f	class:souffle::AstSemanticChecker
checkRules	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkRules(ErrorReport& report, const TypeEnvironment& typeEnv,$/;"	f	class:souffle::AstSemanticChecker
checkTableExists	ReadStreamSQLite.h	/^    void checkTableExists() {$/;"	f	class:souffle::ReadStreamSQLite
checkType	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkType(ErrorReport& report, const AstProgram& program, const AstType& type) {$/;"	f	class:souffle::AstSemanticChecker
checkTypes	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkTypes(ErrorReport& report, const AstProgram& program) {$/;"	f	class:souffle::AstSemanticChecker
checkUnionType	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkUnionType($/;"	f	class:souffle::AstSemanticChecker
checkWitnessProblem	AstSemanticChecker.cpp	/^void AstSemanticChecker::checkWitnessProblem(ErrorReport& report, const AstProgram& program) {$/;"	f	class:souffle::AstSemanticChecker
check_PROGRAMS	Makefile	/^check_PROGRAMS = test\/util_test$(EXEEXT) test\/matching_test$(EXEEXT) \\$/;"	m
check_arity	CompiledIndexUtils.h	/^struct check_arity<arity, F, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
check_arity	CompiledIndexUtils.h	/^struct check_arity<arity> {$/;"	s	namespace:souffle::ram::index_utils
check_index_arity	CompiledIndexUtils.h	/^struct check_index_arity {$/;"	s	namespace:souffle::ram::index_utils
check_index_arity	CompiledIndexUtils.h	/^struct check_index_arity<arity, index<>> {$/;"	s	namespace:souffle::ram::index_utils
check_index_arity	CompiledIndexUtils.h	/^struct check_index_arity<arity, index<F, Rest...>> {$/;"	s	namespace:souffle::ram::index_utils
children	BTree.h	/^        node* children[node::maxKeys + 1];$/;"	m	struct:souffle::detail::btree::inner_node
children	ExplainTree.h	/^    std::vector<std::unique_ptr<TreeNode>> children;$/;"	m	class:souffle::InnerNode
cilk_for	ParallelUtils.h	/^#define cilk_for /;"	d
clause	MagicSet.h	/^    AstClause* clause;$/;"	m	class:souffle::AdornedClause
clauseNum	AstClause.h	/^    size_t clauseNum = 0;$/;"	m	class:souffle::AstClause
clauseSize	AstRelation.h	/^    size_t clauseSize() const {$/;"	f	class:souffle::AstRelation
clauses	AstComponent.h	/^    std::vector<std::unique_ptr<AstClause>> clauses;$/;"	m	class:souffle::AstComponent
clauses	AstProgram.h	/^    std::vector<std::unique_ptr<AstClause>> clauses;$/;"	m	class:souffle::AstProgram
clauses	AstRelation.h	/^    std::vector<std::unique_ptr<AstClause>> clauses;$/;"	m	class:souffle::AstRelation
clean	Brie.h	/^    void clean() {$/;"	f	class:souffle::SparseArray
cleanJsonOut	profile/StringUtils.h	/^inline std::string cleanJsonOut(double val) {$/;"	f	namespace:souffle::profile::Tools
cleanJsonOut	profile/StringUtils.h	/^inline std::string cleanJsonOut(std::string val) {$/;"	f	namespace:souffle::profile::Tools
cleanRelationName	profile/Reader.h	/^    std::string cleanRelationName(const std::string& relationName) {$/;"	f	class:souffle::profile::Reader
cleanString	profile/StringUtils.h	/^inline std::string cleanString(std::string val) {$/;"	f	namespace:souffle::profile::Tools
cleanUp	Interpreter.h	/^       void cleanUp() {$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
cleanup	BTree.h	/^        void cleanup() {$/;"	f	struct:souffle::detail::btree::inner_node
clear	BTree.h	/^        void clear() {$/;"	f	struct:souffle::detail::btree::btree_operation_hints
clear	BTree.h	/^    void clear() {$/;"	f	class:souffle::detail::btree
clear	Brie.h	/^    void clear() {$/;"	f	class:souffle::SparseArray
clear	Brie.h	/^    void clear() {$/;"	f	class:souffle::SparseBitMap
clear	Brie.h	/^    void clear() {$/;"	f	class:souffle::Trie
clear	CompiledIndexUtils.h	/^    void clear() {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
clear	CompiledIndexUtils.h	/^    void clear() {$/;"	f	class:souffle::ram::index_utils::Indices
clear	CompiledIndexUtils.h	/^    void clear() {$/;"	f	class:souffle::ram::index_utils::TrieIndex
clear	CompiledIndexUtils.h	/^    void clear() {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
clear	CompiledIndexUtils.h	/^    void clear() {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
clear	CompiledIndexUtils.h	/^    void clear() {}$/;"	f	class:souffle::ram::index_utils::Indices
clear	CompiledRelation.h	/^    void clear() {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
clear	EquivalenceRelation.h	/^        void clear() {}$/;"	f	struct:souffle::EquivalenceRelation::operation_hints
clear	EquivalenceRelation.h	/^    void clear() {$/;"	f	class:souffle::EquivalenceRelation
clear	PiggyList.h	/^    void clear() {$/;"	f	class:souffle::PiggyList
clear	PiggyList.h	/^    void clear() {$/;"	f	class:souffle::RandomInsertPiggyList
clear	Table.h	/^    void clear() {$/;"	f	class:souffle::Table
clear	TypeSystem.cpp	/^void TypeEnvironment::clear() {$/;"	f	class:souffle::TypeEnvironment
clear	UnionFind.h	/^    void clear() {$/;"	f	class:souffle::DisjointSet
clear	UnionFind.h	/^    void clear() {$/;"	f	class:souffle::SparseDisjointSet
clear	parser.hh	/^      void clear ()$/;"	f	struct:yy::parser::basic_symbol
clear	parser.hh	/^  parser::by_type::clear ()$/;"	f	class:yy::parser::by_type
clearBodyLiterals	AstArgument.h	/^    void clearBodyLiterals() {$/;"	f	class:souffle::AstAggregator
clearExecutionPlan	AstClause.h	/^    void clearExecutionPlan() {$/;"	f	class:souffle::AstClause
clearHistory	profile/UserInputReader.h	/^    void clearHistory() {$/;"	f	class:souffle::profile::InputReader
clearPrompt	profile/UserInputReader.h	/^    void clearPrompt(size_t text_len) {$/;"	f	class:souffle::profile::InputReader
clearTabCompletion	profile/UserInputReader.h	/^    void clearTabCompletion() {$/;"	f	class:souffle::profile::InputReader
clique	GraphUtils.h	/^    const std::set<Vertex, Compare> clique(const Vertex& vertex) const {$/;"	f	class:souffle::Graph
clone	AstArgument.cpp	/^AstAggregator* AstAggregator::clone() const {$/;"	f	class:souffle::AstAggregator
clone	AstParserUtils.h	/^        literal clone() const {$/;"	f	struct:souffle::RuleBody::literal
clone	AstProgram.cpp	/^AstProgram* AstProgram::clone() const {$/;"	f	class:souffle::AstProgram
clone	BTree.h	/^        node* clone() const {$/;"	f	struct:souffle::detail::btree::node
clone	Brie.h	/^    static Node* clone(const Node* node, int level) {$/;"	f	class:souffle::SparseArray
cloneHead	AstClause.h	/^    AstClause* cloneHead() const {$/;"	f	class:souffle::AstClause
cloneOriginalArgument	MagicSet.h	/^    AstArgument* cloneOriginalArgument(const std::string& argName) const {$/;"	f	class:souffle::BindingStore
close	gzfstream.h	/^    gzfstreambuf* close() {$/;"	f	class:souffle::gzfstream::internal::gzfstreambuf
close	gzfstream.h	/^    void close() {$/;"	f	class:souffle::gzfstream::internal::gzfstream
closure	EquivalenceRelation.h	/^    iterator closure(value_type rep) const {$/;"	f	class:souffle::EquivalenceRelation
code	Interpreter.h	/^       std::vector<RamDomain> code;            \/** Instructions stream *\/$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
collectChunks	BTree.h	/^        std::vector<chunk>& collectChunks($/;"	f	struct:souffle::detail::btree::node
collectContent	ComponentModel.cpp	/^void collectContent(const AstComponent& component, const TypeBinding& binding,$/;"	f	namespace:souffle::__anon73
column	SrcLocation.h	/^        int column;$/;"	m	struct:souffle::SrcLocation::Point
column_utils	CompiledIndexUtils.h	/^namespace column_utils {$/;"	n	namespace:souffle::ram
columns	InterpreterIndex.h	/^    std::vector<unsigned char> columns;$/;"	m	class:souffle::InterpreterIndexOrder
combineAggregators	InlineRelationsTransformer.cpp	/^AstArgument* combineAggregators(std::vector<AstAggregator*> aggrs, FunctorOp fun) {$/;"	f	namespace:souffle
combineNegatedLiterals	InlineRelationsTransformer.cpp	/^std::vector<std::vector<AstLiteral*>> combineNegatedLiterals($/;"	f	namespace:souffle
commRank	Mpi.h	/^inline int commRank() {$/;"	f	namespace:souffle::mpi::__anon60
commSize	Mpi.h	/^inline int commSize() {$/;"	f	namespace:souffle::mpi::__anon59
comp	BTree.h	/^    mutable Comparator comp;$/;"	m	class:souffle::detail::btree
comp	CompiledIndexUtils.h	/^    typename Index::comparator comp;$/;"	m	class:souffle::ram::iterator_utils::filter_iterator
comp_deref	Util.h	/^struct comp_deref {$/;"	s	namespace:souffle
comparator	BTree.h	/^struct comparator {$/;"	s	namespace:souffle::detail
comparator	CompiledIndexUtils.h	/^struct comparator<> {$/;"	s	namespace:souffle::ram::index_utils
comparator	CompiledIndexUtils.h	/^struct comparator<First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
comparator	InterpreterIndex.h	/^        comparator(const InterpreterIndexOrder& order) : order(order) {}$/;"	f	struct:souffle::InterpreterIndex::comparator
comparator	InterpreterIndex.h	/^    struct comparator {$/;"	s	class:souffle::InterpreterIndex
compileToBinary	main.cpp	/^void compileToBinary(std::string compileCmd, const std::string& sourceFilename) {$/;"	f	namespace:souffle
componentType	AstComponent.h	/^    std::unique_ptr<AstComponentType> componentType;$/;"	m	class:souffle::AstComponentInit
components	AstComponent.h	/^    std::vector<std::unique_ptr<AstComponent>> components;$/;"	m	class:souffle::AstComponent
components	AstProgram.h	/^    std::vector<std::unique_ptr<AstComponent>> components;$/;"	m	class:souffle::AstProgram
computeIndices	SynthesiserRelation.cpp	/^void SynthesiserBrieRelation::computeIndices() {$/;"	f	class:souffle::SynthesiserBrieRelation
computeIndices	SynthesiserRelation.cpp	/^void SynthesiserDirectRelation::computeIndices() {$/;"	f	class:souffle::SynthesiserDirectRelation
computeIndices	SynthesiserRelation.cpp	/^void SynthesiserEqrelRelation::computeIndices() {$/;"	f	class:souffle::SynthesiserEqrelRelation
computeIndices	SynthesiserRelation.cpp	/^void SynthesiserIndirectRelation::computeIndices() {$/;"	f	class:souffle::SynthesiserIndirectRelation
computeIndices	SynthesiserRelation.cpp	/^void SynthesiserNullaryRelation::computeIndices() {$/;"	f	class:souffle::SynthesiserNullaryRelation
computeIsRecursive	PrecedenceGraph.cpp	/^bool RecursiveClauses::computeIsRecursive($/;"	f	class:souffle::RecursiveClauses
computeRelationExpirySchedule	PrecedenceGraph.cpp	/^std::vector<std::set<const AstRelation*>> RelationSchedule::computeRelationExpirySchedule($/;"	f	class:souffle::RelationSchedule
computeTopologicalOrdering	PrecedenceGraph.cpp	/^void TopologicallySortedSCCGraph::computeTopologicalOrdering(size_t scc, std::vector<bool>& visited) {$/;"	f	class:souffle::TopologicallySortedSCCGraph
computed	PrecedenceGraph.h	/^    const std::set<const AstRelation*>& computed() const {$/;"	f	class:souffle::RelationScheduleStep
computedIndices	SynthesiserRelation.h	/^    std::vector<IndexSet::LexicographicalOrder> computedIndices;$/;"	m	class:souffle::SynthesiserRelation
computedRelations	PrecedenceGraph.h	/^    std::set<const AstRelation*> computedRelations;$/;"	m	class:souffle::RelationScheduleStep
concat	CompiledIndexUtils.h	/^struct concat<index<C1...>, index<C2...>> {$/;"	s	namespace:souffle::ram::index_utils
condition	AstTransforms.h	/^    std::function<bool()> condition;$/;"	m	class:souffle::ConditionalTransformer
condition	AstTransforms.h	/^    std::function<bool()> condition;$/;"	m	class:souffle::WhileTransformer
condition	RamOperation.h	/^    std::unique_ptr<RamCondition> condition;$/;"	m	class:souffle::RamAggregate
condition	RamOperation.h	/^    std::unique_ptr<RamCondition> condition;$/;"	m	class:souffle::RamFilter
condition	RamStatement.h	/^    std::unique_ptr<RamCondition> condition;$/;"	m	class:souffle::RamExit
condition	RamStatement.h	/^    std::unique_ptr<RamCondition> condition;$/;"	m	class:souffle::RamQuery
conditionVariable	ProfileEvent.h	/^        std::condition_variable conditionVariable;$/;"	m	class:souffle::ProfileEventSingleton::ProfileTimer
config	Global.h	/^    static MainConfig& config() {$/;"	f	class:souffle::Global
configProcessor	EventProcessor.h	/^} configProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::ConfigProcessor
configuration	profile/Tui.h	/^    void configuration() {$/;"	f	namespace:souffle::profile
conjunct	AstParserUtils.cpp	/^void RuleBody::conjunct(RuleBody&& other) {$/;"	f	class:souffle::RuleBody
const_iterator	parser.hh	/^      typedef typename S::const_reverse_iterator const_iterator;$/;"	t	class:yy::parser::stack
constant	RamExpression.h	/^    const RamDomain constant;$/;"	m	class:souffle::RamNumber
constraint	AstParserUtils.cpp	/^RuleBody RuleBody::constraint(AstConstraint* constraint) {$/;"	f	class:souffle::RuleBody
constraintList	ExplainProvenanceSLD.h	/^    std::vector<std::string> constraintList = {$/;"	m	class:souffle::ExplainProvenanceSLD
constraints	AstClause.h	/^    std::vector<std::unique_ptr<AstConstraint>> constraints;$/;"	m	class:souffle::AstClause
constraints	AstConstraintAnalysis.h	/^    Problem<AnalysisVar> constraints;$/;"	m	class:souffle::__anon68::AstConstraintAnalysis
consume	test/compiled_relation_test.cpp	/^void consume(T t) {}$/;"	f	namespace:souffle::ram
consume_comment	json11.h	/^    bool consume_comment() {$/;"	f	struct:json11::__anon66::final
consume_garbage	json11.h	/^    void consume_garbage() {$/;"	f	struct:json11::__anon66::final
consume_whitespace	json11.h	/^    void consume_whitespace() {$/;"	f	struct:json11::__anon66::final
container_size	PiggyList.h	/^    std::atomic<size_t> container_size;$/;"	m	class:souffle::PiggyList
contains	BTree.h	/^        CacheAccessCounter contains;$/;"	m	struct:souffle::detail::btree::hint_statistics
contains	BTree.h	/^    bool contains(const Key& k) const {$/;"	f	class:souffle::detail::btree
contains	BTree.h	/^    bool contains(const Key& k, operation_hints& hints) const {$/;"	f	class:souffle::detail::btree
contains	Brie.h	/^        CacheAccessCounter contains;$/;"	m	struct:souffle::detail::TrieBase::hint_statistics
contains	Brie.h	/^    bool contains(Values... values) const {$/;"	f	class:souffle::detail::TrieBase
contains	Brie.h	/^    bool contains(const entry_type& tuple) const {$/;"	f	class:souffle::Trie
contains	Brie.h	/^    bool contains(const entry_type& tuple, op_context& ctxt) const {$/;"	f	class:souffle::Trie
contains	Brie.h	/^    bool contains(const entry_type& tuple, op_context&) const {$/;"	f	class:souffle::Trie
contains	Brie.h	/^    bool contains(const entry_type&) const {$/;"	f	class:souffle::Trie
contains	CompiledIndexUtils.h	/^    bool contains(const T& tuple, const First&, operation_context& c) const {$/;"	f	class:souffle::ram::index_utils::Indices
contains	CompiledIndexUtils.h	/^    bool contains(const T& tuple, const Index& i, operation_context& c) const {$/;"	f	class:souffle::ram::index_utils::Indices
contains	CompiledIndexUtils.h	/^    bool contains(const T&, const Index&, operation_context&) const {$/;"	f	class:souffle::ram::index_utils::Indices
contains	CompiledIndexUtils.h	/^    bool contains(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
contains	CompiledIndexUtils.h	/^    bool contains(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
contains	CompiledIndexUtils.h	/^    bool contains(const tuple_type& tuple, operation_hints& ctxt) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
contains	CompiledIndexUtils.h	/^    bool contains(const tuple_type& tuple, operation_hints& ctxt) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
contains	CompiledIndexUtils.h	/^struct contains<E, E, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
contains	CompiledIndexUtils.h	/^struct contains<E, F, Rest...> {$/;"	s	namespace:souffle::ram::column_utils
contains	CompiledIndexUtils.h	/^struct contains<E, F, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
contains	CompiledIndexUtils.h	/^struct contains<E> {$/;"	s	namespace:souffle::ram::column_utils
contains	CompiledIndexUtils.h	/^struct contains<E> {$/;"	s	namespace:souffle::ram::index_utils
contains	CompiledRelation.h	/^    bool contains(Args... args) const {$/;"	f	struct:souffle::ram::detail::RelationBase
contains	CompiledRelation.h	/^    bool contains(const tuple_type& = tuple_type(), const operation_context& = operation_context()) const {$/;"	f	class:souffle::ram::detail::AutoRelation
contains	CompiledRelation.h	/^    bool contains(const tuple_type& element) const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
contains	CompiledRelation.h	/^    bool contains(const tuple_type& tuple) const {$/;"	f	struct:souffle::ram::detail::RelationBase
contains	CompiledRelation.h	/^    bool contains(const tuple_type& tuple, operation_context& context) const {$/;"	f	class:souffle::ram::detail::AutoRelation
contains	CompiledRelation.h	/^    bool contains(const tuple_type& tuple, operation_context& context) const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
contains	CompiledRelation.h	/^    bool contains(const tuple_type& tuple, operation_context& ctxt) const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
contains	CompiledRelation.h	/^    bool contains(const tuple_type& tuple, operation_context&) const {$/;"	f	class:souffle::ram::detail::GenericRelation
contains	CompiledSouffle.h	/^    bool contains(const t_tuple& t) const {$/;"	f	class:souffle::t_nullaries
contains	CompiledSouffle.h	/^    bool contains(const t_tuple& t, context& \/* ctxt *\/) const {$/;"	f	class:souffle::t_nullaries
contains	EquivalenceRelation.h	/^    bool contains(value_type x, value_type y) const {$/;"	f	class:souffle::EquivalenceRelation
contains	GraphUtils.h	/^    bool contains(const Vertex& from, const Vertex& to) const {$/;"	f	class:souffle::Graph
contains	GraphUtils.h	/^    bool contains(const Vertex& vertex) const {$/;"	f	class:souffle::Graph
contains	MagicSet.cpp	/^bool contains(std::set<AdornedPredicate> adornedPredicates, const AstRelationIdentifier& atomName,$/;"	f	namespace:souffle
contains	MagicSet.cpp	/^bool contains(std::set<T> set, T element) {$/;"	f	namespace:souffle
contains	TypeSystem.h	/^    bool contains(const Type& type) const {$/;"	f	struct:souffle::TypeSet
contains	UnionFind.h	/^    inline bool contains(SparseDomain v1, SparseDomain v2) {$/;"	f	class:souffle::SparseDisjointSet
contains	Util.h	/^bool contains(const C& container, const typename C::value_type& element) {$/;"	f	namespace:souffle
containsAggregators	MagicSet.cpp	/^bool containsAggregators(AstClause* clause) {$/;"	f	namespace:souffle
containsElement	EquivalenceRelation.h	/^    bool containsElement(value_type e) const {$/;"	f	class:souffle::EquivalenceRelation
containsInlinedAtom	InlineRelationsTransformer.cpp	/^bool containsInlinedAtom(const AstProgram& program, const AstClause& clause) {$/;"	f	namespace:souffle
contains_full_index	CompiledIndexUtils.h	/^struct contains_full_index<arity, First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
contains_full_index	CompiledIndexUtils.h	/^struct contains_full_index<arity> {$/;"	s	namespace:souffle::ram::index_utils
contains_internal	Brie.h	/^    bool contains_internal(const Tuple& tuple, op_context& ctxt) const {$/;"	f	class:souffle::Trie
contains_internal	Brie.h	/^    bool contains_internal(const Tuple&, op_context&) const {$/;"	f	class:souffle::Trie
context	CompiledSouffle.h	/^    struct context {};$/;"	s	class:souffle::t_nullaries
convert	souffle2bdd.cpp	/^    void convert(std::ostream& out, const AstTranslationUnit& tu) {$/;"	f	class:souffle::BddBddBTranslator
convert	souffle2lb.cpp	/^    void convert(std::ostream& out, const AstTranslationUnit& tu) {$/;"	f	class:souffle::LogicbloxConverter
convertExistenceChecks	RamTransforms.cpp	/^bool ConvertExistenceChecksTransformer::convertExistenceChecks(RamProgram& program) {$/;"	f	class:souffle::ConvertExistenceChecksTransformer
convertRamIdent	Synthesiser.cpp	/^const std::string Synthesiser::convertRamIdent(const std::string& name) {$/;"	f	class:souffle::Synthesiser
convertTypeName	souffle2lb.cpp	/^    AstTypeIdentifier convertTypeName(const AstTypeIdentifier& name) {$/;"	f	class:souffle::LogicbloxConverter	file:
copy	parser.hh	/^    copy (const self_type& that)$/;"	f	class:yy::parser::semantic_type
copyBaseComponents	AstComponent.h	/^    void copyBaseComponents(const AstComponent* other) {$/;"	f	class:souffle::AstComponent
count	AstArgument.h	/^    enum Op { min, max, count, sum };$/;"	e	enum:souffle::AstAggregator::Op
count	RamStatement.h	/^    const size_t count;$/;"	m	class:souffle::RamWait
count	Table.h	/^    std::size_t count = 0;$/;"	m	class:souffle::Table
count	test/compiled_relation_test.cpp	/^int count(const C& c) {$/;"	f	namespace:souffle::ram
count	test/table_test.cpp	/^int count(const C& c) {$/;"	f	namespace:souffle::test
countEntries	BTree.h	/^        size_type countEntries() const {$/;"	f	struct:souffle::detail::btree::node
countNodes	BTree.h	/^        size_type countNodes() const {$/;"	f	struct:souffle::detail::btree::node
counter	Interpreter.h	/^    int counter;$/;"	m	class:souffle::Interpreter
counter	Interpreter.h	/^   int counter;$/;"	m	class:souffle::LowLevelMachine
covered	CompiledRelation.h	/^    struct covered {$/;"	s	class:souffle::ram::detail::AutoRelation
covers	BTree.h	/^    bool covers(const node* node, const Key& k) const {$/;"	f	class:souffle::detail::btree
covers	CompiledIndexUtils.h	/^    struct covers {$/;"	s	struct:souffle::ram::index
covers	InterpreterIndex.h	/^    bool covers(unsigned char column) const {$/;"	f	class:souffle::InterpreterIndexOrder
coversUpperBound	BTree.h	/^    bool coversUpperBound(const node* node, const Key& k) const {$/;"	f	class:souffle::detail::btree
cpu_relax	ParallelUtils.h	/^#define cpu_relax(/;"	d
createAdornedIdentifier	MagicSet.cpp	/^AstRelationIdentifier createAdornedIdentifier($/;"	f	namespace:souffle
createAnnotatedClause	AstTypeAnalysis.cpp	/^AstClause* createAnnotatedClause($/;"	f	namespace:souffle
createCondition	AstTranslator.cpp	/^std::unique_ptr<RamCondition> AstTranslator::ClauseTranslator::createCondition($/;"	f	class:souffle::AstTranslator::ClauseTranslator
createCondition	AstTranslator.cpp	/^std::unique_ptr<RamCondition> AstTranslator::ProvenanceClauseTranslator::createCondition($/;"	f	class:souffle::AstTranslator::ProvenanceClauseTranslator
createContext	CompiledRelation.h	/^    operation_context createContext() {$/;"	f	class:souffle::ram::detail::AutoRelation
createContext	CompiledRelation.h	/^    operation_context createContext() {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
createContext	CompiledRelation.h	/^    operation_context createContext() {$/;"	f	class:souffle::ram::detail::GenericRelation
createContext	CompiledRelation.h	/^    operation_context createContext() {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
createContext	CompiledSouffle.h	/^    context createContext() {$/;"	f	class:souffle::t_nullaries
createID	profile/Relation.h	/^    std::string createID() {$/;"	f	class:souffle::profile::Relation
createId	profile/Reader.h	/^    std::string createId() {$/;"	f	class:souffle::profile::Reader
createIndices	RamTransforms.cpp	/^bool CreateIndicesTransformer::createIndices(RamProgram& program) {$/;"	f	class:souffle::CreateIndicesTransformer
createMagicIdentifier	MagicSet.cpp	/^AstRelationIdentifier createMagicIdentifier(const AstRelationIdentifier& relationName, size_t outputNumber) {$/;"	f	namespace:souffle
createMagicRelation	MagicSet.cpp	/^AstRelation* createMagicRelation(AstRelation* original, const AstRelationIdentifier& magicPredName) {$/;"	f	namespace:souffle
createNewRelation	MagicSet.cpp	/^AstRelation* createNewRelation(AstRelation* original, const AstRelationIdentifier& newName) {$/;"	f	namespace:souffle
createNode	PiggyList.h	/^    size_t createNode() {$/;"	f	class:souffle::PiggyList
createNumericType	TypeSystem.h	/^    PrimitiveType& createNumericType(const identifier& name) {$/;"	f	class:souffle::TypeEnvironment
createOperation	AstTranslator.cpp	/^std::unique_ptr<RamOperation> AstTranslator::ClauseTranslator::createOperation(const AstClause& clause) {$/;"	f	class:souffle::AstTranslator::ClauseTranslator
createOperation	AstTranslator.cpp	/^std::unique_ptr<RamOperation> AstTranslator::ProvenanceClauseTranslator::createOperation($/;"	f	class:souffle::AstTranslator::ProvenanceClauseTranslator
createRecID	profile/Relation.h	/^    std::string createRecID(std::string name) {$/;"	f	class:souffle::profile::Relation
createRecordType	TypeSystem.h	/^    RecordType& createRecordType(const identifier& name) {$/;"	f	class:souffle::TypeEnvironment
createRelation	Interpreter.h	/^    void createRelation(const RamRelation& id) {$/;"	f	class:souffle::Interpreter
createRelationReference	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::createRelationReference($/;"	f	class:souffle::AstTranslator
createRelationReference	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::createRelationReference(const std::string name,$/;"	f	class:souffle::AstTranslator
createRelationTable	WriteStreamSQLite.h	/^    void createRelationTable() {$/;"	f	class:souffle::WriteStreamSQLite
createRelationView	WriteStreamSQLite.h	/^    void createRelationView() {$/;"	f	class:souffle::WriteStreamSQLite
createSubIdentifier	MagicSet.cpp	/^AstRelationIdentifier createSubIdentifier($/;"	f	namespace:souffle
createSymbolTable	WriteStreamSQLite.h	/^    void createSymbolTable() {$/;"	f	class:souffle::WriteStreamSQLite
createSymbolType	TypeSystem.h	/^    PrimitiveType& createSymbolType(const identifier& name) {$/;"	f	class:souffle::TypeEnvironment
createTables	WriteStreamSQLite.h	/^    void createTables() {$/;"	f	class:souffle::WriteStreamSQLite
createType	TypeSystem.h	/^    T& createType(const identifier& name, const Args&... args) {$/;"	f	class:souffle::TypeEnvironment
createUnionType	TypeSystem.h	/^    UnionType& createUnionType(const identifier& name) {$/;"	f	class:souffle::TypeEnvironment
createValueIndex	AstTranslator.cpp	/^void AstTranslator::ClauseTranslator::createValueIndex(const AstClause& clause) {$/;"	f	class:souffle::AstTranslator::ClauseTranslator
cssChartist	profile/htmlCssChartist.h	/^std::string cssChartist = R"___($/;"	m	namespace:souffle::profile::html
cssStyle	profile/htmlCssStyle.h	/^std::string cssStyle = R"___($/;"	m	namespace:souffle::profile::html
ctxt	CompiledIndexUtils.h	/^        typename index_t::operation_hints ctxt;$/;"	m	struct:souffle::ram::index_utils::Indices::operation_context
ctxt	Interpreter.h	/^    InterpreterContext ctxt = InterpreterContext(100);   \/\/TODO $/;"	m	class:souffle::LowLevelMachine
cur	BTree.h	/^        node const* cur;$/;"	m	class:souffle::detail::btree::iterator
currentAddressLabel	Interpreter.h	/^       size_t currentAddressLabel = 0;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
current_char	profile/UserInputReader.h	/^    char current_char = 0;$/;"	m	class:souffle::profile::InputReader
current_hist_val	profile/UserInputReader.h	/^    std::string current_hist_val;$/;"	m	class:souffle::profile::InputReader
current_tab_completes	profile/UserInputReader.h	/^    std::vector<std::string> current_tab_completes;$/;"	m	class:souffle::profile::InputReader
current_tab_val	profile/UserInputReader.h	/^    std::string current_tab_val;$/;"	m	class:souffle::profile::InputReader
cursor_pos	profile/UserInputReader.h	/^    size_t cursor_pos = 0;$/;"	m	class:souffle::profile::InputReader
d	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
data	CompiledTuple.h	/^    Domain data[arity];$/;"	m	struct:souffle::ram::Tuple
data	Constraints.h	/^    data_type data;$/;"	m	class:souffle::Assignment
data	Global.h	/^    const std::map<K, V>& data() const {$/;"	f	class:souffle::BaseTable
data	Global.h	/^    void data(const std::map<K, V>& otherData) {$/;"	f	class:souffle::BaseTable
data	IndexSetAnalysis.h	/^    std::map<std::string, IndexSet> data;$/;"	m	class:souffle::IndexSetAnalysis
data	InterpreterContext.h	/^    std::vector<const RamDomain*> data;$/;"	m	class:souffle::InterpreterContext
data	SouffleInterface.h	/^    const RamDomain* data = nullptr;$/;"	m	class:souffle::tuple
data	Table.h	/^        T data[blockSize];$/;"	m	struct:souffle::Table::Block
dataStructure	SynthesiserRelation.h	/^    std::string dataStructure;$/;"	m	class:souffle::SynthesiserRelation
database	ProfileEvent.h	/^    profile::ProfileDatabase database;$/;"	m	class:souffle::ProfileEventSingleton
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datatype	Mpi.h	/^inline const MPI_Datatype datatype() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<char>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<double>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<float>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<int>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<long double>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<long long>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<long>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<short>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<unsigned char>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<unsigned long long>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<unsigned long>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<unsigned short>() {$/;"	f	namespace:souffle::mpi::__anon53
datatype	Mpi.h	/^inline const MPI_Datatype datatype<unsigned>() {$/;"	f	namespace:souffle::mpi::__anon53
db	ReadStreamSQLite.h	/^    sqlite3* db = nullptr;$/;"	m	class:souffle::ReadStreamSQLite
db	WriteStreamSQLite.h	/^    sqlite3* db = nullptr;$/;"	m	class:souffle::WriteStreamSQLite
db	profile/Reader.h	/^    const ProfileDatabase& db = ProfileEventSingleton::instance().getDB();$/;"	m	class:souffle::profile::Reader
dbFilename	ReadStreamSQLite.h	/^    const std::string& dbFilename;$/;"	m	class:souffle::ReadStreamSQLite
dbFilename	WriteStreamSQLite.h	/^    const std::string& dbFilename;$/;"	m	class:souffle::WriteStreamSQLite
dbSymbolTable	WriteStreamSQLite.h	/^    std::unordered_map<uint64_t, uint64_t> dbSymbolTable;$/;"	m	class:souffle::WriteStreamSQLite
debugReport	AstTranslationUnit.h	/^    DebugReport& debugReport;$/;"	m	class:souffle::AstTranslationUnit
debugReport	RamTranslationUnit.h	/^    DebugReport& debugReport;$/;"	m	class:souffle::RamTranslationUnit
debug_level	parser.cc	/^  parser::debug_level () const$/;"	f	class:yy::parser
debug_level_type	parser.hh	/^    typedef int debug_level_type;$/;"	t	class:yy::parser
debug_stream	parser.cc	/^  parser::debug_stream () const$/;"	f	class:yy::parser
decltype	CompiledIndexUtils.h	/^        auto getForIndex(const Index& i) -> decltype(nested.getForIndex(i)) {$/;"	f	struct:souffle::ram::index_utils::Indices::operation_context
decltype	CompiledIndexUtils.h	/^    auto getIndex(const Index& i) -> decltype(nested.getIndex(i)) {$/;"	f	class:souffle::ram::index_utils::Indices
decltype	CompiledIndexUtils.h	/^    auto getIndex(const Index& i) const -> decltype(nested.getIndex(i)) {$/;"	f	class:souffle::ram::index_utils::Indices
decltype	CompiledIndexUtils.h	/^    auto partition(const I& index) const -> decltype(nested.partition(index)) {$/;"	f	class:souffle::ram::index_utils::Indices
decltype	CompiledIndexUtils.h	/^    auto scan(const Index& i) const -> decltype(nested.scan(i)) {$/;"	f	class:souffle::ram::index_utils::Indices
decltype	CompiledRelation.h	/^            -> decltype(indices.template equal_range<I>(value)) {$/;"	f	class:souffle::ram::detail::GenericRelation
decltype	CompiledRelation.h	/^            -> decltype(indices.template equal_range<index<Columns...>>(value)) {$/;"	f	class:souffle::ram::detail::GenericRelation
decltype	CompiledRelation.h	/^            -> decltype(this->equalRangeInternal<I>(value, ctxt)) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
decltype	CompiledRelation.h	/^            -> decltype(this->equalRangeInternal<I>(value, std::declval<operation_context&>())) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
decltype	CompiledRelation.h	/^            -> decltype(this->equalRangeInternal<index<Columns...>>(value, ctxt)) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
decltype	CompiledRelation.h	/^            -> decltype(this->template equalRange<index<Columns...>>(value)) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	CompiledRelation.h	/^            -> decltype(this->template equalRange<index<Columns...>>(value, ctxt)) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	CompiledRelation.h	/^    auto begin() const -> decltype(indices.getIndex(primary_index()).begin()) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	CompiledRelation.h	/^    auto end() const -> decltype(indices.getIndex(primary_index()).end()) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	CompiledRelation.h	/^    auto equalRange(const tuple_type& value) const -> decltype($/;"	f	class:souffle::ram::detail::SingleIndexRelation
decltype	CompiledRelation.h	/^    auto equalRange(const tuple_type& value) const -> decltype(indices.template equal_range<I>(value)) {$/;"	f	class:souffle::ram::detail::GenericRelation
decltype	CompiledRelation.h	/^    auto partition() -> decltype(indices.partition(primary_index())) {$/;"	f	class:souffle::ram::detail::AutoRelation
decltype	CompiledRelation.h	/^    auto partition() -> decltype(indices.partition(primary_index())) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	CompiledRelation.h	/^    auto scan() const -> decltype(indices.scan(Index())) {$/;"	f	class:souffle::ram::detail::AutoRelation
decltype	CompiledRelation.h	/^    auto scan() const -> decltype(indices.scan(Index())) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
decltype	SouffleInterface.h	/^    decltype(array)::iterator begin() {$/;"	f	class:souffle::tuple
default_bottom_factory	Constraints.h	/^struct default_bottom_factory {$/;"	s	namespace:souffle::detail
default_factory	Brie.h	/^struct default_factory {$/;"	s	namespace:souffle::detail
default_meet_op	Constraints.h	/^struct default_meet_op {$/;"	s	namespace:souffle::detail
default_merge	Brie.h	/^struct default_merge {$/;"	s	namespace:souffle::detail
default_strategy	BTree.h	/^struct default_strategy : public binary {};$/;"	s	namespace:souffle::detail
default_strategy	BTree.h	/^struct default_strategy<int> : public linear {};$/;"	s	namespace:souffle::detail
default_strategy	BTree.h	/^struct default_strategy<std::tuple<Ts...>> : public linear {};$/;"	s	namespace:souffle::detail
delimiter	ReadStreamCSV.h	/^    const std::string delimiter;$/;"	m	class:souffle::ReadStreamCSV
delimiter	WriteStreamCSV.h	/^    const std::string delimiter;$/;"	m	class:souffle::WriteCoutCSV
delimiter	WriteStreamCSV.h	/^    const std::string delimiter;$/;"	m	class:souffle::WriteFileCSV
delimiter	WriteStreamCSV.h	/^    const std::string delimiter;$/;"	m	class:souffle::WriteGZipFileCSV
denseToSparseMap	UnionFind.h	/^    DenseMap denseToSparseMap;$/;"	m	class:souffle::SparseDisjointSet
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
depthAnalyzer	Interpreter.h	/^       RamOperationDepthAnalysis depthAnalyzer;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
depthLimit	Explain.h	/^    int depthLimit;$/;"	m	class:souffle::Explain
deref	Util.h	/^struct deref {$/;"	s	namespace:souffle
derefIter	IterUtils.h	/^IterDerefWrapper<Iter> derefIter(const Iter& iter) {$/;"	f	namespace:souffle
deref_compare	CompiledIndexUtils.h	/^struct deref_compare {$/;"	s	namespace:souffle::ram::index_utils
description	Global.h	/^    std::string description; \/* The description of what this option does, used in the help text produced$/;"	m	struct:souffle::MainOption
desiredNumKeys	BTree.h	/^            desiredNumKeys = ((blockSize > sizeof(base)) ? blockSize - sizeof(base) : 0) \/ sizeof(Key),$/;"	e	enum:souffle::detail::btree::node::__anon69
destinationStrata	RamStatement.h	/^    const std::set<size_t> destinationStrata;$/;"	m	class:souffle::RamSend
destroy	parser.hh	/^    destroy ()$/;"	f	class:yy::parser::semantic_type
detail	AstNode.h	/^namespace detail {$/;"	n	namespace:souffle
detail	AstVisitor.h	/^namespace detail {$/;"	n	namespace:souffle
detail	BTree.h	/^namespace detail {$/;"	n	namespace:souffle
detail	Brie.h	/^namespace detail {$/;"	n	namespace:souffle
detail	CompiledIndexUtils.h	/^namespace detail {$/;"	n	namespace:souffle::ram::index_utils
detail	CompiledRecord.h	/^namespace detail {$/;"	n	namespace:souffle
detail	CompiledRelation.h	/^namespace detail {$/;"	n	namespace:souffle::ram
detail	Constraints.h	/^namespace detail {$/;"	n	namespace:souffle
detail	LambdaBTree.h	/^namespace detail {$/;"	n	namespace:souffle
detail	ParallelUtils.h	/^namespace detail {$/;"	n	namespace:souffle
detail	RamNode.h	/^namespace detail {$/;"	n	namespace:souffle
detail	RamVisitor.h	/^namespace detail {$/;"	n	namespace:souffle
detail	Util.h	/^namespace detail {$/;"	n	namespace:souffle
dfSearch	IndexSetAnalysis.cpp	/^bool MaxMatching::dfSearch(SearchColumns u) {$/;"	f	class:souffle::MaxMatching
diagnostics	ErrorReport.h	/^    std::set<Diagnostic> diagnostics;$/;"	m	class:souffle::ErrorReport
direct_index_factory	CompiledIndexUtils.h	/^struct direct_index_factory<T, Index, true> {$/;"	s	namespace:souffle::ram::index_utils
directives	IODirectives.h	/^    std::map<std::string, std::string> directives;$/;"	m	class:souffle::IODirectives
disjunct	AstParserUtils.cpp	/^void RuleBody::disjunct(RuleBody&& other) {$/;"	f	class:souffle::RuleBody
dist_bin_SCRIPTS	Makefile	/^dist_bin_SCRIPTS = souffle-compile souffle-config$/;"	m
distance	IndexSetAnalysis.h	/^    Distance distance;$/;"	m	class:souffle::MaxMatching
djSetList	EquivalenceRelation.h	/^        StatesBucket djSetList;$/;"	m	class:souffle::EquivalenceRelation::iterator
djSetMapListEnd	EquivalenceRelation.h	/^        typename StatesMap::iterator djSetMapListEnd;$/;"	m	class:souffle::EquivalenceRelation::iterator
djSetMapListIt	EquivalenceRelation.h	/^        typename StatesMap::iterator djSetMapListIt;$/;"	m	class:souffle::EquivalenceRelation::iterator
dll	Interpreter.h	/^    void* dll;$/;"	m	class:souffle::Interpreter
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE_TARNAME}$/;"	m
document	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile
dout	souffle2lb.cpp	/^    std::ostream& dout;$/;"	m	class:souffle::LogicbloxConverter	file:
downgrade_to_read	ParallelUtils.h	/^    void downgrade_to_read() {$/;"	f	class:souffle::ReadWriteLock
downgrade_to_read	ParallelUtils.h	/^    void downgrade_to_read() {}$/;"	f	class:souffle::souffle::ReadWriteLock
driver	parser.hh	/^    ParserDriver &driver;$/;"	m	class:yy::parser
dropRelation	Interpreter.h	/^    void dropRelation(const RamRelation& id) {$/;"	f	class:souffle::Interpreter
dropRelation	Interpreter.h	/^    void dropRelation(const std::string& relName) {$/;"	f	class:souffle::LowLevelMachine
ds	UnionFind.h	/^    DisjointSet ds;$/;"	m	class:souffle::SparseDisjointSet
ds	UnionFind.h	/^    DisjointSet& operator=(DisjointSet& ds) = delete;$/;"	m	class:souffle::DisjointSet
ds	UnionFind.h	/^    DisjointSet& operator=(DisjointSet&& ds) = delete;$/;"	m	class:souffle::DisjointSet
dummy1	parser.hh	/^      char dummy1[sizeof (AstArgument *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy10	parser.hh	/^      char dummy10[sizeof (AstFunctorDeclaration *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy11	parser.hh	/^      char dummy11[sizeof (AstIO *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy12	parser.hh	/^      char dummy12[sizeof (AstPragma *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy13	parser.hh	/^      char dummy13[sizeof (AstRecordInit *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy14	parser.hh	/^      char dummy14[sizeof (AstRecordType *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy15	parser.hh	/^      char dummy15[sizeof (AstRelation *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy16	parser.hh	/^      char dummy16[sizeof (AstRelationIdentifier *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy17	parser.hh	/^      char dummy17[sizeof (AstType *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy18	parser.hh	/^      char dummy18[sizeof (AstTypeIdentifier *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy19	parser.hh	/^      char dummy19[sizeof (AstUnionType *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy2	parser.hh	/^      char dummy2[sizeof (AstAtom *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy20	parser.hh	/^      char dummy20[sizeof (AstUserDefinedFunctor *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy21	parser.hh	/^      char dummy21[sizeof (RuleBody *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy22	parser.hh	/^      char dummy22[sizeof (std::string)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy23	parser.hh	/^      char dummy23[sizeof (std::vector<AstAtom*>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy24	parser.hh	/^      char dummy24[sizeof (std::vector<AstClause*>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy25	parser.hh	/^      char dummy25[sizeof (std::vector<AstIO *>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy26	parser.hh	/^      char dummy26[sizeof (std::vector<AstLoad *>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy27	parser.hh	/^      char dummy27[sizeof (std::vector<AstRelation *>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy28	parser.hh	/^      char dummy28[sizeof (std::vector<AstStore *>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy29	parser.hh	/^      char dummy29[sizeof (std::vector<AstTypeIdentifier>)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy3	parser.hh	/^      char dummy3[sizeof (AstClause *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy30	parser.hh	/^      char dummy30[sizeof (uint32_t)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy4	parser.hh	/^      char dummy4[sizeof (AstComponent *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy5	parser.hh	/^      char dummy5[sizeof (AstComponentInit *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy6	parser.hh	/^      char dummy6[sizeof (AstComponentType *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy7	parser.hh	/^      char dummy7[sizeof (AstDomain)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy8	parser.hh	/^      char dummy8[sizeof (AstExecutionOrder *)];$/;"	m	union:yy::parser::semantic_type::union_type
dummy9	parser.hh	/^      char dummy9[sizeof (AstExecutionPlan *)];$/;"	m	union:yy::parser::semantic_type::union_type
dump	Brie.h	/^    void dump(bool detail = false, std::ostream& out = std::cout) const {$/;"	f	class:souffle::SparseArray
dump	Brie.h	/^    void dump(bool detail = false, std::ostream& out = std::cout) const {$/;"	f	class:souffle::SparseBitMap
dump	Brie.h	/^    void dump(bool detailed, std::ostream& out, const Node& node, int level, index_type offset,$/;"	f	class:souffle::SparseArray
dump	ProfileEvent.h	/^    void dump() {$/;"	f	class:souffle::ProfileEventSingleton
dump	json11.h	/^    std::string dump() const {$/;"	f	class:json11::final
dump	json11.h	/^inline void Json::dump(string& out) const {$/;"	f	class:json11::Json
dump	json11.h	/^static void dump(NullStruct, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(bool value, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(const Json::array& values, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(const Json::object& values, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(const string& value, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(double value, string& out) {$/;"	f	namespace:json11
dump	json11.h	/^static void dump(long long value, string& out) {$/;"	f	namespace:json11
duration	test/btree_multiset_test.cpp	/^long duration(const time_point& start, const time_point& end) {$/;"	f	namespace:souffle::test
duration	test/btree_set_test.cpp	/^long duration(const time_point& start, const time_point& end) {$/;"	f	namespace:souffle::test
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
e	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	f	namespace:souffle::profile
element	AstTranslator.h	/^        int element;$/;"	m	struct:souffle::AstTranslator::Location
element	RamExpression.h	/^    const size_t element;$/;"	m	class:souffle::RamElementAccess
elementTypes	TypeSystem.h	/^    std::vector<const Type*> elementTypes;$/;"	m	class:souffle::UnionType
emitCode	Synthesiser.cpp	/^void Synthesiser::emitCode(std::ostream& out, const RamStatement& stmt) {$/;"	f	class:souffle::Synthesiser
emplace	parser.hh	/^    emplace ()$/;"	f	class:yy::parser::semantic_type
emplace	parser.hh	/^    emplace (U&&... u)$/;"	f	class:yy::parser::semantic_type
emplace	parser.hh	/^    emplace (const T& t)$/;"	f	class:yy::parser::semantic_type
empty	AstClause.h	/^    bool empty() const {$/;"	f	class:souffle::AstExecutionPlan
empty	AstType.h	/^    bool empty() const {$/;"	f	class:souffle::AstTypeIdentifier
empty	BTree.h	/^    bool empty() const {$/;"	f	class:souffle::detail::btree
empty	Brie.h	/^    bool empty() const {$/;"	f	class:souffle::SparseArray
empty	Brie.h	/^    bool empty() const {$/;"	f	class:souffle::SparseBitMap
empty	Brie.h	/^    bool empty() const {$/;"	f	class:souffle::Trie
empty	CompiledIndexUtils.h	/^    bool empty() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
empty	CompiledIndexUtils.h	/^    bool empty() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
empty	CompiledIndexUtils.h	/^    bool empty() const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
empty	CompiledIndexUtils.h	/^    bool empty() const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
empty	CompiledRelation.h	/^    bool empty() const {$/;"	f	class:souffle::ram::detail::AutoRelation
empty	CompiledRelation.h	/^    bool empty() const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
empty	CompiledRelation.h	/^    bool empty() const {$/;"	f	class:souffle::ram::detail::GenericRelation
empty	CompiledRelation.h	/^    bool empty() const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
empty	CompiledRelation.h	/^    bool empty() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
empty	CompiledSouffle.h	/^    bool empty() const {$/;"	f	class:souffle::t_nullaries
empty	DebugReport.h	/^    bool empty() const {$/;"	f	class:souffle::DebugReport
empty	InterpreterRelation.h	/^    bool empty() const {$/;"	f	class:souffle::InterpreterRelation
empty	Table.h	/^    bool empty() const {$/;"	f	class:souffle::Table
empty	TypeSystem.h	/^    bool empty() const {$/;"	f	struct:souffle::TypeSet
empty	Util.h	/^    bool empty() const {$/;"	f	struct:souffle::range
emptyPartition	EquivalenceRelation.h	/^    void emptyPartition() const {$/;"	f	class:souffle::EquivalenceRelation
empty_state	parser.hh	/^      enum { empty_state = -1 };$/;"	e	enum:yy::parser::by_state::__anon10
empty_symbol	parser.hh	/^    enum { empty_symbol = -2 };$/;"	e	enum:yy::parser::__anon9
enableLogging	SignalHandler.h	/^    void enableLogging() {$/;"	f	class:souffle::SignalHandler
enclosingComponent	ComponentModel.h	/^    std::map<const AstComponent*, const AstComponent*> enclosingComponent;$/;"	m	class:souffle::ComponentLookup
encode_utf8	json11.h	/^    void encode_utf8(long pt, string& out) {$/;"	f	struct:json11::__anon66::final
end	AstClause.h	/^    const_iterator end() const {$/;"	f	class:souffle::AstExecutionOrder
end	BTree.h	/^    iterator end() const {$/;"	f	class:souffle::detail::btree
end	Brie.h	/^        bool end;$/;"	m	class:souffle::Trie::iterator_core
end	Brie.h	/^    iterator end() const {$/;"	f	class:souffle::SparseArray
end	Brie.h	/^    iterator end() const {$/;"	f	class:souffle::SparseBitMap
end	Brie.h	/^    iterator end() const {$/;"	f	class:souffle::Trie
end	CompiledIndexUtils.h	/^    Iter end;$/;"	m	class:souffle::ram::iterator_utils::filter_iterator
end	CompiledIndexUtils.h	/^    iterator end() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
end	CompiledIndexUtils.h	/^    iterator end() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
end	CompiledIndexUtils.h	/^    iterator end() const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
end	CompiledIndexUtils.h	/^    iterator end() const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
end	CompiledRelation.h	/^    iterator end() const {$/;"	f	class:souffle::ram::detail::AutoRelation
end	CompiledRelation.h	/^    iterator end() const {$/;"	f	class:souffle::ram::detail::GenericRelation
end	CompiledRelation.h	/^    iterator end() const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
end	CompiledRelation.h	/^    iterator end() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
end	CompiledSouffle.h	/^    iterator end() const {$/;"	f	class:souffle::t_nullaries
end	Constraints.h	/^    iterator end() const {$/;"	f	class:souffle::Assignment
end	EquivalenceRelation.h	/^    iterator end() const {$/;"	f	class:souffle::EquivalenceRelation
end	InterpreterRelation.h	/^    inline iterator end() const {$/;"	f	class:souffle::InterpreterRelation
end	IterUtils.h	/^    bool end = true;$/;"	m	class:souffle::SingleValueIterator
end	PiggyList.h	/^    iterator end() {$/;"	f	class:souffle::PiggyList
end	ProfileDatabase.h	/^    microseconds end;$/;"	m	class:souffle::profile::DurationEntry
end	SrcLocation.h	/^    Point end = {};$/;"	m	class:souffle::SrcLocation
end	Table.h	/^    iterator end() const {$/;"	f	class:souffle::Table
end	TypeSystem.h	/^    const_iterator end() const {$/;"	f	struct:souffle::TypeSet
end	Util.h	/^    Iter end;$/;"	m	class:souffle::detail::joined_sequence
end	Util.h	/^    Iter& end() {$/;"	f	struct:souffle::range
end	Util.h	/^    const Iter& end() const {$/;"	f	struct:souffle::range
end_read	ParallelUtils.h	/^    bool end_read(const Lease& \/*lease*\/) {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
end_read	ParallelUtils.h	/^    bool end_read(const Lease& lease) {$/;"	f	class:souffle::OptimisticReadWriteLock
end_read	ParallelUtils.h	/^    void end_read() {$/;"	f	class:souffle::ReadWriteLock
end_read	ParallelUtils.h	/^    void end_read() {}$/;"	f	class:souffle::souffle::ReadWriteLock
end_write	ParallelUtils.h	/^    void end_write() {$/;"	f	class:souffle::OptimisticReadWriteLock
end_write	ParallelUtils.h	/^    void end_write() {$/;"	f	class:souffle::ReadWriteLock
end_write	ParallelUtils.h	/^    void end_write() {}$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
end_write	ParallelUtils.h	/^    void end_write() {}$/;"	f	class:souffle::souffle::ReadWriteLock
entries	ProfileDatabase.h	/^    std::map<std::string, std::unique_ptr<Entry>> entries;$/;"	m	class:souffle::profile::DirectoryEntry
env	AstTypeEnvironmentAnalysis.h	/^    TypeEnvironment env;$/;"	m	class:souffle::TypeEnvironmentAnalysis
environment	Interpreter.h	/^    relation_map environment;$/;"	m	class:souffle::Interpreter
environment	Interpreter.h	/^   relation_map environment;$/;"	m	class:souffle::LowLevelMachine
environment	TypeSystem.h	/^    const TypeEnvironment& environment;$/;"	m	class:souffle::Type
eout	souffle2lb.cpp	/^    std::ostream& eout;$/;"	m	class:souffle::LogicbloxConverter	file:
eqrel_index_factory	CompiledRelation.h	/^    struct eqrel_index_factory {$/;"	s	struct:souffle::ram::EqRel
equal	AstParserUtils.cpp	/^bool RuleBody::equal(const clause& a, const clause& b) {$/;"	f	class:souffle::RuleBody
equal	AstParserUtils.cpp	/^bool RuleBody::equal(const literal& a, const literal& b) {$/;"	f	class:souffle::RuleBody
equal	BTree.h	/^    bool equal(const Key& a, const Key& b) const {$/;"	f	class:souffle::detail::btree
equal	BTree.h	/^    bool equal(const T& a, const T& b) const {$/;"	f	struct:souffle::detail::comparator
equal	CompiledIndexUtils.h	/^    bool equal(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::comparator
equal	CompiledIndexUtils.h	/^    bool equal(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::deref_compare
equal	InterpreterIndex.h	/^        bool equal(const RamDomain* x, const RamDomain* y) const {$/;"	f	struct:souffle::InterpreterIndex::comparator
equal	UnionFind.h	/^    bool equal(const StorePair& a, const StorePair& b) {$/;"	f	struct:souffle::EqrelMapComparator
equal	Util.h	/^bool equal(const std::set<T>& a, const std::set<T>& b, const Comp& comp = Comp()) {$/;"	f	namespace:souffle
equal	Util.h	/^bool equal(const std::vector<T>& a, const std::vector<T>& b, const Comp& comp = Comp()) {$/;"	f	namespace:souffle
equalRange	CompiledIndexUtils.h	/^    equalRange(const T& tuple, operation_context& c) const {$/;"	f	class:souffle::ram::index_utils::Indices
equalRange	CompiledIndexUtils.h	/^    range<iterator> equalRange(const T&, const Index&, operation_context&) const {$/;"	f	class:souffle::ram::index_utils::Indices
equalRange	CompiledIndexUtils.h	/^    range<iterator> equalRange(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
equalRange	CompiledIndexUtils.h	/^    range<iterator> equalRange(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
equalRange	CompiledIndexUtils.h	/^    range<iterator> equalRange(const tuple_type& tuple, operation_hints& ctxt) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
equalRange	CompiledIndexUtils.h	/^    range<iterator> equalRange(const tuple_type& tuple, operation_hints& ctxt) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
equalRange	CompiledRelation.h	/^    range<iterator> equalRange(const tuple_type& value) const {$/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	CompiledRelation.h	/^    range<iterator> equalRange(const tuple_type& value, Context& ctxt) const {$/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	CompiledRelation.h	/^    range<iterator> equalRange(const tuple_type& value, operation_context& ctxt) const {$/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	CompiledRelation.h	/^    range<typename indices_t::template iter_type<Index>::type> equalRange($/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	CompiledRelation.h	/^    range<typename indices_t::template iter_type<Index>::type> equalRange($/;"	f	class:souffle::ram::detail::DirectIndexedRelation
equalRange	CompiledRelation.h	/^    range<typename indices_t::template iter_type<Index>::type> equalRange(const tuple_type& value) const {$/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	CompiledRelation.h	/^    range<typename indices_t::template iter_type<Index>::type> equalRange(const tuple_type& value) const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
equalRange	CompiledRelation.h	/^    range<typename indices_t::template iter_type<index<Columns...>>::type> equalRange($/;"	f	class:souffle::ram::detail::AutoRelation
equalRange	InterpreterIndex.h	/^    inline std::pair<iterator, iterator> equalRange(const RamDomain* value) const {$/;"	f	class:souffle::InterpreterIndex
equalRangeInternal	CompiledRelation.h	/^    equalRangeInternal(const tuple_type& value, operation_context& ctxt) const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
equalRangeInternal	CompiledRelation.h	/^    equalRangeInternal(const tuple_type& value, operation_context&) const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
equal_ptr	Util.h	/^bool equal_ptr(const T* a, const T* b) {$/;"	f	namespace:souffle
equal_ptr	Util.h	/^bool equal_ptr(const std::unique_ptr<T>& a, const std::unique_ptr<T>& b) {$/;"	f	namespace:souffle
equal_range	CompiledRelation.h	/^    equal_range(const tuple_type& t) const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
equal_range	CompiledRelation.h	/^    range<tuple_type*> equal_range(const tuple_type&) const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
equal_range	CompiledRelation.h	/^    void equal_range(const tuple_type&) const {}$/;"	f	class:souffle::ram::detail::GenericRelationGroup
equal_targets	Util.h	/^bool equal_targets(const std::set<T*>& a, const std::set<T*>& b) {$/;"	f	namespace:souffle
equal_targets	Util.h	/^bool equal_targets(const std::set<std::shared_ptr<T>>& a, const std::set<std::shared_ptr<T>>& b) {$/;"	f	namespace:souffle
equal_targets	Util.h	/^bool equal_targets(const std::set<std::unique_ptr<T>>& a, const std::set<std::unique_ptr<T>>& b) {$/;"	f	namespace:souffle
equal_targets	Util.h	/^bool equal_targets(const std::vector<T*>& a, const std::vector<T*>& b) {$/;"	f	namespace:souffle
equal_targets	Util.h	/^bool equal_targets(const std::vector<std::shared_ptr<T>>& a, const std::vector<std::shared_ptr<T>>& b) {$/;"	f	namespace:souffle
equal_targets	Util.h	/^bool equal_targets(const std::vector<std::unique_ptr<T>>& a, const std::vector<std::unique_ptr<T>>& b) {$/;"	f	namespace:souffle
equivalencePartition	EquivalenceRelation.h	/^    mutable StatesMap equivalencePartition;$/;"	m	class:souffle::EquivalenceRelation
err	json11.h	/^    string& err;$/;"	m	struct:json11::__anon66::final
error	ParserDriver.cpp	/^void ParserDriver::error(const SrcLocation& loc, const std::string& msg) {$/;"	f	class:souffle::ParserDriver
error	ParserDriver.cpp	/^void ParserDriver::error(const std::string& msg) {$/;"	f	class:souffle::ParserDriver
error	SignalHandler.h	/^    void error(const std::string& error) {$/;"	f	class:souffle::SignalHandler
error	parser.cc	/^  parser::error (const syntax_error& yyexc)$/;"	f	class:yy::parser
error	parser.cc	/^void yy::parser::error(const location_type &l, const std::string &m) {$/;"	f	class:yy::parser
error	souffle-compile	/^error() {$/;"	f
errorReport	AstTranslationUnit.h	/^    ErrorReport& errorReport;$/;"	m	class:souffle::AstTranslationUnit
errorReport	RamTranslationUnit.h	/^    ErrorReport& errorReport;$/;"	m	class:souffle::RamTranslationUnit
esc	json11.h	/^static inline string esc(char c) {$/;"	f	namespace:json11
escape	EventProcessor.h	/^    std::string escape(const std::string& text) {$/;"	f	class:souffle::profile::EventProcessorSingleton
escape	IODirectives.h	/^    std::string escape($/;"	f	class:souffle::IODirectives
escape	IODirectives.h	/^    std::string escape(const std::string& inputString) const {$/;"	f	class:souffle::IODirectives
escapeQuotes	profile/StringUtils.h	/^inline std::string escapeQuotes(std::string val) {$/;"	f	namespace:souffle::profile::Tools
eval	Interpreter.cpp	/^void LowLevelMachine::eval() {$/;"	f	class:souffle::LowLevelMachine
evalCond	Interpreter.cpp	/^bool Interpreter::evalCond(const RamCondition& cond, const InterpreterContext& ctxt) {$/;"	f	class:souffle::Interpreter
evalOp	Interpreter.cpp	/^void Interpreter::evalOp(const RamOperation& op, const InterpreterContext& args) {$/;"	f	class:souffle::Interpreter
evalStmt	Interpreter.cpp	/^void Interpreter::evalStmt(const RamStatement& stmt) {$/;"	f	class:souffle::Interpreter
evalVal	Interpreter.cpp	/^RamDomain Interpreter::evalVal(const RamExpression& value, const InterpreterContext& ctxt) {$/;"	f	class:souffle::Interpreter
evaluate	test/test.h	/^    test_result evaluate(bool condition) {$/;"	f	class:TestCase
exec	InterpreterInterface.h	/^    Interpreter& exec;$/;"	m	class:souffle::InterpreterProgInterface
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
executeBinary	main.cpp	/^void executeBinary(const std::string& binaryFilename$/;"	f	namespace:souffle
executeMain	Interpreter.cpp	/^void Interpreter::executeMain() {$/;"	f	class:souffle::Interpreter
executeSQL	ReadStreamSQLite.h	/^    void executeSQL(const std::string& sql) {$/;"	f	class:souffle::ReadStreamSQLite
executeSQL	WriteStreamSQLite.h	/^    void executeSQL(const std::string& sql, sqlite3* db) {$/;"	f	class:souffle::WriteStreamSQLite
executeSubroutine	Interpreter.cpp	/^void Interpreter::executeSubroutine(const RamStatement& stmt, const std::vector<RamDomain>& arguments,$/;"	f	class:souffle::Interpreter
executeSubroutine	SouffleInterface.h	/^    virtual void executeSubroutine(std::string name, const std::vector<RamDomain>& args,$/;"	f	class:souffle::SouffleProgram
existDir	CompiledOptions.h	/^    bool existDir(const std::string& name) const {$/;"	f	class:souffle::CmdOptions
existFile	CompiledOptions.h	/^    inline bool existFile(const std::string& name) const {$/;"	f	class:souffle::CmdOptions
exists	InterpreterIndex.h	/^    bool exists(const RamDomain* value) {$/;"	f	class:souffle::InterpreterIndex
exists	InterpreterRelation.h	/^    bool exists(const RamDomain* tuple) const {$/;"	f	class:souffle::InterpreterRelation
exitTag	SymbolTable.h	/^    static int exitTag() {$/;"	f	class:souffle::SymbolTable
expect	json11.h	/^    Json expect(const string& expected, Json res) {$/;"	f	struct:json11::__anon66::final
expired	PrecedenceGraph.h	/^    const std::set<const AstRelation*>& expired() const {$/;"	f	class:souffle::RelationScheduleStep
expiredRelations	PrecedenceGraph.h	/^    std::set<const AstRelation*> expiredRelations;$/;"	m	class:souffle::RelationScheduleStep
explain	Explain.h	/^    void explain() {$/;"	f	class:souffle::Explain
explain	ExplainProvenanceSLD.h	/^    std::unique_ptr<TreeNode> explain($/;"	f	class:souffle::ExplainProvenanceSLD
expr	AstArgument.h	/^    std::unique_ptr<AstArgument> expr;$/;"	m	class:souffle::AstAggregator
expression	RamOperation.h	/^    std::unique_ptr<RamExpression> expression;$/;"	m	class:souffle::RamAggregate
expressions	RamOperation.h	/^    std::vector<std::unique_ptr<RamExpression>> expressions;$/;"	m	class:souffle::RamProject
expressions	RamOperation.h	/^    std::vector<std::unique_ptr<RamExpression>> expressions;$/;"	m	class:souffle::RamReturn
extend	CompiledIndexUtils.h	/^    void extend(const DisjointSetIndex& other) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
extend	CompiledIndexUtils.h	/^struct extend<index<Columns...>, Col> {$/;"	s	namespace:souffle::ram::index_utils
extend	CompiledRelation.h	/^    void extend(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::AutoRelation
extend	CompiledRelation.h	/^    void extend(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
extend	ComponentModel.h	/^    TypeBinding extend(const std::vector<AstTypeIdentifier>& formalParams,$/;"	f	class:souffle::TypeBinding
extend	EquivalenceRelation.h	/^    void extend(const EquivalenceRelation<TupleType>& other) {$/;"	f	class:souffle::EquivalenceRelation
extend	InterpreterRelation.h	/^    virtual std::vector<RamDomain*> extend(const RamDomain* tuple) {$/;"	f	class:souffle::InterpreterRelation
extend	InterpreterRelation.h	/^    virtual void extend(const InterpreterRelation& rel) {}$/;"	f	class:souffle::InterpreterRelation
extend_to_full_index	CompiledIndexUtils.h	/^struct extend_to_full_index : public detail::extend_to_full_index_aux<0, arity, Index> {};$/;"	s	namespace:souffle::ram::index_utils
extend_to_full_index_aux	CompiledIndexUtils.h	/^struct extend_to_full_index_aux {$/;"	s	namespace:souffle::ram::index_utils::detail
extend_to_full_index_aux	CompiledIndexUtils.h	/^struct extend_to_full_index_aux<arity, arity, Index> {$/;"	s	namespace:souffle::ram::index_utils::detail
extloc	AstNode.h	/^    std::string extloc() const {$/;"	f	class:souffle::AstNode
extloc	SrcLocation.cpp	/^std::string SrcLocation::extloc() const {$/;"	f	class:souffle::SrcLocation
extra_literals	souffle2bdd.cpp	/^    std::vector<std::string> extra_literals;$/;"	m	class:souffle::BddBddBTranslator	file:
extra_literals	souffle2lb.cpp	/^    std::vector<std::string> extra_literals;$/;"	m	class:souffle::LogicbloxConverter	file:
extractAdornment	MagicSet.cpp	/^std::string extractAdornment(const AstRelationIdentifier& magicRelationName) {$/;"	f	namespace:souffle
extractConstant	MagicSet.cpp	/^AstArgument* extractConstant(SymbolTable& symbolTable, const std::string& normalisedConstant) {$/;"	f	namespace:souffle
extractPermutations	MinimiseProgramTransformer.cpp	/^std::vector<std::vector<unsigned int>> extractPermutations($/;"	f	namespace:souffle
extractRelationNameFromAtom	profile/Reader.h	/^    std::string extractRelationNameFromAtom(const Atom& atom) {$/;"	f	class:souffle::profile::Reader
f	json11.h	/^    const std::shared_ptr<JsonValue> f = make_shared<JsonBoolean>(false);$/;"	m	struct:json11::Statics
f	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile
f_name	profile/Tui.h	/^    std::string f_name;$/;"	m	class:souffle::profile::Tui
fail	json11.h	/^    Json fail(string&& msg) {$/;"	f	struct:json11::__anon66::final
fail	json11.h	/^    T fail(string&& msg, const T err_ret) {$/;"	f	struct:json11::__anon66::final
failed	json11.h	/^    bool failed;$/;"	m	struct:json11::__anon66::final
false_factory	AstGroundAnalysis.cpp	/^struct false_factory {$/;"	s	namespace:souffle::__anon2	file:
fatal	test/test.h	/^    std::ostream& fatal(bool condition, const std::string& txt, const std::string& loc) {$/;"	f	class:TestCase
fields	AstType.h	/^    std::vector<Field> fields;$/;"	m	class:souffle::AstRecordType
fields	TypeSystem.h	/^    std::vector<Field> fields;$/;"	m	struct:souffle::RecordType
file	ReadStreamCSV.h	/^    std::istream& file;$/;"	m	class:souffle::ReadStreamCSV
file	WriteStreamCSV.h	/^    gzfstream::ogzfstream file;$/;"	m	class:souffle::WriteGZipFileCSV
file	WriteStreamCSV.h	/^    std::ofstream file;$/;"	m	class:souffle::WriteFileCSV
fileHandle	ReadStreamCSV.h	/^    gzfstream::igzfstream fileHandle;$/;"	m	class:souffle::ReadFileCSV
fileHandle	ReadStreamCSV.h	/^    std::ifstream fileHandle;$/;"	m	class:souffle::ReadFileCSV
fileHandle	gzfstream.h	/^    gzFile fileHandle = {};$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
file_exists	profile/StringUtils.h	/^inline bool file_exists(const std::string& name) {$/;"	f	namespace:souffle::profile::Tools
file_loc	profile/Reader.h	/^    std::string file_loc;$/;"	m	class:souffle::profile::Reader
filename	SrcLocation.h	/^    std::string filename;$/;"	m	class:souffle::SrcLocation
filter_iterator	CompiledIndexUtils.h	/^    filter_iterator(Iter&& begin, Iter&& end, const tuple_type& value)$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
filter_iterator	CompiledIndexUtils.h	/^class filter_iterator : public std::iterator<std::forward_iterator_tag, typename Iter::value_type> {$/;"	c	namespace:souffle::ram::iterator_utils
final	json11.h	/^class Json final {$/;"	c	namespace:json11
final	json11.h	/^class JsonArray final : public Value<Json::ARRAY, Json::array> {$/;"	c	namespace:json11
final	json11.h	/^class JsonBoolean final : public Value<Json::BOOL, bool> {$/;"	c	namespace:json11
final	json11.h	/^class JsonDouble final : public Value<Json::NUMBER, double> {$/;"	c	namespace:json11
final	json11.h	/^class JsonInt final : public Value<Json::NUMBER, long long> {$/;"	c	namespace:json11
final	json11.h	/^class JsonNull final : public Value<Json::NUL, NullStruct> {$/;"	c	namespace:json11
final	json11.h	/^class JsonObject final : public Value<Json::OBJECT, Json::object> {$/;"	c	namespace:json11
final	json11.h	/^class JsonString final : public Value<Json::STRING, string> {$/;"	c	namespace:json11
final	json11.h	/^struct JsonParser final {$/;"	s	namespace:json11::__anon66
finalize	Mpi.h	/^inline void finalize() {$/;"	f	namespace:souffle::mpi::__anon58
find	BTree.h	/^    iterator find(const Key& k) const {$/;"	f	class:souffle::detail::btree
find	BTree.h	/^    iterator find(const Key& k, operation_hints& hints) const {$/;"	f	class:souffle::detail::btree
find	Brie.h	/^    iterator find(const entry_type& entry) const {$/;"	f	class:souffle::Trie
find	Brie.h	/^    iterator find(const entry_type& entry, op_context& ctxt) const {$/;"	f	class:souffle::Trie
find	Brie.h	/^    iterator find(index_type i) const {$/;"	f	class:souffle::SparseArray
find	Brie.h	/^    iterator find(index_type i) const {$/;"	f	class:souffle::SparseBitMap
find	Brie.h	/^    iterator find(index_type i, op_context& ctxt) const {$/;"	f	class:souffle::SparseArray
find	Brie.h	/^    iterator find(index_type i, op_context& ctxt) const {$/;"	f	class:souffle::SparseBitMap
find	CompiledIndexUtils.h	/^    iterator find(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
find	CompiledIndexUtils.h	/^    iterator find(const key_type& key, operation_hints& hints) const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
find	CompiledIndexUtils.h	/^    iterator find(const tuple_type& key, operation_hints& ctxt) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
find	ComponentModel.h	/^    const AstTypeIdentifier& find(const AstTypeIdentifier& name) const {$/;"	f	class:souffle::TypeBinding
find	EquivalenceRelation.h	/^    iterator find(const TupleType& t) const {$/;"	f	class:souffle::EquivalenceRelation
find	EquivalenceRelation.h	/^    iterator find(const TupleType&, operation_hints&) const {$/;"	f	class:souffle::EquivalenceRelation
find	SouffleInterface.h	/^    static inline ProgramFactory* find(const std::string& factoryName) {$/;"	f	class:souffle::ProgramFactory
findFirst	Brie.h	/^    static Node* findFirst(Node* node, int level) {$/;"	f	class:souffle::SparseArray
findInlineCycle	AstSemanticChecker.cpp	/^std::vector<AstRelationIdentifier> findInlineCycle(const PrecedenceGraph& precedenceGraph,$/;"	f	namespace:souffle
findNode	UnionFind.h	/^    inline SparseDomain findNode(SparseDomain x) {$/;"	f	class:souffle::SparseDisjointSet
findNode	UnionFind.h	/^    parent_t findNode(parent_t x) {$/;"	f	class:souffle::DisjointSet
findTuple	ExplainProvenanceSLD.h	/^    std::pair<int, int> findTuple(const std::string& relName, std::vector<RamDomain> tup) {$/;"	f	class:souffle::ExplainProvenanceSLD
finishParsing	AstProgram.cpp	/^void AstProgram::finishParsing() {$/;"	f	class:souffle::AstProgram
first	Brie.h	/^        Node* first;$/;"	m	struct:souffle::SparseArray::RootInfo
first	RamStatement.h	/^    std::unique_ptr<RamRelationReference> first;$/;"	m	class:souffle::RamSwap
firstOffset	Brie.h	/^        index_type firstOffset;$/;"	m	struct:souffle::SparseArray::RootInfo
fix_binding	Brie.h	/^struct fix_binding {$/;"	s	namespace:souffle::detail
fix_binding	Brie.h	/^struct fix_binding<0, Dim, Dim> {$/;"	s	namespace:souffle::detail
fix_binding	Brie.h	/^struct fix_binding<0, Pos, Dim> {$/;"	s	namespace:souffle::detail
fix_first	Brie.h	/^struct fix_first {$/;"	s	namespace:souffle::detail
fix_first	Brie.h	/^struct fix_first<Dim, Dim> {$/;"	s	namespace:souffle::detail
fixedPlan	AstClause.h	/^    bool fixedPlan = false;$/;"	m	class:souffle::AstClause
flex_int16_t	scanner.cc	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	scanner.cc	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	scanner.cc	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	scanner.cc	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	scanner.cc	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	scanner.cc	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	scanner.cc	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	scanner.cc	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	scanner.cc	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	scanner.cc	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint64_t	scanner.cc	/^typedef uint64_t flex_uint64_t;$/;"	t	file:
flex_uint8_t	scanner.cc	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	scanner.cc	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
formNegatedLiterals	InlineRelationsTransformer.cpp	/^std::vector<std::vector<AstLiteral*>> formNegatedLiterals(AstProgram& program, AstAtom* atom) {$/;"	f	namespace:souffle
formatMemory	profile/StringUtils.h	/^inline std::string formatMemory(uint64_t kbytes) {$/;"	f	namespace:souffle::profile::Tools
formatNum	profile/ProgramRun.h	/^    inline std::string formatNum(int precision, long number) const {$/;"	f	class:souffle::profile::ProgramRun
formatNum	profile/StringUtils.h	/^inline std::string formatNum(double amount) {$/;"	f	namespace:souffle::profile::Tools
formatNum	profile/StringUtils.h	/^inline std::string formatNum(int precision, int64_t amount) {$/;"	f	namespace:souffle::profile::Tools
formatTable	profile/ProgramRun.h	/^    inline std::vector<std::vector<std::string>> formatTable(Table& table, int precision) const {$/;"	f	class:souffle::profile::ProgramRun
formatTable	profile/StringUtils.h	/^inline std::vector<std::vector<std::string>> formatTable(Table table, int precision) {$/;"	f	namespace:souffle::profile::Tools
formatTime	profile/ProgramRun.h	/^    inline std::string formatTime(std::chrono::microseconds runtime) const {$/;"	f	class:souffle::profile::ProgramRun
formatTime	profile/StringUtils.h	/^inline std::string formatTime(std::chrono::microseconds number) {$/;"	f	namespace:souffle::profile::Tools
forward	CompiledIndexUtils.h	/^    void forward() {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
freeList	PiggyList.h	/^    void freeList() {$/;"	f	class:souffle::PiggyList
freeList	PiggyList.h	/^    void freeList() {$/;"	f	class:souffle::RandomInsertPiggyList
freeNodes	Brie.h	/^    static void freeNodes(Node* node, int level) {$/;"	f	class:souffle::SparseArray
frequencies	Interpreter.h	/^    std::map<std::string, std::map<size_t, size_t>> frequencies;$/;"	m	class:souffle::Interpreter
frequency	profile/Rule.h	/^    const size_t frequency;$/;"	m	class:souffle::profile::Atom
frequencyAtomProcessor	EventProcessor.h	/^} frequencyAtomProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::FrequencyAtomProcessor
fun	AstArgument.h	/^    Op fun;$/;"	m	class:souffle::AstAggregator
function	AstArgument.h	/^    FunctorOp function;$/;"	m	class:souffle::AstIntrinsicFunctor
function	RamOperation.h	/^    Function function;$/;"	m	class:souffle::RamAggregate
function	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	f	namespace:souffle::profile
function	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	f	namespace:souffle::profile::html
functorOpAcceptsNumbers	FunctorOps.h	/^inline bool functorOpAcceptsNumbers(size_t arg, const FunctorOp op) {$/;"	f	namespace:souffle
functorOpAcceptsSymbols	FunctorOps.h	/^inline bool functorOpAcceptsSymbols(size_t arg, const FunctorOp op) {$/;"	f	namespace:souffle
functors	AstProgram.h	/^    std::map<std::string, std::unique_ptr<AstFunctorDeclaration>> functors;$/;"	m	class:souffle::AstProgram
genAllDisjointSetLists	EquivalenceRelation.h	/^    void genAllDisjointSetLists() const {$/;"	f	class:souffle::EquivalenceRelation
genJson	profile/Tui.h	/^    std::string genJson() {$/;"	f	namespace:souffle::profile
genJsonAtoms	profile/Tui.h	/^    std::stringstream& genJsonAtoms(std::stringstream& ss) {$/;"	f	class:souffle::profile::Tui
genJsonConfiguration	profile/Tui.h	/^    std::stringstream& genJsonConfiguration(std::stringstream& ss) {$/;"	f	class:souffle::profile::Tui
genJsonRelations	profile/Tui.h	/^    std::stringstream& genJsonRelations(std::stringstream& ss, const std::string& name, size_t maxRows) {$/;"	f	class:souffle::profile::Tui
genJsonTop	profile/Tui.h	/^    std::stringstream& genJsonTop(std::stringstream& ss) {$/;"	f	class:souffle::profile::Tui
generateCode	Synthesiser.cpp	/^void Synthesiser::generateCode(std::ostream& os, const std::string& id, bool& withSharedLibrary) {$/;"	f	class:souffle::Synthesiser
generateDebugReport	DebugReport.cpp	/^void DebugReporter::generateDebugReport($/;"	f	class:souffle::DebugReporter
generateRelationTypeStruct	Synthesiser.cpp	/^void Synthesiser::generateRelationTypeStruct($/;"	f	class:souffle::Synthesiser
generateTypeStruct	SynthesiserRelation.cpp	/^void SynthesiserBrieRelation::generateTypeStruct(std::ostream& out) {$/;"	f	class:souffle::SynthesiserBrieRelation
generateTypeStruct	SynthesiserRelation.cpp	/^void SynthesiserDirectRelation::generateTypeStruct(std::ostream& out) {$/;"	f	class:souffle::SynthesiserDirectRelation
generateTypeStruct	SynthesiserRelation.cpp	/^void SynthesiserEqrelRelation::generateTypeStruct(std::ostream& out) {$/;"	f	class:souffle::SynthesiserEqrelRelation
generateTypeStruct	SynthesiserRelation.cpp	/^void SynthesiserIndirectRelation::generateTypeStruct(std::ostream& out) {$/;"	f	class:souffle::SynthesiserIndirectRelation
generateTypeStruct	SynthesiserRelation.cpp	/^void SynthesiserNullaryRelation::generateTypeStruct(std::ostream& out) {$/;"	f	class:souffle::SynthesiserNullaryRelation
generateUniqueID	DebugReport.h	/^    static std::string generateUniqueID(const std::string& id) {$/;"	f	class:souffle::DebugReportSection
generated	AstClause.h	/^    bool generated = false;$/;"	m	class:souffle::AstClause
generatingInstructionStream	Interpreter.cpp	/^void LowLevelMachine::generatingInstructionStream() {$/;"	f	class:souffle::LowLevelMachine
generator	Interpreter.h	/^   LVMGenerator generator;$/;"	m	class:souffle::LowLevelMachine
get	Brie.h	/^    value_type& get(index_type i) {$/;"	f	class:souffle::SparseArray
get	Brie.h	/^    value_type& get(index_type i, op_context& ctxt) {$/;"	f	class:souffle::SparseArray
get	CompiledRelation.h	/^    const typename std::enable_if<config::template covers_query<Index, First>::value, this_type>::type& get()$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	CompiledRelation.h	/^    get() const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	CompiledRelation.h	/^    get() {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	CompiledRelation.h	/^    typename std::enable_if<config::template covers_query<Index, First>::value, this_type&>::type get() {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	CompiledRelation.h	/^    void get() const {}$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	CompiledRelation.h	/^    void get() {}$/;"	f	class:souffle::ram::detail::GenericRelationGroup
get	Global.h	/^    const V& get(const K& key) const {$/;"	f	class:souffle::BaseTable
get	Global.h	/^    const V& get(const K& key, const V& value) const {$/;"	f	class:souffle::BaseTable
get	IODirectives.h	/^    const std::string& get(const std::string& key) const {$/;"	f	class:souffle::IODirectives
get	PiggyList.h	/^    inline T& get(size_t index) const {$/;"	f	class:souffle::PiggyList
get	PiggyList.h	/^    inline T& get(size_t index) const {$/;"	f	class:souffle::RandomInsertPiggyList
get	RamRelation.h	/^    const RamRelation* get() const {$/;"	f	class:souffle::RamRelationReference
get	UnionFind.h	/^    inline std::atomic<block_t>& get(parent_t node) const {$/;"	f	class:souffle::DisjointSet
getAdditionalMessages	ErrorReport.h	/^    const std::vector<DiagnosticMessage>& getAdditionalMessages() const {$/;"	f	class:souffle::Diagnostic
getAdornedClauses	MagicSet.h	/^    const std::vector<std::vector<AdornedClause>>& getAdornedClauses() const {$/;"	f	class:souffle::Adornment
getAdornment	MagicSet.h	/^    std::string getAdornment() const {$/;"	f	class:souffle::AdornedPredicate
getAggregatorLocation	AstTranslator.h	/^        const Location& getAggregatorLocation(const AstAggregator& agg) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
getAllChains	IndexSetAnalysis.h	/^    const ChainOrderMap getAllChains() const {$/;"	f	class:souffle::IndexSet
getAllOrders	IndexSetAnalysis.h	/^    const OrderCollection getAllOrders() const {$/;"	f	class:souffle::IndexSet
getAllRelations	SouffleInterface.h	/^    std::vector<Relation*> getAllRelations() const {$/;"	f	class:souffle::SouffleProgram
getAllTypes	TypeSystem.cpp	/^TypeSet TypeEnvironment::getAllTypes() const {$/;"	f	class:souffle::TypeEnvironment
getAllTypes	TypeSystem.h	/^    static TypeSet getAllTypes() {$/;"	f	struct:souffle::TypeSet
getAnalysis	AstTranslationUnit.h	/^    Analysis* getAnalysis() const {$/;"	f	class:souffle::AstTranslationUnit
getAnalysis	RamTranslationUnit.h	/^    Analysis* getAnalysis() const {$/;"	f	class:souffle::RamTranslationUnit
getArg	AstArgument.h	/^    AstArgument* getArg(size_t idx) const {$/;"	f	class:souffle::AstIntrinsicFunctor
getArg	AstArgument.h	/^    const AstArgument* getArg(size_t idx) const {$/;"	f	class:souffle::AstUserDefinedFunctor
getArg	RamRelation.h	/^    const std::string getArg(uint32_t i) const {$/;"	f	class:souffle::RamRelation
getArgCount	AstArgument.h	/^    size_t getArgCount() const {$/;"	f	class:souffle::AstUserDefinedFunctor
getArgCount	AstFunctorDeclaration.h	/^    size_t getArgCount() const {$/;"	f	class:souffle::AstFunctorDeclaration
getArgCount	RamExpression.h	/^    size_t getArgCount() const {$/;"	f	class:souffle::RamArgument
getArgCount	RamExpression.h	/^    size_t getArgCount() const {$/;"	f	class:souffle::RamIntrinsicOperator
getArgCount	RamExpression.h	/^    size_t getArgCount() const {$/;"	f	class:souffle::RamUserDefinedOperator
getArgList	AstTranslator.cpp	/^AstTranslator::ClauseTranslator::arg_list* AstTranslator::ClauseTranslator::getArgList($/;"	f	class:souffle::AstTranslator::ClauseTranslator
getArgTypeQualifier	RamRelation.h	/^    const std::string getArgTypeQualifier(uint32_t i) const {$/;"	f	class:souffle::RamRelation
getArgument	AstLiteral.h	/^    AstArgument* getArgument(size_t idx) const {$/;"	f	class:souffle::AstAtom
getArgument	InterpreterContext.h	/^    RamDomain getArgument(size_t i) const {$/;"	f	class:souffle::InterpreterContext
getArgument	RamExpression.h	/^    const RamExpression* getArgument(size_t i) const {$/;"	f	class:souffle::RamIntrinsicOperator
getArgument	RamExpression.h	/^    const RamExpression* getArgument(size_t i) const {$/;"	f	class:souffle::RamUserDefinedOperator
getArguments	AstArgument.h	/^    std::vector<AstArgument*> getArguments() const {$/;"	f	class:souffle::AstIntrinsicFunctor
getArguments	AstArgument.h	/^    std::vector<AstArgument*> getArguments() const {$/;"	f	class:souffle::AstRecordInit
getArguments	AstArgument.h	/^    std::vector<AstArgument*> getArguments() const {$/;"	f	class:souffle::AstUserDefinedFunctor
getArguments	AstLiteral.h	/^    std::vector<AstArgument*> getArguments() const {$/;"	f	class:souffle::AstAtom
getArguments	InterpreterContext.h	/^    const std::vector<RamDomain>& getArguments() const {$/;"	f	class:souffle::InterpreterContext
getArguments	RamExpression.h	/^    std::vector<RamExpression*> getArguments() const {$/;"	f	class:souffle::RamIntrinsicOperator
getArguments	RamExpression.h	/^    std::vector<RamExpression*> getArguments() const {$/;"	f	class:souffle::RamPackRecord
getArguments	RamExpression.h	/^    std::vector<RamExpression*> getArguments() const {$/;"	f	class:souffle::RamUserDefinedOperator
getArity	AstArgument.h	/^    size_t getArity() const {$/;"	f	class:souffle::AstIntrinsicFunctor
getArity	AstLiteral.h	/^    size_t getArity() const {$/;"	f	class:souffle::AstAtom
getArity	AstRelation.h	/^    size_t getArity() const {$/;"	f	class:souffle::AstRelation
getArity	InterpreterRelation.h	/^    size_t getArity() const {$/;"	f	class:souffle::InterpreterRelation
getArity	RamOperation.h	/^    std::size_t getArity() const {$/;"	f	class:souffle::RamUnpackRecord
getArity	RamRelation.h	/^    unsigned getArity() const {$/;"	f	class:souffle::RamRelation
getArity	SynthesiserRelation.h	/^    size_t getArity() const {$/;"	f	class:souffle::SynthesiserRelation
getAtom	AstLiteral.h	/^    AstAtom* getAtom() {$/;"	f	class:souffle::AstNegation
getAtom	AstLiteral.h	/^    AstAtom* getAtom() {$/;"	f	class:souffle::AstProvenanceNegation
getAtomRelation	AstUtils.cpp	/^const AstRelation* getAtomRelation(const AstAtom* atom, const AstProgram* program) {$/;"	f	namespace:souffle
getAtomTable	profile/OutputProcessor.h	/^Table inline OutputProcessor::getAtomTable(std::string strRel, std::string strRul) const {$/;"	f	class:souffle::profile::OutputProcessor
getAtomic	Brie.h	/^    atomic_value_type& getAtomic(index_type i) {$/;"	f	class:souffle::SparseArray
getAtomic	Brie.h	/^    atomic_value_type& getAtomic(index_type i, op_context& ctxt) {$/;"	f	class:souffle::SparseArray
getAtoms	AstClause.h	/^    std::vector<AstAtom*> getAtoms() const {$/;"	f	class:souffle::AstClause
getAtoms	profile/Rule.h	/^    const std::set<Atom>& getAtoms() const {$/;"	f	class:souffle::profile::Rule
getAttribute	AstRelation.h	/^    AstAttribute* getAttribute(size_t idx) const {$/;"	f	class:souffle::AstRelation
getAttributeName	AstAttribute.h	/^    const std::string& getAttributeName() const {$/;"	f	class:souffle::AstAttribute
getAttributeTypeQualifiers	InterpreterRelation.h	/^    std::vector<std::string>& getAttributeTypeQualifiers() {$/;"	f	class:souffle::InterpreterRelation
getAttributeTypeQualifiers	RamRelation.h	/^    const std::vector<std::string>& getAttributeTypeQualifiers() const {$/;"	f	class:souffle::RamRelation
getAttributes	AstRelation.h	/^    std::vector<AstAttribute*> getAttributes() const {$/;"	f	class:souffle::AstRelation
getBaseComponents	AstComponent.h	/^    const std::vector<AstComponentType*> getBaseComponents() const {$/;"	f	class:souffle::AstComponent
getBaseType	TypeSystem.h	/^    const Type& getBaseType() const {$/;"	f	class:souffle::PrimitiveType
getBeginCoreIterator	Brie.h	/^    iterator_core<I> getBeginCoreIterator(Tuple& entry) const {$/;"	f	class:souffle::Trie
getBeginCoreIterator	Brie.h	/^    iterator_core<I> getBeginCoreIterator(Tuple&) const {$/;"	f	class:souffle::Trie
getBinaryConstraints	AstClause.h	/^    std::vector<AstBinaryConstraint*> getBinaryConstraints() const {$/;"	f	class:souffle::AstClause
getBindings	MagicSet.h	/^    const BindingStore& getBindings() const {$/;"	f	class:souffle::Adornment
getBlock	PiggyList.h	/^    inline T* getBlock(size_t blockNum) const {$/;"	f	class:souffle::RandomInsertPiggyList
getBlock	PiggyList.h	/^    inline T* getBlock(size_t blocknum) const {$/;"	f	class:souffle::PiggyList
getBody	RamStatement.h	/^    const RamStatement& getBody() const {$/;"	f	class:souffle::RamLoop
getBody	RamStatement.h	/^    const RamStatement& getBody() const {$/;"	f	class:souffle::RamStratum
getBodyAdornment	MagicSet.h	/^    std::vector<std::string> getBodyAdornment() const {$/;"	f	class:souffle::AdornedClause
getBodyLiteral	AstClause.cpp	/^AstLiteral* AstClause::getBodyLiteral(size_t idx) const {$/;"	f	class:souffle::AstClause
getBodyLiterals	AstArgument.h	/^    std::vector<AstLiteral*> getBodyLiterals() const {$/;"	f	class:souffle::AstAggregator
getBodyLiterals	AstClause.cpp	/^std::vector<AstLiteral*> AstClause::getBodyLiterals() const {$/;"	f	class:souffle::AstClause
getBodyRelations	AstUtils.cpp	/^std::set<const AstRelation*> getBodyRelations(const AstClause* clause, const AstProgram* program) {$/;"	f	namespace:souffle
getBodySize	AstClause.h	/^    size_t getBodySize() const {$/;"	f	class:souffle::AstClause
getBoundaries	Brie.h	/^    range<iterator> getBoundaries(const entry_type& entry) const {$/;"	f	class:souffle::Trie
getBoundaries	Brie.h	/^    range<iterator> getBoundaries(const entry_type& entry, op_context& ctxt) const {$/;"	f	class:souffle::Trie
getBoundaries	Brie.h	/^    range<iterator> getBoundaries(const entry_type& entry, op_context&) const {$/;"	f	class:souffle::Trie
getBoundaries	Brie.h	/^    range<iterator> getBoundaries(const entry_type&) const {$/;"	f	class:souffle::Trie
getBoundaries	EquivalenceRelation.h	/^    range<iterator> getBoundaries(const TupleType& entry) const {$/;"	f	class:souffle::EquivalenceRelation
getBoundaries	EquivalenceRelation.h	/^    range<iterator> getBoundaries(const TupleType& entry, operation_hints&) const {$/;"	f	class:souffle::EquivalenceRelation
getCells	profile/Row.h	/^    inline std::vector<std::shared_ptr<CellInterface>> getCells() {$/;"	f	class:souffle::profile::Row
getChain	IndexSetAnalysis.cpp	/^IndexSet::Chain IndexSet::getChain(const SearchColumns umn, const MaxMatching::Matchings& match) {$/;"	f	class:souffle::IndexSet
getChainsFromMatching	IndexSetAnalysis.cpp	/^const IndexSet::ChainOrderMap IndexSet::getChainsFromMatching($/;"	f	class:souffle::IndexSet
getChecks	test/test.h	/^    size_t getChecks() const {$/;"	f	class:TestCase
getChild	BTree.h	/^        node* getChild(size_type s) const {$/;"	f	struct:souffle::detail::btree::node
getChildNodes	AstArgument.cpp	/^std::vector<const AstNode*> AstAggregator::getChildNodes() const {$/;"	f	class:souffle::AstAggregator
getChildren	BTree.h	/^        node* const* getChildren() const {$/;"	f	struct:souffle::detail::btree::node
getChildren	BTree.h	/^        node** getChildren() {$/;"	f	struct:souffle::detail::btree::node
getChunks	BTree.h	/^    std::vector<chunk> getChunks(size_type num) const {$/;"	f	class:souffle::detail::btree
getClause	AstRelation.h	/^    AstClause* getClause(size_t idx) const {$/;"	f	class:souffle::AstRelation
getClause	MagicSet.h	/^    AstClause* getClause() const {$/;"	f	class:souffle::AdornedClause
getClauseNum	AstClause.h	/^    size_t getClauseNum() const {$/;"	f	class:souffle::AstClause
getClauses	AstComponent.h	/^    std::vector<AstClause*> getClauses() const {$/;"	f	class:souffle::AstComponent
getClauses	AstRelation.h	/^    std::vector<AstClause*> getClauses() const {$/;"	f	class:souffle::AstRelation
getCodeSection	DebugReport.cpp	/^DebugReportSection DebugReporter::getCodeSection(const std::string& id, std::string title, std::string code) {$/;"	f	class:souffle::DebugReporter
getComponent	ComponentModel.cpp	/^const AstComponent* ComponentLookup::getComponent($/;"	f	class:souffle::ComponentLookup
getComponentInstantiations	AstProgram.h	/^    std::vector<AstComponentInit*> getComponentInstantiations() const {$/;"	f	class:souffle::AstProgram
getComponentType	AstComponent.h	/^    const AstComponentType* getComponentType() const {$/;"	f	class:souffle::AstComponent
getComponentType	AstComponent.h	/^    const AstComponentType* getComponentType() const {$/;"	f	class:souffle::AstComponentInit
getComponents	AstComponent.h	/^    std::vector<AstComponent*> getComponents() const {$/;"	f	class:souffle::AstComponent
getComponents	AstProgram.h	/^    std::vector<AstComponent*> getComponents() const {$/;"	f	class:souffle::AstProgram
getCondition	RamOperation.h	/^    RamCondition* getCondition() const {$/;"	f	class:souffle::RamAggregate
getCondition	RamOperation.h	/^    const RamCondition& getCondition() const {$/;"	f	class:souffle::RamFilter
getCondition	RamStatement.h	/^    const RamCondition& getCondition() const {$/;"	f	class:souffle::RamExit
getCondition	RamStatement.h	/^    const RamCondition* getCondition() const {$/;"	f	class:souffle::RamQuery
getConditions	RamTransforms.cpp	/^std::vector<std::unique_ptr<RamCondition>> getConditions(const RamCondition* condition) {$/;"	f	namespace:souffle::__anon74
getConstant	AstArgument.h	/^    const std::string& getConstant() const {$/;"	f	class:souffle::AstStringConstant
getConstant	RamExpression.h	/^    RamDomain getConstant() const {$/;"	f	class:souffle::RamNumber
getConstraints	AstClause.h	/^    std::vector<AstConstraint*> getConstraints() const {$/;"	f	class:souffle::AstClause
getCopyTime	profile/Relation.h	/^    std::chrono::microseconds getCopyTime() const {$/;"	f	class:souffle::profile::Relation
getCopytime	profile/Iteration.h	/^    std::chrono::microseconds getCopytime() const {$/;"	f	class:souffle::profile::Iteration
getCount	Mpi.h	/^inline int getCount(std::unique_ptr<MPI_Status>& status) {$/;"	f	namespace:souffle::mpi::__anon54
getCount	RamStatement.h	/^    const int getCount() const {$/;"	f	class:souffle::RamWait
getCounter	Interpreter.h	/^    int getCounter() const {$/;"	f	class:souffle::Interpreter
getDB	ProfileEvent.h	/^    const profile::ProfileDatabase& getDB() const {$/;"	f	class:souffle::ProfileEventSingleton
getData	CompiledRelation.h	/^    const table_t& getData() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
getData	test/btree_multiset_test.cpp	/^std::vector<Entry> getData(unsigned numEntries) {$/;"	f	namespace:souffle::test
getData	test/btree_set_test.cpp	/^std::vector<Entry> getData(unsigned numEntries) {$/;"	f	namespace:souffle::test
getDataStructure	SynthesiserRelation.h	/^    const std::string& getDataStructure() const {$/;"	f	class:souffle::SynthesiserRelation
getDebugReport	AstTranslationUnit.h	/^    DebugReport& getDebugReport() {$/;"	f	class:souffle::AstTranslationUnit
getDebugReport	AstTranslationUnit.h	/^    const DebugReport& getDebugReport() const {$/;"	f	class:souffle::AstTranslationUnit
getDebugReport	RamTranslationUnit.h	/^    DebugReport& getDebugReport() {$/;"	f	class:souffle::RamTranslationUnit
getDebugReport	RamTranslationUnit.h	/^    const DebugReport& getDebugReport() const {$/;"	f	class:souffle::RamTranslationUnit
getDefinitionPoint	AstTranslator.h	/^        const Location& getDefinitionPoint(const AstRecordInit& init) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
getDefinitionPoint	AstTranslator.h	/^        const Location& getDefinitionPoint(const AstVariable& var) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
getDelimiter	ReadStreamCSV.h	/^    std::string getDelimiter(const IODirectives& ioDirectives) const {$/;"	f	class:souffle::ReadStreamCSV
getDelimiter	WriteStreamCSV.h	/^    virtual std::string getDelimiter(const IODirectives& ioDirectives) const {$/;"	f	class:souffle::WriteStreamCSV
getDepth	BTree.h	/^        size_type getDepth() const {$/;"	f	struct:souffle::detail::btree::node
getDepth	BTree.h	/^    size_type getDepth() const {$/;"	f	class:souffle::detail::btree
getDepth	RamOperationDepth.cpp	/^size_t RamOperationDepthAnalysis::getDepth(const RamOperation* op) const {$/;"	f	class:souffle::RamOperationDepthAnalysis
getDescription	CompiledRelation.h	/^    std::string getDescription() const {$/;"	f	struct:souffle::ram::detail::RelationBase
getDestinationStrata	RamStatement.h	/^    const std::set<size_t> getDestinationStrata() const {$/;"	f	class:souffle::RamSend
getDistance	IndexSetAnalysis.cpp	/^int MaxMatching::getDistance(int v) {$/;"	f	class:souffle::MaxMatching
getDotGraphSection	DebugReport.cpp	/^DebugReportSection DebugReporter::getDotGraphSection($/;"	f	class:souffle::DebugReporter
getEDB	MagicSet.h	/^    const std::set<AstRelationIdentifier>& getEDB() const {$/;"	f	class:souffle::Adornment
getElement	RamExpression.h	/^    size_t getElement() const {$/;"	f	class:souffle::RamElementAccess
getElementTypes	TypeSystem.h	/^    const std::vector<const Type*>& getElementTypes() const {$/;"	f	class:souffle::UnionType
getEnd	ProfileDatabase.h	/^    microseconds getEnd() const {$/;"	f	class:souffle::profile::DurationEntry
getEndpoint	MagicSet.cpp	/^int getEndpoint(std::string mainName) {$/;"	f	namespace:souffle
getEndtime	profile/Iteration.h	/^    std::chrono::microseconds getEndtime() const {$/;"	f	class:souffle::profile::Iteration
getEndtime	profile/ProgramRun.h	/^    std::chrono::microseconds getEndtime() const {$/;"	f	class:souffle::profile::ProgramRun
getEndtime	profile/Relation.h	/^    std::chrono::microseconds getEndtime() const {$/;"	f	class:souffle::profile::Relation
getEndtime	profile/Rule.h	/^    std::chrono::microseconds getEndtime() const {$/;"	f	class:souffle::profile::Rule
getErrorReport	AstTranslationUnit.h	/^    ErrorReport& getErrorReport() {$/;"	f	class:souffle::AstTranslationUnit
getErrorReport	AstTranslationUnit.h	/^    const ErrorReport& getErrorReport() const {$/;"	f	class:souffle::AstTranslationUnit
getErrorReport	RamTranslationUnit.h	/^    ErrorReport& getErrorReport() {$/;"	f	class:souffle::RamTranslationUnit
getErrorReport	RamTranslationUnit.h	/^    const ErrorReport& getErrorReport() const {$/;"	f	class:souffle::RamTranslationUnit
getExecutionPlan	AstClause.h	/^    const AstExecutionPlan* getExecutionPlan() const {$/;"	f	class:souffle::AstClause
getExpression	RamOperation.h	/^    const RamExpression* getExpression() const {$/;"	f	class:souffle::RamAggregate
getExternalNonOutputPredecessorRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getExternalNonOutputPredecessorRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getExternalOutputPredecessorRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getExternalOutputPredecessorRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getExternalPredecessorRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getExternalPredecessorRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getFactoryRegistry	SouffleInterface.h	/^    static inline std::map<std::string, ProgramFactory*>& getFactoryRegistry() {$/;"	f	class:souffle::ProgramFactory
getFailed	test/test.h	/^    size_t getFailed() const {$/;"	f	class:TestCase
getFalse	AstParserUtils.cpp	/^RuleBody RuleBody::getFalse() {$/;"	f	class:souffle::RuleBody
getFields	AstType.h	/^    const std::vector<Field>& getFields() const {$/;"	f	class:souffle::AstRecordType
getFields	TypeSystem.h	/^    const std::vector<Field>& getFields() const {$/;"	f	struct:souffle::RecordType
getFileName	IODirectives.h	/^    const std::string& getFileName() const {$/;"	f	class:souffle::IODirectives
getFileName	ReadStreamCSV.h	/^    std::string getFileName(const IODirectives& ioDirectives) const {$/;"	f	class:souffle::ReadFileCSV
getFirstHalf	profile/HtmlGenerator.h	/^    static std::string getFirstHalf() {$/;"	f	class:souffle::profile::HtmlGenerator
getFirstInfo	Brie.h	/^    FirstInfoSnapshot getFirstInfo() const {$/;"	f	class:souffle::SparseArray
getFirstRelation	RamStatement.h	/^    const RamRelation& getFirstRelation() const {$/;"	f	class:souffle::RamSwap
getFirstVersion	Brie.h	/^    uint64_t getFirstVersion() const {$/;"	f	class:souffle::SparseArray
getForArity	InterpreterRecords.cpp	/^RecordMap& getForArity(int arity) {$/;"	f	namespace:souffle::__anon67
getForIndex	CompiledIndexUtils.h	/^        int getForIndex(const Index& i) {$/;"	f	struct:souffle::ram::index_utils::Indices::operation_context
getForIndex	CompiledIndexUtils.h	/^        typename index_t::operation_hints& getForIndex(const First&) {$/;"	f	struct:souffle::ram::index_utils::Indices::operation_context
getFunction	AstArgument.h	/^    FunctorOp getFunction() const {$/;"	f	class:souffle::AstIntrinsicFunctor
getFunction	RamOperation.h	/^    Function getFunction() const {$/;"	f	class:souffle::RamAggregate
getFunctorDeclaration	AstProgram.cpp	/^AstFunctorDeclaration* AstProgram::getFunctorDeclaration(const std::string& name) const {$/;"	f	class:souffle::AstProgram
getFunctorOpArity	FunctorOps.h	/^inline size_t getFunctorOpArity(FunctorOp op) {$/;"	f	namespace:souffle
getGreatestCommonSubtypes	TypeSystem.cpp	/^TypeSet getGreatestCommonSubtypes(const Type& a, const Type& b) {$/;"	f	namespace:souffle
getGreatestCommonSubtypes	TypeSystem.cpp	/^TypeSet getGreatestCommonSubtypes(const TypeSet& a, const TypeSet& b) {$/;"	f	namespace:souffle
getGreatestCommonSubtypes	TypeSystem.cpp	/^TypeSet getGreatestCommonSubtypes(const TypeSet& set) {$/;"	f	namespace:souffle
getGreatestCommonSubtypes	TypeSystem.h	/^TypeSet getGreatestCommonSubtypes(const Types&... types) {$/;"	f	namespace:souffle
getGroundedTerms	AstGroundAnalysis.cpp	/^std::map<const AstArgument*, bool> getGroundedTerms(const AstClause& clause) {$/;"	f	namespace:souffle
getGroup	test/test.h	/^    const std::string& getGroup() const {$/;"	f	class:TestCase
getHead	AstClause.h	/^    AstAtom* getHead() const {$/;"	f	class:souffle::AstClause
getHeadAdornment	MagicSet.h	/^    std::string getHeadAdornment() const {$/;"	f	class:souffle::AdornedClause
getHeadRelation	AstUtils.cpp	/^const AstRelation* getHeadRelation(const AstClause* clause, const AstProgram* program) {$/;"	f	namespace:souffle
getHeight	ExplainTree.h	/^    uint32_t getHeight() const {$/;"	f	class:souffle::TreeNode
getHintStatistics	BTree.h	/^    const hint_statistics& getHintStatistics() const {$/;"	f	class:souffle::detail::btree
getHintStatistics	Brie.h	/^    const hint_statistics& getHintStatistics() const {$/;"	f	class:souffle::detail::TrieBase
getHtml	profile/HtmlGenerator.h	/^    static std::string getHtml(std::string json) {$/;"	f	class:souffle::profile::HtmlGenerator
getIDB	MagicSet.h	/^    const std::set<AstRelationIdentifier>& getIDB() const {$/;"	f	class:souffle::Adornment
getIODirectiveMap	AstIO.h	/^    const std::map<std::string, std::string>& getIODirectiveMap() const {$/;"	f	class:souffle::AstIO
getIODirectives	RamStatement.h	/^    const std::vector<IODirectives>& getIODirectives() const {$/;"	f	class:souffle::RamLoad
getIODirectives	RamStatement.h	/^    const std::vector<IODirectives>& getIODirectives() const {$/;"	f	class:souffle::RamStore
getIOType	IODirectives.h	/^    const std::string& getIOType() const {$/;"	f	class:souffle::IODirectives
getId	SouffleInterface.h	/^        virtual uint32_t getId() const {$/;"	f	class:souffle::Relation::iterator_base
getId	profile/Relation.h	/^    const std::string& getId() const {$/;"	f	class:souffle::profile::Relation
getId	profile/Rule.h	/^    std::string getId() const {$/;"	f	class:souffle::profile::Rule
getIdentifier	RamExpression.h	/^    size_t getIdentifier() const {$/;"	f	class:souffle::RamElementAccess
getIdentifier	RamOperation.h	/^    std::size_t getIdentifier() const {$/;"	f	class:souffle::RamSearch
getIgnoredAtoms	MagicSet.h	/^    const std::set<AstRelationIdentifier>& getIgnoredAtoms() const {$/;"	f	class:souffle::Adornment
getIndex	AstArgument.h	/^    AstDomain getIndex() const {$/;"	f	class:souffle::AstConstant
getIndex	Brie.h	/^    static index_type getIndex(RamDomain a, unsigned level) {$/;"	f	class:souffle::SparseArray
getIndex	CompiledIndexUtils.h	/^    const index_t& getIndex(const First&) const {$/;"	f	class:souffle::ram::index_utils::Indices
getIndex	CompiledIndexUtils.h	/^    index_t& getIndex(const First&) {$/;"	f	class:souffle::ram::index_utils::Indices
getIndex	CompiledIndexUtils.h	/^    int getIndex(const Index& i) {$/;"	f	class:souffle::ram::index_utils::Indices
getIndex	InterpreterRelation.h	/^    InterpreterIndex* getIndex(const InterpreterIndexOrder& order) const {$/;"	f	class:souffle::InterpreterRelation
getIndex	InterpreterRelation.h	/^    InterpreterIndex* getIndex(const SearchColumns& key) const {$/;"	f	class:souffle::InterpreterRelation
getIndex	InterpreterRelation.h	/^    InterpreterIndex* getIndex(const SearchColumns& key, InterpreterIndex* cachedIndex) const {$/;"	f	class:souffle::InterpreterRelation
getIndex	RamStatement.h	/^    const int getIndex() const {$/;"	f	class:souffle::RamStratum
getIndexElement	RamOperation.cpp	/^std::unique_ptr<RamExpression> RamAggregate::getIndexElement(RamCondition* c, size_t& element, size_t level) {$/;"	f	class:souffle::RamAggregate
getIndexElement	RamTransforms.cpp	/^std::unique_ptr<RamExpression> CreateIndicesTransformer::getIndexElement($/;"	f	class:souffle::CreateIndicesTransformer
getIndexSet	SynthesiserRelation.h	/^    const IndexSet& getIndexSet() const {$/;"	f	class:souffle::SynthesiserRelation
getIndexes	IndexSetAnalysis.h	/^    IndexSet& getIndexes(const RamRelation& rel) {$/;"	f	class:souffle::IndexSetAnalysis
getIndices	SynthesiserRelation.h	/^    std::vector<std::vector<int>> getIndices() const {$/;"	f	class:souffle::SynthesiserRelation
getInlinedArgument	InlineRelationsTransformer.cpp	/^NullableVector<AstArgument*> getInlinedArgument(AstProgram& program, const AstArgument* arg) {$/;"	f	namespace:souffle
getInlinedAtom	InlineRelationsTransformer.cpp	/^NullableVector<AstAtom*> getInlinedAtom(AstProgram& program, AstAtom& atom) {$/;"	f	namespace:souffle
getInlinedClause	InlineRelationsTransformer.cpp	/^std::vector<AstClause*> getInlinedClause(AstProgram& program, const AstClause& clause) {$/;"	f	namespace:souffle
getInlinedLiteral	InlineRelationsTransformer.cpp	/^NullableVector<std::vector<AstLiteral*>> getInlinedLiteral(AstProgram& program, AstLiteral* lit) {$/;"	f	namespace:souffle
getInput	profile/UserInputReader.h	/^    std::string getInput() {$/;"	f	class:souffle::profile::InputReader
getInputColumnMap	ReadStreamCSV.h	/^    std::map<int, int> getInputColumnMap(const IODirectives& ioDirectives, const unsigned arity) const {$/;"	f	class:souffle::ReadStreamCSV
getInputFileDir	CompiledOptions.h	/^    const std::string& getInputFileDir() const {$/;"	f	class:souffle::CmdOptions
getInputIODirectives	AstTranslator.cpp	/^std::vector<IODirectives> AstTranslator::getInputIODirectives($/;"	f	class:souffle::AstTranslator
getInputRelations	SouffleInterface.h	/^    std::vector<Relation*> getInputRelations() const {$/;"	f	class:souffle::SouffleProgram
getInstance	CompiledSouffle.h	/^inline souffle::SouffleProgram* getInstance(const char* p) {$/;"	f
getInstance	IOSystem.h	/^    static IOSystem& getInstance() {$/;"	f	class:souffle::IOSystem
getInstanceName	AstComponent.h	/^    const std::string& getInstanceName() const {$/;"	f	class:souffle::AstComponentInit
getInstantiatedContent	ComponentModel.cpp	/^ComponentContent getInstantiatedContent(const AstComponentInit& componentInit,$/;"	f	namespace:souffle::__anon73
getInstantiations	AstComponent.h	/^    std::vector<AstComponentInit*> getInstantiations() const {$/;"	f	class:souffle::AstComponent
getInternalInputRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getInternalInputRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getInternalNonOutputRelationsWithExternalSuccessors	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getInternalNonOutputRelationsWithExternalSuccessors($/;"	f	class:souffle::SCCGraph
getInternalOutputRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getInternalOutputRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getInternalRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getInternalRelations(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getInternalRelations	SouffleInterface.h	/^    std::vector<Relation*> getInternalRelations() const {$/;"	f	class:souffle::SouffleProgram
getInternalRelationsWithExternalSuccessors	PrecedenceGraph.h	/^    const std::set<const AstRelation*> getInternalRelationsWithExternalSuccessors(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getInterval	ProfileEvent.h	/^        uint32_t getInterval() {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
getIterationNumber	Interpreter.h	/^    size_t getIterationNumber() const {$/;"	f	class:souffle::Interpreter
getIterations	profile/Relation.h	/^    const std::vector<std::shared_ptr<Iteration>>& getIterations() const {$/;"	f	class:souffle::profile::Relation
getIterator	Brie.h	/^        iter_type& getIterator() {$/;"	f	class:souffle::Trie::iterator_core
getIterator	Brie.h	/^        store_iter_t& getIterator() {$/;"	f	class:souffle::Trie::iterator_core
getKey	ProfileDatabase.h	/^    const std::string& getKey() const {$/;"	f	class:souffle::profile::Entry
getKey	RamExistenceCheckAnalysis.cpp	/^SearchColumns RamExistenceCheckAnalysis::getKey(const RamExistenceCheck* existCheck) const {$/;"	f	class:souffle::RamExistenceCheckAnalysis
getKey	RamProvenanceExistenceCheckAnalysis.cpp	/^SearchColumns RamProvenanceExistenceCheckAnalysis::getKey($/;"	f	class:souffle::RamProvenanceExistenceCheckAnalysis
getKeys	ProfileDatabase.h	/^    const std::set<std::string> getKeys() const {$/;"	f	class:souffle::profile::DirectoryEntry
getLHS	AstLiteral.h	/^    AstArgument* getLHS() const {$/;"	f	class:souffle::AstBinaryConstraint
getLHS	RamCondition.h	/^    RamExpression* getLHS() const {$/;"	f	class:souffle::RamConstraint
getLHS	RamCondition.h	/^    const RamCondition& getLHS() const {$/;"	f	class:souffle::RamConjunction
getLeaf	Brie.h	/^    inline Cell& getLeaf(index_type i, op_context& ctxt) {$/;"	f	class:souffle::SparseArray
getLeastCommonSupertypes	TypeSystem.cpp	/^TypeSet getLeastCommonSupertypes(const Type& a, const Type& b) {$/;"	f	namespace:souffle
getLeastCommonSupertypes	TypeSystem.cpp	/^TypeSet getLeastCommonSupertypes(const TypeSet& a, const TypeSet& b) {$/;"	f	namespace:souffle
getLeastCommonSupertypes	TypeSystem.cpp	/^TypeSet getLeastCommonSupertypes(const TypeSet& set) {$/;"	f	namespace:souffle
getLeastCommonSupertypes	TypeSystem.h	/^TypeSet getLeastCommonSupertypes(const Types&... types) {$/;"	f	namespace:souffle
getLevel	RamConditionLevel.cpp	/^size_t RamConditionLevelAnalysis::getLevel(const RamCondition* condition) const {$/;"	f	class:souffle::RamConditionLevelAnalysis
getLevel	RamExpressionLevel.cpp	/^size_t RamExpressionLevelAnalysis::getLevel(const RamExpression* value) const {$/;"	f	class:souffle::RamExpressionLevelAnalysis
getLevel	RamOperation.cpp	/^size_t getLevel(const RamCondition* condition) {$/;"	f	namespace:souffle
getLevel	RamOperation.cpp	/^size_t getLevel(const RamExpression* value) {$/;"	f	namespace:souffle
getLevelMask	Brie.h	/^    static index_type getLevelMask(unsigned level) {$/;"	f	class:souffle::SparseArray
getLexOrder	IndexSetAnalysis.h	/^    const LexicographicalOrder getLexOrder(SearchColumns cols) const {$/;"	f	class:souffle::IndexSet
getLoads	AstComponent.h	/^    std::vector<AstLoad*> getLoads() const {$/;"	f	class:souffle::AstComponent
getLoads	AstProgram.cpp	/^const std::vector<std::unique_ptr<AstLoad>>& AstProgram::getLoads() const {$/;"	f	class:souffle::AstProgram
getLoads	AstRelation.h	/^    std::vector<AstLoad*> getLoads() const {$/;"	f	class:souffle::AstRelation
getLoadtime	profile/Relation.h	/^    std::chrono::microseconds getLoadtime() const {$/;"	f	class:souffle::profile::Relation
getLocation	ErrorReport.h	/^    const SrcLocation& getLocation() const {$/;"	f	class:souffle::DiagnosticMessage
getLocator	profile/Iteration.h	/^    const std::string& getLocator() const {$/;"	f	class:souffle::profile::Iteration
getLocator	profile/Relation.h	/^    const std::string& getLocator() const {$/;"	f	class:souffle::profile::Relation
getLocator	profile/Rule.h	/^    std::string getLocator() const {$/;"	f	class:souffle::profile::Rule
getMain	RamProgram.h	/^    RamStatement* getMain() const {$/;"	f	class:souffle::RamProgram
getMainIndex	CompiledRelation.h	/^    const main_index_type& getMainIndex() const {$/;"	f	class:souffle::ram::detail::GenericRelation
getMainIndex	CompiledRelation.h	/^    main_index_type& getMainIndex() {$/;"	f	class:souffle::ram::detail::GenericRelation
getMatch	IndexSetAnalysis.cpp	/^SearchColumns MaxMatching::getMatch(SearchColumns v) {$/;"	f	class:souffle::MaxMatching
getMaxRSSDiff	profile/Relation.h	/^    size_t getMaxRSSDiff() const {$/;"	f	class:souffle::profile::Relation
getMaxVersion	AstClause.h	/^    const int getMaxVersion() const {$/;"	f	class:souffle::AstExecutionPlan
getMemoryUsage	BTree.h	/^        size_type getMemoryUsage() const {$/;"	f	struct:souffle::detail::btree::node
getMemoryUsage	BTree.h	/^    size_type getMemoryUsage() const {$/;"	f	class:souffle::detail::btree
getMemoryUsage	Brie.h	/^    static std::size_t getMemoryUsage(const Node* node, int level) {$/;"	f	class:souffle::SparseArray
getMemoryUsage	Brie.h	/^    std::size_t getMemoryUsage() const {$/;"	f	class:souffle::SparseArray
getMemoryUsage	Brie.h	/^    std::size_t getMemoryUsage() const {$/;"	f	class:souffle::SparseBitMap
getMemoryUsage	Brie.h	/^    std::size_t getMemoryUsage() const {$/;"	f	class:souffle::Trie
getMessage	ErrorReport.h	/^    const std::string& getMessage() const {$/;"	f	class:souffle::DiagnosticMessage
getMessage	RamStatement.h	/^    const std::string& getMessage() const {$/;"	f	class:souffle::RamDebugInfo
getMessage	RamStatement.h	/^    const std::string& getMessage() const {$/;"	f	class:souffle::RamLogSize
getMessage	RamStatement.h	/^    const std::string& getMessage() const {$/;"	f	class:souffle::RamLogTimer
getModifiableType	TypeSystem.cpp	/^Type* TypeEnvironment::getModifiableType(const identifier& name) {$/;"	f	class:souffle::TypeEnvironment
getName	AstArgument.h	/^    const std::string& getName() const {$/;"	f	class:souffle::AstUserDefinedFunctor
getName	AstArgument.h	/^    const std::string& getName() const {$/;"	f	class:souffle::AstVariable
getName	AstComponent.h	/^    const std::string& getName() const {$/;"	f	class:souffle::AstComponentType
getName	AstFunctorDeclaration.h	/^    const std::string& getName() const {$/;"	f	class:souffle::AstFunctorDeclaration
getName	AstIO.h	/^    const AstRelationIdentifier& getName() const {$/;"	f	class:souffle::AstIO
getName	AstLiteral.h	/^    const AstRelationIdentifier& getName() const {$/;"	f	class:souffle::AstAtom
getName	AstRelation.h	/^    const AstRelationIdentifier& getName() const {$/;"	f	class:souffle::AstRelation
getName	AstRelationIdentifier.h	/^    std::string getName() const {$/;"	f	class:souffle::AstRelationIdentifier
getName	AstType.h	/^    const AstTypeIdentifier& getName() const {$/;"	f	class:souffle::AstType
getName	CompiledRelation.h	/^    const char* getName() {$/;"	f	struct:souffle::ram::detail::std_set_config
getName	CompiledRelation.h	/^    const char* getName() {$/;"	f	struct:souffle::ram::detail::std_unordered_config
getName	MagicSet.h	/^    AstRelationIdentifier getName() const {$/;"	f	class:souffle::AdornedPredicate
getName	RamExpression.h	/^    const std::string& getName() const {$/;"	f	class:souffle::RamUserDefinedOperator
getName	RamRelation.h	/^    const std::string& getName() const {$/;"	f	class:souffle::RamRelation
getName	TypeSystem.h	/^    const AstTypeIdentifier& getName() const {$/;"	f	class:souffle::Type
getName	profile/Relation.h	/^    std::string getName() const {$/;"	f	class:souffle::profile::Relation
getName	profile/Rule.h	/^    std::string getName() const {$/;"	f	class:souffle::profile::Rule
getNames	AstIO.h	/^    const std::set<AstRelationIdentifier>& getNames() const {$/;"	f	class:souffle::AstIO
getNames	AstRelationIdentifier.h	/^    const std::vector<std::string>& getNames() const {$/;"	f	class:souffle::AstRelationIdentifier
getNames	AstType.h	/^    const std::vector<std::string>& getNames() const {$/;"	f	class:souffle::AstTypeIdentifier
getNegatedAtoms	MagicSet.h	/^    const std::set<AstRelationIdentifier>& getNegatedAtoms() const {$/;"	f	class:souffle::Adornment
getNegations	AstClause.h	/^    std::vector<AstNegation*> getNegations() const {$/;"	f	class:souffle::AstClause
getNested	Brie.h	/^        nested_iter_core& getNested() {$/;"	f	class:souffle::Trie::iterator_core
getNewAddressLabel	Interpreter.h	/^       size_t getNewAddressLabel() { return currentAddressLabel++; }$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
getNewIndexScanIterator	Interpreter.h	/^       size_t getNewIndexScanIterator() {return indexScanIteratorIndex++; }$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
getNewScanIterator	Interpreter.h	/^       size_t getNewScanIterator() {return scanIteratorIndex++; }$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
getNextAtomMaxBoundSIPS	MagicSet.cpp	/^int getNextAtomMaxBoundSIPS(std::vector<AstAtom*>& atoms, const std::set<std::string>& boundArgs,$/;"	f	namespace:souffle
getNextAtomMaxRatioSIPS	MagicSet.cpp	/^int getNextAtomMaxRatioSIPS(std::vector<AstAtom*>& atoms, const std::set<std::string>& boundArgs,$/;"	f	namespace:souffle
getNextAtomNaiveSIPS	MagicSet.cpp	/^int getNextAtomNaiveSIPS(std::vector<AstAtom*> atoms, const std::set<std::string>& boundArgs,$/;"	f	namespace:souffle
getNextAtomSIPS	MagicSet.cpp	/^int getNextAtomSIPS(std::vector<AstAtom*>& atoms, std::set<std::string> boundArgs,$/;"	f	namespace:souffle
getNextEdbName	MagicSet.cpp	/^std::string getNextEdbName(AstProgram* program) {$/;"	f	namespace:souffle
getNodeType	RamNode.h	/^    RamNodeType getNodeType() const {$/;"	f	class:souffle::RamNode
getNonRecTime	profile/Relation.h	/^    std::chrono::microseconds getNonRecTime() const {$/;"	f	class:souffle::profile::Relation
getNull	CompiledRecord.h	/^RamDomain getNull() {$/;"	f	namespace:souffle
getNull	InterpreterRecords.cpp	/^RamDomain getNull() {$/;"	f	namespace:souffle
getNumElements	BTree.h	/^        size_type getNumElements() const {$/;"	f	struct:souffle::detail::btree::base
getNumErrors	ErrorReport.h	/^    unsigned getNumErrors() const {$/;"	f	class:souffle::ErrorReport
getNumIssues	ErrorReport.h	/^    unsigned getNumIssues() const {$/;"	f	class:souffle::ErrorReport
getNumJobs	CompiledOptions.h	/^    size_t getNumJobs() const {$/;"	f	class:souffle::CmdOptions
getNumMatchings	IndexSetAnalysis.h	/^    int getNumMatchings() const {$/;"	f	class:souffle::MaxMatching
getNumMatchings	test/matching_test.cpp	/^    int getNumMatchings() {$/;"	f	class:TestAutoIndex
getNumNodes	BTree.h	/^    size_type getNumNodes() const {$/;"	f	class:souffle::detail::btree
getNumWarnings	ErrorReport.h	/^    unsigned getNumWarnings() const {$/;"	f	class:souffle::ErrorReport
getNumber	AstArgument.h	/^    size_t getNumber() const {$/;"	f	class:souffle::AstSubroutineArgument
getNumberOfSCCs	PrecedenceGraph.h	/^    size_t getNumberOfSCCs() const {$/;"	f	class:souffle::SCCGraph
getNumberType	TypeSystem.h	/^    const Type& getNumberType() const {$/;"	f	class:souffle::TypeEnvironment
getOpContextName	Synthesiser.cpp	/^const std::string Synthesiser::getOpContextName(const RamRelation& rel) {$/;"	f	class:souffle::Synthesiser
getOperand	RamCondition.h	/^    const RamCondition& getOperand() const {$/;"	f	class:souffle::RamNegation
getOperation	RamOperation.h	/^    RamOperation& getOperation() const {$/;"	f	class:souffle::RamNestedOperation
getOperation	RamStatement.h	/^    const RamOperation& getOperation() const {$/;"	f	class:souffle::RamQuery
getOperator	AstArgument.h	/^    Op getOperator() const {$/;"	f	class:souffle::AstAggregator
getOperator	AstLiteral.h	/^    BinaryConstraintOp getOperator() const {$/;"	f	class:souffle::AstBinaryConstraint
getOperator	RamCondition.h	/^    BinaryConstraintOp getOperator() const {$/;"	f	class:souffle::RamConstraint
getOperator	RamExpression.h	/^    FunctorOp getOperator() const {$/;"	f	class:souffle::RamIntrinsicOperator
getOrder	AstClause.h	/^    const std::vector<unsigned int>& getOrder() const {$/;"	f	class:souffle::AstExecutionOrder
getOrderFor	AstClause.h	/^    const AstExecutionOrder& getOrderFor(int version) const {$/;"	f	class:souffle::AstExecutionPlan
getOrdering	MagicSet.h	/^    std::vector<unsigned int> getOrdering() const {$/;"	f	class:souffle::AdornedClause
getOrders	AstClause.h	/^    std::map<int, const AstExecutionOrder*> getOrders() const {$/;"	f	class:souffle::AstExecutionPlan
getOrphanClauses	AstProgram.h	/^    std::vector<AstClause*> getOrphanClauses() const {$/;"	f	class:souffle::AstProgram
getOutputFileDir	CompiledOptions.h	/^    const std::string& getOutputFileDir() const {$/;"	f	class:souffle::CmdOptions
getOutputIODirectives	AstTranslator.cpp	/^std::vector<IODirectives> AstTranslator::getOutputIODirectives($/;"	f	class:souffle::AstTranslator
getOutputLock	ParallelUtils.h	/^inline Lock& getOutputLock() {$/;"	f	namespace:souffle::souffle
getOutputRelations	SouffleInterface.h	/^    std::vector<Relation*> getOutputRelations() const {$/;"	f	class:souffle::SouffleProgram
getOverridden	AstComponent.h	/^    const std::set<std::string>& getOverridden() const {$/;"	f	class:souffle::AstComponent
getP	RamTranslationUnit.h	/^    const RamProgram& getP() const {$/;"	f	class:souffle::RamTranslationUnit
getParent	BTree.h	/^        node* getParent() const {$/;"	f	struct:souffle::detail::btree::base
getPattern	RamOperation.h	/^    std::vector<RamExpression*> getPattern() const {$/;"	f	class:souffle::RamAggregate
getPositionInParent	BTree.h	/^        field_index_type getPositionInParent() const {$/;"	f	struct:souffle::detail::btree::base
getPragmaDirectives	AstProgram.cpp	/^const std::vector<std::unique_ptr<AstPragma>>& AstProgram::getPragmaDirectives() const {$/;"	f	class:souffle::AstProgram
getPredecessorSCCs	PrecedenceGraph.h	/^    const std::set<size_t> getPredecessorSCCs(const AstRelation* relation) const {$/;"	f	class:souffle::SCCGraph
getPredecessorSCCs	PrecedenceGraph.h	/^    const std::set<size_t>& getPredecessorSCCs(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getPrimaryMessage	ErrorReport.h	/^    const DiagnosticMessage& getPrimaryMessage() const {$/;"	f	class:souffle::Diagnostic
getPrintSizes	AstComponent.h	/^    std::vector<AstPrintSize*> getPrintSizes() const {$/;"	f	class:souffle::AstComponent
getProfileName	CompiledOptions.h	/^    const std::string& getProfileName() const {$/;"	f	class:souffle::CmdOptions
getProfileText	RamOperation.h	/^    const std::string& getProfileText() const {$/;"	f	class:souffle::RamNestedOperation
getProgram	AstTranslationUnit.h	/^    AstProgram* getProgram() {$/;"	f	class:souffle::AstTranslationUnit
getProgram	AstTranslationUnit.h	/^    const AstProgram* getProgram() const {$/;"	f	class:souffle::AstTranslationUnit
getProgram	RamTranslationUnit.h	/^    RamProgram* getProgram() {$/;"	f	class:souffle::RamTranslationUnit
getProgram	RamTranslationUnit.h	/^    const RamProgram* getProgram() const {$/;"	f	class:souffle::RamTranslationUnit
getProgramRun	profile/OutputProcessor.h	/^    const std::shared_ptr<ProgramRun>& getProgramRun() const {$/;"	f	class:souffle::profile::OutputProcessor
getQualifier	AstRelation.h	/^    int getQualifier() const {$/;"	f	class:souffle::AstRelation
getRHS	AstLiteral.h	/^    AstArgument* getRHS() const {$/;"	f	class:souffle::AstBinaryConstraint
getRHS	RamCondition.h	/^    RamExpression* getRHS() const {$/;"	f	class:souffle::RamConstraint
getRHS	RamCondition.h	/^    const RamCondition& getRHS() const {$/;"	f	class:souffle::RamConjunction
getRamRelation	SynthesiserRelation.h	/^    const RamRelation& getRamRelation() const {$/;"	f	class:souffle::SynthesiserRelation
getRangePattern	RamOperation.h	/^    std::vector<RamExpression*> getRangePattern() const {$/;"	f	class:souffle::RamIndexScan
getRangeQueryColumns	RamIndexScanKeys.cpp	/^SearchColumns RamIndexScanKeysAnalysis::getRangeQueryColumns(const RamIndexScan* scan) const {$/;"	f	class:souffle::RamIndexScanKeysAnalysis
getRangeQueryColumns	RamOperation.h	/^    SearchColumns getRangeQueryColumns() const {$/;"	f	class:souffle::RamAggregate
getReader	IOSystem.h	/^    std::unique_ptr<ReadStream> getReader(const std::vector<bool>& symbolMask, SymbolTable& symbolTable,$/;"	f	class:souffle::IOSystem
getReads	profile/Relation.h	/^    size_t getReads() const {$/;"	f	class:souffle::profile::Relation
getRecTime	profile/Relation.h	/^    std::chrono::microseconds getRecTime() const {$/;"	f	class:souffle::profile::Relation
getRecordMap	CompiledRecord.h	/^RecordMap<Tuple>& getRecordMap() {$/;"	f	namespace:souffle::detail
getRecords	AstUtils.cpp	/^std::vector<const AstRecordInit*> getRecords(const AstNode& root) {$/;"	f	namespace:souffle
getRecords	AstUtils.cpp	/^std::vector<const AstRecordInit*> getRecords(const AstNode* root) {$/;"	f	namespace:souffle
getRedundantRelations	PrecedenceGraph.h	/^    const std::set<const AstRelation*>& getRedundantRelations() const {$/;"	f	class:souffle::RedundantRelations
getReferenceLevel	RamOperation.h	/^    std::size_t getReferenceLevel() const {$/;"	f	class:souffle::RamUnpackRecord
getReferencePosition	RamOperation.h	/^    std::size_t getReferencePosition() const {$/;"	f	class:souffle::RamUnpackRecord
getReferencedRelations	Synthesiser.cpp	/^std::set<const RamRelation*> Synthesiser::getReferencedRelations(const RamOperation& op) {$/;"	f	class:souffle::Synthesiser
getRelTable	profile/OutputProcessor.h	/^Table inline OutputProcessor::getRelTable() const {$/;"	f	class:souffle::profile::OutputProcessor
getRelation	AstProgram.cpp	/^AstRelation* AstProgram::getRelation(const AstRelationIdentifier& name) const {$/;"	f	class:souffle::AstProgram
getRelation	IndexSetAnalysis.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::IndexSet
getRelation	Interpreter.h	/^    InterpreterRelation& getRelation(const std::string& name) {$/;"	f	class:souffle::Interpreter
getRelation	Interpreter.h	/^    inline InterpreterRelation& getRelation(const RamRelation& id) {$/;"	f	class:souffle::Interpreter
getRelation	Interpreter.h	/^   InterpreterRelation& getRelation(const std::string& name) {$/;"	f	class:souffle::LowLevelMachine
getRelation	RamCondition.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamAbstractExistenceCheck
getRelation	RamCondition.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamEmptinessCheck
getRelation	RamOperation.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamAggregate
getRelation	RamOperation.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamProject
getRelation	RamOperation.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamRelationSearch
getRelation	RamProgram.h	/^    const RamRelation* getRelation(const std::string& name) const {$/;"	f	class:souffle::RamProgram
getRelation	RamStatement.h	/^    const RamRelation& getRelation() const {$/;"	f	class:souffle::RamRelationStatement
getRelation	RamStatement.h	/^    const RamRelation* getRelation() const {$/;"	f	class:souffle::RamLogTimer
getRelation	SouffleInterface.h	/^    Relation* getRelation(const std::string& name) const {$/;"	f	class:souffle::SouffleProgram
getRelation	profile/ProgramRun.h	/^    const Relation* getRelation(const std::string& name) const {$/;"	f	class:souffle::profile::ProgramRun
getRelationMap	Interpreter.h	/^    relation_map& getRelationMap() const {$/;"	f	class:souffle::Interpreter
getRelationMap	profile/ProgramRun.h	/^    inline const std::unordered_map<std::string, std::shared_ptr<Relation>>& getRelationMap() const {$/;"	f	class:souffle::profile::ProgramRun
getRelationName	AstTranslator.h	/^    std::string getRelationName(const AstRelationIdentifier& id) {$/;"	f	class:souffle::AstTranslator
getRelationName	IODirectives.h	/^    const std::string& getRelationName() const {$/;"	f	class:souffle::IODirectives
getRelationName	Synthesiser.cpp	/^const std::string Synthesiser::getRelationName(const RamRelation& rel) {$/;"	f	class:souffle::Synthesiser
getRelationName	Synthesiser.cpp	/^const std::string Synthesiser::getRelationName(const std::string& relName) {$/;"	f	class:souffle::Synthesiser
getRelationOutput	ExplainProvenance.h	/^    virtual std::string getRelationOutput(const std::string& relName) {$/;"	f	class:souffle::ExplainProvenance
getRelationSize	AstProfileUse.cpp	/^size_t AstProfileUse::getRelationSize(const AstRelationIdentifier& rel) {$/;"	f	class:souffle::AstProfileUse
getRelations	AstComponent.h	/^    std::vector<AstRelation*> getRelations() const {$/;"	f	class:souffle::AstComponent
getRelations	AstProgram.cpp	/^std::vector<AstRelation*> AstProgram::getRelations() const {$/;"	f	class:souffle::AstProgram
getRelations	MagicSet.h	/^    const std::vector<AstRelationIdentifier>& getRelations() const {$/;"	f	class:souffle::Adornment
getRelationsAtTime	profile/ProgramRun.h	/^    std::set<std::shared_ptr<Relation>> getRelationsAtTime($/;"	f	class:souffle::profile::ProgramRun
getReorderedClause	AstTranslator.cpp	/^std::unique_ptr<AstClause> AstTranslator::ClauseTranslator::getReorderedClause($/;"	f	class:souffle::AstTranslator::ClauseTranslator
getRepresentation	AstRelation.h	/^    RelationRepresentation getRepresentation() const {$/;"	f	class:souffle::AstRelation
getRepresentation	RamRelation.h	/^    const RelationRepresentation getRepresentation() const {$/;"	f	class:souffle::RamRelation
getReturnErrors	InterpreterContext.h	/^    std::vector<bool>& getReturnErrors() const {$/;"	f	class:souffle::InterpreterContext
getReturnValues	InterpreterContext.h	/^    std::vector<RamDomain>& getReturnValues() const {$/;"	f	class:souffle::InterpreterContext
getRootInfo	Brie.h	/^    RootInfoSnapshot getRootInfo() const {$/;"	f	class:souffle::SparseArray
getRootVersion	Brie.h	/^    uint64_t getRootVersion() const {$/;"	f	class:souffle::SparseArray
getRows	profile/Table.h	/^    inline std::vector<std::shared_ptr<Row>> getRows() {$/;"	f	class:souffle::profile::Table
getRulTable	profile/OutputProcessor.h	/^Table inline OutputProcessor::getRulTable() const {$/;"	f	class:souffle::profile::OutputProcessor
getRuleMap	profile/Relation.h	/^    const std::unordered_map<std::string, std::shared_ptr<Rule>>& getRuleMap() const {$/;"	f	class:souffle::profile::Relation
getRuleRecList	profile/Relation.h	/^    std::vector<std::shared_ptr<Rule>> getRuleRecList() const {$/;"	f	class:souffle::profile::Relation
getRules	profile/Iteration.h	/^    const std::unordered_map<std::string, std::shared_ptr<Rule>>& getRules() const {$/;"	f	class:souffle::profile::Iteration
getRuntime	profile/Iteration.h	/^    std::chrono::microseconds getRuntime() const {$/;"	f	class:souffle::profile::Iteration
getRuntime	profile/ProgramRun.h	/^    std::string getRuntime() const {$/;"	f	class:souffle::profile::ProgramRun
getRuntime	profile/Rule.h	/^    std::chrono::microseconds getRuntime() const {$/;"	f	class:souffle::profile::Rule
getSCC	PrecedenceGraph.h	/^    const size_t getSCC(const AstRelation* rel) const {$/;"	f	class:souffle::SCCGraph
getSavetime	profile/Relation.h	/^    std::chrono::microseconds getSavetime() const {$/;"	f	class:souffle::profile::Relation
getSearches	IndexSetAnalysis.h	/^    const SearchSet& getSearches() const {$/;"	f	class:souffle::IndexSet
getSecondHalf	profile/HtmlGenerator.h	/^    static std::string getSecondHalf() {$/;"	f	class:souffle::profile::HtmlGenerator
getSecondRelation	RamStatement.h	/^    const RamRelation& getSecondRelation() const {$/;"	f	class:souffle::RamSwap
getSignature	SouffleInterface.h	/^    std::string getSignature() {$/;"	f	class:souffle::Relation
getSingleton	CompiledRelation.h	/^        static const tuple_type& getSingleton() {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
getSipsFunction	ReorderLiteralsTransformer.cpp	/^sips_t getSipsFunction(const std::string& sipsChosen) {$/;"	f	namespace:souffle
getSize	ExplainTree.h	/^    size_t getSize() {$/;"	f	class:souffle::TreeNode
getSize	ProfileDatabase.h	/^    size_t getSize() const {$/;"	f	class:souffle::profile::SizeEntry
getSourceFileName	CompiledOptions.h	/^    const std::string& getSourceFileName() const {$/;"	f	class:souffle::CmdOptions
getSourceRelation	RamStatement.h	/^    const RamRelation& getSourceRelation() const {$/;"	f	class:souffle::RamMerge
getSourceStratum	RamStatement.h	/^    const int getSourceStratum() const {$/;"	f	class:souffle::RamRecv
getSplitPoint	BTree.h	/^        int getSplitPoint(int \/*unused*\/) {$/;"	f	struct:souffle::detail::btree::node
getSrcLoc	AstNode.h	/^    SrcLocation getSrcLoc() const {$/;"	f	class:souffle::AstNode
getStart	ProfileDatabase.h	/^    microseconds getStart() const {$/;"	f	class:souffle::profile::DurationEntry
getStarttime	profile/Iteration.h	/^    std::chrono::microseconds getStarttime() const {$/;"	f	class:souffle::profile::Iteration
getStarttime	profile/ProgramRun.h	/^    std::chrono::microseconds getStarttime() const {$/;"	f	class:souffle::profile::ProgramRun
getStarttime	profile/Relation.h	/^    std::chrono::microseconds getStarttime() const {$/;"	f	class:souffle::profile::Relation
getStarttime	profile/Rule.h	/^    std::chrono::microseconds getStarttime() const {$/;"	f	class:souffle::profile::Rule
getStatement	RamStatement.h	/^    const RamStatement& getStatement() const {$/;"	f	class:souffle::RamDebugInfo
getStatement	RamStatement.h	/^    const RamStatement& getStatement() const {$/;"	f	class:souffle::RamLogTimer
getStatements	RamStatement.h	/^    std::vector<RamStatement*> getStatements() const {$/;"	f	class:souffle::RamParallel
getStatements	RamStatement.h	/^    std::vector<RamStatement*> getStatements() const {$/;"	f	class:souffle::RamSequence
getStore	Brie.h	/^    const data_store_t& getStore() const {$/;"	f	class:souffle::SparseBitMap
getStore	Brie.h	/^    const map_type& getStore() const {$/;"	f	class:souffle::Trie
getStore	Brie.h	/^    const store_type& getStore() const {$/;"	f	class:souffle::Trie
getStores	AstComponent.h	/^    std::vector<AstStore*> getStores() const {$/;"	f	class:souffle::AstComponent
getStores	AstProgram.cpp	/^const std::vector<std::unique_ptr<AstStore>>& AstProgram::getStores() const {$/;"	f	class:souffle::AstProgram
getStores	AstRelation.h	/^    std::vector<AstStore*> getStores() const {$/;"	f	class:souffle::AstRelation
getStratumIndex	CompiledOptions.h	/^    size_t getStratumIndex() const {$/;"	f	class:souffle::CmdOptions
getString	ExplainTree.h	/^    std::string getString() {$/;"	f	class:souffle::ScreenBuffer
getString	MagicSet.cpp	/^std::string getString(const AstArgument* arg) {$/;"	f	namespace:souffle
getSubroutine	RamProgram.h	/^    const RamStatement& getSubroutine(const std::string& name) const {$/;"	f	class:souffle::RamProgram
getSubroutines	RamProgram.h	/^    const std::map<std::string, RamStatement*> getSubroutines() const {$/;"	f	class:souffle::RamProgram
getSubrulTable	profile/OutputProcessor.h	/^Table inline OutputProcessor::getSubrulTable(std::string strRel, std::string strRul) const {$/;"	f	class:souffle::profile::OutputProcessor
getSuccessorSCCs	PrecedenceGraph.h	/^    const std::set<size_t> getSuccessorSCCs(const AstRelation* relation) const {$/;"	f	class:souffle::SCCGraph
getSuccessorSCCs	PrecedenceGraph.h	/^    const std::set<size_t>& getSuccessorSCCs(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
getSymbolForFunctorOp	FunctorOps.h	/^inline std::string getSymbolForFunctorOp(FunctorOp op) {$/;"	f	namespace:souffle
getSymbolTable	AstTranslationUnit.h	/^    const souffle::SymbolTable& getSymbolTable() const {$/;"	f	class:souffle::AstTranslationUnit
getSymbolTable	AstTranslationUnit.h	/^    souffle::SymbolTable& getSymbolTable() {$/;"	f	class:souffle::AstTranslationUnit
getSymbolTable	Interpreter.h	/^    SymbolTable& getSymbolTable() {$/;"	f	class:souffle::Interpreter
getSymbolTable	ParserDriver.cpp	/^souffle::SymbolTable& ParserDriver::getSymbolTable() {$/;"	f	class:souffle::ParserDriver
getSymbolTable	RamTranslationUnit.h	/^    souffle::SymbolTable& getSymbolTable() const {$/;"	f	class:souffle::RamTranslationUnit
getSymbolTableID	WriteStreamSQLite.h	/^    uint64_t getSymbolTableID(int index) {$/;"	f	class:souffle::WriteStreamSQLite
getSymbolTableIDFromDB	WriteStreamSQLite.h	/^    uint64_t getSymbolTableIDFromDB(int index) {$/;"	f	class:souffle::WriteStreamSQLite
getSymbolType	TypeSystem.h	/^    const Type& getSymbolType() const {$/;"	f	class:souffle::TypeEnvironment
getSynthesiserRelation	SynthesiserRelation.cpp	/^std::unique_ptr<SynthesiserRelation> SynthesiserRelation::getSynthesiserRelation($/;"	f	class:souffle::SynthesiserRelation
getTargetExpression	AstArgument.h	/^    const AstArgument* getTargetExpression() const {$/;"	f	class:souffle::AstAggregator
getTargetRelation	RamStatement.h	/^    const RamRelation& getTargetRelation() const {$/;"	f	class:souffle::RamMerge
getTermWidth	profile/Tui.h	/^    uint32_t getTermWidth() {$/;"	f	namespace:souffle::profile
getTest	test/test.h	/^    const std::string& getTest() const {$/;"	f	class:TestCase
getText	ProfileDatabase.h	/^    const std::string& getText() const {$/;"	f	class:souffle::profile::TextEntry
getTime	ProfileDatabase.h	/^    microseconds getTime() const {$/;"	f	class:souffle::profile::DurationEntry::TimeEntry
getTotalCopyTime	profile/ProgramRun.h	/^    std::chrono::microseconds getTotalCopyTime() const {$/;"	f	class:souffle::profile::ProgramRun
getTotalIndexKey	InterpreterRelation.h	/^    SearchColumns getTotalIndexKey() const {$/;"	f	class:souffle::InterpreterRelation
getTotalLoadtime	profile/ProgramRun.h	/^    std::chrono::microseconds getTotalLoadtime() const {$/;"	f	class:souffle::profile::ProgramRun
getTotalRecursiveRuleSize	profile/Relation.h	/^    size_t getTotalRecursiveRuleSize() const {$/;"	f	class:souffle::profile::Relation
getTotalRecursiveSize	profile/ProgramRun.h	/^    size_t getTotalRecursiveSize() const {$/;"	f	class:souffle::profile::ProgramRun
getTotalSavetime	profile/ProgramRun.h	/^    std::chrono::microseconds getTotalSavetime() const {$/;"	f	class:souffle::profile::ProgramRun
getTotalSize	profile/ProgramRun.h	/^    size_t getTotalSize() const {$/;"	f	class:souffle::profile::ProgramRun
getTotalTime	profile/ProgramRun.h	/^    std::chrono::microseconds getTotalTime() const {$/;"	f	class:souffle::profile::ProgramRun
getTranslationUnit	Interpreter.h	/^    RamTranslationUnit& getTranslationUnit() {$/;"	f	class:souffle::Interpreter
getTranslationUnit	Interpreter.h	/^   RamTranslationUnit& getTranslationUnit() {$/;"	f	class:souffle::LowLevelMachine
getTranslationUnit	Synthesiser.h	/^    RamTranslationUnit& getTranslationUnit() {$/;"	f	class:souffle::Synthesiser
getTrue	AstParserUtils.cpp	/^RuleBody RuleBody::getTrue() {$/;"	f	class:souffle::RuleBody
getType	AstArgument.h	/^    const std::string& getType() const {$/;"	f	class:souffle::AstTypeCast
getType	AstFunctorDeclaration.h	/^    const std::string& getType() const {$/;"	f	class:souffle::AstFunctorDeclaration
getType	AstProgram.cpp	/^const AstType* AstProgram::getType(const AstTypeIdentifier& name) const {$/;"	f	class:souffle::AstProgram
getType	ErrorReport.h	/^    Type getType() const {$/;"	f	class:souffle::Diagnostic
getType	RamExpression.h	/^    const std::string& getType() const {$/;"	f	class:souffle::RamUserDefinedOperator
getType	TypeSystem.cpp	/^const Type& TypeEnvironment::getType(const identifier& ident) const {$/;"	f	class:souffle::TypeEnvironment
getTypeEnvironment	AstTypeEnvironmentAnalysis.h	/^    const TypeEnvironment& getTypeEnvironment() {$/;"	f	class:souffle::TypeEnvironmentAnalysis
getTypeEnvironment	TypeSystem.h	/^    const TypeEnvironment& getTypeEnvironment() const {$/;"	f	class:souffle::Type
getTypeName	AstAttribute.h	/^    const AstTypeIdentifier& getTypeName() const {$/;"	f	class:souffle::AstAttribute
getTypeName	SynthesiserRelation.cpp	/^std::string SynthesiserBrieRelation::getTypeName() {$/;"	f	class:souffle::SynthesiserBrieRelation
getTypeName	SynthesiserRelation.cpp	/^std::string SynthesiserDirectRelation::getTypeName() {$/;"	f	class:souffle::SynthesiserDirectRelation
getTypeName	SynthesiserRelation.cpp	/^std::string SynthesiserEqrelRelation::getTypeName() {$/;"	f	class:souffle::SynthesiserEqrelRelation
getTypeName	SynthesiserRelation.cpp	/^std::string SynthesiserIndirectRelation::getTypeName() {$/;"	f	class:souffle::SynthesiserIndirectRelation
getTypeName	SynthesiserRelation.cpp	/^std::string SynthesiserNullaryRelation::getTypeName() {$/;"	f	class:souffle::SynthesiserNullaryRelation
getTypeParameters	AstComponent.h	/^    const std::vector<AstTypeIdentifier>& getTypeParameters() const {$/;"	f	class:souffle::AstComponentType
getTypeQualifier	TypeSystem.cpp	/^std::string getTypeQualifier(const Type& type) {$/;"	f	namespace:souffle
getTypes	AstComponent.h	/^    std::vector<AstType*> getTypes() const {$/;"	f	class:souffle::AstComponent
getTypes	AstProgram.cpp	/^std::vector<const AstType*> AstProgram::getTypes() const {$/;"	f	class:souffle::AstProgram
getTypes	AstType.h	/^    const std::vector<AstTypeIdentifier>& getTypes() const {$/;"	f	class:souffle::AstUnionType
getTypes	AstTypeAnalysis.h	/^    TypeSet getTypes(const AstArgument* argument) const {$/;"	f	class:souffle::TypeAnalysis
getUnmatchedKeys	IndexSetAnalysis.h	/^    const SearchSet getUnmatchedKeys(const MaxMatching::Matchings& match, const SearchSet& nodes) {$/;"	f	class:souffle::IndexSet
getUsageStats	profile/Tui.h	/^    std::set<Usage> getUsageStats(size_t width = size_t(-1)) {$/;"	f	namespace:souffle::profile
getValue	AstArgument.h	/^    AstArgument* getValue() const {$/;"	f	class:souffle::AstTypeCast
getValue	RamOperation.h	/^    RamExpression& getValue(size_t i) const {$/;"	f	class:souffle::RamReturn
getValues	RamCondition.h	/^    std::vector<RamExpression*> getValues() const {$/;"	f	class:souffle::RamAbstractExistenceCheck
getValues	RamOperation.h	/^    std::vector<RamExpression*> getValues() const {$/;"	f	class:souffle::RamProject
getValues	RamOperation.h	/^    std::vector<RamExpression*> getValues() const {$/;"	f	class:souffle::RamReturn
getValues	RamStatement.h	/^    std::vector<RamExpression*> getValues() const {$/;"	f	class:souffle::RamFact
getVar	AstConstraintAnalysis.h	/^    AnalysisVar getVar(const AstArgument& arg) {$/;"	f	class:souffle::__anon68::AstConstraintAnalysis
getVar	AstConstraintAnalysis.h	/^    inline AnalysisVar getVar(const AstArgument* arg) {$/;"	f	class:souffle::__anon68::AstConstraintAnalysis
getVariableDependencies	MagicSet.h	/^    const std::set<std::string>& getVariableDependencies(const std::string& argName) const {$/;"	f	class:souffle::BindingStore
getVariableReferences	AstTranslator.h	/^        const variable_reference_map& getVariableReferences() const {$/;"	f	class:souffle::AstTranslator::ValueIndex
getVariables	AstUtils.cpp	/^std::vector<const AstVariable*> getVariables(const AstNode& root) {$/;"	f	namespace:souffle
getVariables	AstUtils.cpp	/^std::vector<const AstVariable*> getVariables(const AstNode* root) {$/;"	f	namespace:souffle
getVector	InlineRelationsTransformer.cpp	/^    const std::vector<T>& getVector() const {$/;"	f	class:souffle::NullableVector
getVersion	profile/Rule.h	/^    int getVersion() const {$/;"	f	class:souffle::profile::Rule
getVersionAtoms	profile/OutputProcessor.h	/^Table inline OutputProcessor::getVersionAtoms(std::string strRel, std::string srcLocator, int version) const {$/;"	f	class:souffle::profile::OutputProcessor
getVersions	profile/OutputProcessor.h	/^Table inline OutputProcessor::getVersions(std::string strRel, std::string strRul) const {$/;"	f	class:souffle::profile::OutputProcessor
getWidth	ExplainTree.h	/^    uint32_t getWidth() const {$/;"	f	class:souffle::TreeNode
getWriter	IOSystem.h	/^    std::unique_ptr<WriteStream> getWriter(const std::vector<bool>& symbolMask,$/;"	f	class:souffle::IOSystem
get_boundaries	Brie.h	/^        CacheAccessCounter get_boundaries;$/;"	m	struct:souffle::detail::TrieBase::hint_statistics
get_first_full_index	CompiledIndexUtils.h	/^struct get_first_full_index<arity, First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
get_first_full_index	CompiledIndexUtils.h	/^struct get_first_full_index<arity, Index> {$/;"	s	namespace:souffle::ram::index_utils
get_full_index	CompiledIndexUtils.h	/^struct get_full_index {$/;"	s	namespace:souffle::ram::index_utils
get_full_index	CompiledIndexUtils.h	/^struct get_full_index<0> {$/;"	s	namespace:souffle::ram::index_utils
get_nested_iter_core	Brie.h	/^    auto operator()(IterCore& core) -> decltype(get_nested_iter_core<Level - 1>()(core.getNested())) {$/;"	f	struct:souffle::detail::get_nested_iter_core
get_nested_iter_core	Brie.h	/^struct get_nested_iter_core {$/;"	s	namespace:souffle::detail
get_nested_iter_core	Brie.h	/^struct get_nested_iter_core<0> {$/;"	s	namespace:souffle::detail
get_next_token	json11.h	/^    char get_next_token() {$/;"	f	struct:json11::__anon66::final
get_prefix	CompiledIndexUtils.h	/^struct get_prefix<L, index<Rest...>> {$/;"	s	namespace:souffle::ram::index_utils
get_prefix_aux	CompiledIndexUtils.h	/^struct get_prefix_aux<0, First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils::detail
get_prefix_aux	CompiledIndexUtils.h	/^struct get_prefix_aux<0> {$/;"	s	namespace:souffle::ram::index_utils::detail
get_prefix_aux	CompiledIndexUtils.h	/^struct get_prefix_aux<L, First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils::detail
getch	profile/UserInputReader.h	/^    void getch() {$/;"	f	class:souffle::profile::InputReader
getkvp	AstPragma.h	/^    std::pair<std::string, std::string> getkvp() const {$/;"	f	class:souffle::AstPragma
globalScopeComponents	ComponentModel.h	/^    std::set<const AstComponent*> globalScopeComponents;$/;"	m	class:souffle::ComponentLookup
gpos	profile/Reader.h	/^    std::streampos gpos;$/;"	m	class:souffle::profile::Reader
graph	IndexSetAnalysis.h	/^    Graph graph;$/;"	m	class:souffle::MaxMatching
graph	PrecedenceGraph.h	/^    const Graph<const AstRelation*, AstNameComparison>& graph() const {$/;"	f	class:souffle::PrecedenceGraph
graphBySize	profile/Tui.h	/^    void graphBySize(std::vector<size_t> list) {$/;"	f	namespace:souffle::profile
graphByTime	profile/Tui.h	/^    void graphByTime(std::vector<std::chrono::microseconds> list) {$/;"	f	namespace:souffle::profile
group	test/test.h	/^    std::string group;  \/\/ group name of test$/;"	m	class:TestCase
grow_parent	BTree.h	/^        void grow_parent(node** root, lock_type& root_lock, node* sibling, std::vector<node*>& locked_nodes) {$/;"	f	struct:souffle::detail::btree::node
gzfstream	gzfstream.h	/^    gzfstream() {$/;"	f	class:souffle::gzfstream::internal::gzfstream
gzfstream	gzfstream.h	/^    gzfstream(const std::string& filename, std::ios_base::openmode mode) {$/;"	f	class:souffle::gzfstream::internal::gzfstream
gzfstream	gzfstream.h	/^class gzfstream : virtual public std::ios {$/;"	c	namespace:souffle::gzfstream::internal
gzfstream	gzfstream.h	/^namespace gzfstream {$/;"	n	namespace:souffle
gzfstreambuf	gzfstream.h	/^    gzfstreambuf() {$/;"	f	class:souffle::gzfstream::internal::gzfstreambuf
gzfstreambuf	gzfstream.h	/^class gzfstreambuf : public std::streambuf {$/;"	c	namespace:souffle::gzfstream::internal
handleMpiMessages	SymbolTable.h	/^    void handleMpiMessages(const size_t count) {$/;"	f	class:souffle::SymbolTable
handler	SignalHandler.h	/^    static void handler(int signal) {$/;"	f	class:souffle::SignalHandler
has	Global.h	/^    bool has(const K& key) const {$/;"	f	class:souffle::BaseTable
has	Global.h	/^    bool has(const K& key, const V& value) const {$/;"	f	class:souffle::BaseTable
has	IODirectives.h	/^    bool has(const std::string& key) const {$/;"	f	class:souffle::IODirectives
hasBoundArgument	MagicSet.cpp	/^bool hasBoundArgument($/;"	f	namespace:souffle
hasClauseWithAggregatedRelation	AstUtils.cpp	/^bool hasClauseWithAggregatedRelation(const AstRelation* relation, const AstRelation* aggRelation,$/;"	f	namespace:souffle
hasClauseWithNegatedRelation	AstUtils.cpp	/^bool hasClauseWithNegatedRelation(const AstRelation* relation, const AstRelation* negRelation,$/;"	f	namespace:souffle
hasFixedExecutionPlan	AstClause.h	/^    bool hasFixedExecutionPlan() const {$/;"	f	class:souffle::AstClause
hasLoc	ErrorReport.h	/^    bool hasLoc;$/;"	m	class:souffle::DiagnosticMessage
hasLocation	ErrorReport.h	/^    bool hasLocation() const {$/;"	f	class:souffle::DiagnosticMessage
hasOrderFor	AstClause.h	/^    bool hasOrderFor(int version) const {$/;"	f	class:souffle::AstExecutionPlan
hasPrefix	MagicSet.cpp	/^bool hasPrefix(const std::string& str, const std::string& prefix) {$/;"	f	namespace:souffle
hasReceivedInput	profile/UserInputReader.h	/^    bool hasReceivedInput() {$/;"	f	class:souffle::profile::InputReader
hasRecordInHead	AstRelation.h	/^    bool hasRecordInHead() const {$/;"	f	class:souffle::AstRelation
hasRelationSize	AstProfileUse.cpp	/^bool AstProfileUse::hasRelationSize(const AstRelationIdentifier& rel) {$/;"	f	class:souffle::AstProfileUse
hasSubsections	DebugReport.h	/^    bool hasSubsections() const {$/;"	f	class:souffle::DebugReportSection
hasUnnamedVariable	AstSemanticChecker.cpp	/^static bool hasUnnamedVariable(const AstArgument* arg) {$/;"	f	namespace:souffle
hasUnnamedVariable	AstSemanticChecker.cpp	/^static bool hasUnnamedVariable(const AstLiteral* lit) {$/;"	f	namespace:souffle
has_shape	json11.h	/^inline bool Json::has_shape(const shape& types, string& err) const {$/;"	f	class:json11::Json
hash	CompiledTuple.h	/^struct hash<souffle::ram::Tuple<Domain, arity>> {$/;"	s	namespace:std
hash	StringPool.h	/^    inline size_t hash(const char* str) {$/;"	f	class:souffle::StringPool
hash	test/btree_multiset_test.cpp	/^struct hash<tuple<A, B>> {$/;"	s	namespace:std	file:
hash	test/btree_set_test.cpp	/^struct hash<tuple<A, B>> {$/;"	s	namespace:std	file:
hashentry	StringPool.h	/^        hashentry(char* s = nullptr, struct hashentry* n = NULL) : str(s), next(n) {}$/;"	f	struct:souffle::StringPool::hashentry
hashentry	StringPool.h	/^    struct hashentry {$/;"	s	class:souffle::StringPool
hashtab	StringPool.h	/^    static hashentry* hashtab[HASH_SIZE];$/;"	m	class:souffle::StringPool
hashtab	scanner.cc	/^    StringPool::hashentry *StringPool::hashtab[HASH_SIZE];$/;"	m	class:StringPool	file:
head	AstClause.h	/^    std::unique_ptr<AstAtom> head;$/;"	m	class:souffle::AstClause
head	Table.h	/^    Block* head;$/;"	m	class:souffle::Table
headAdornment	MagicSet.h	/^    std::string headAdornment;$/;"	m	class:souffle::AdornedClause
height	ExplainTree.h	/^    uint32_t height = 0;  \/\/ height of node (including sub-trees)$/;"	m	class:souffle::TreeNode
height	ExplainTree.h	/^    uint32_t height;  \/\/ height of the screen buffer$/;"	m	class:souffle::ScreenBuffer
help	Global.h	/^    const std::string& help() const {$/;"	f	class:souffle::MainConfig
help	profile/Tui.h	/^    static void help() {$/;"	f	namespace:souffle::profile
hint_statistics	BTree.h	/^    struct hint_statistics {$/;"	s	class:souffle::detail::btree
hint_statistics	Brie.h	/^    struct hint_statistics {$/;"	s	class:souffle::detail::TrieBase
hint_stats	BTree.h	/^    mutable hint_statistics hint_stats;$/;"	m	class:souffle::detail::btree
hint_stats	Brie.h	/^    mutable hint_statistics hint_stats;$/;"	m	class:souffle::detail::TrieBase
hist_pos	profile/UserInputReader.h	/^    size_t hist_pos = 0;$/;"	m	class:souffle::profile::InputReader
history	profile/UserInputReader.h	/^    std::vector<std::string> history;$/;"	m	class:souffle::profile::InputReader
historyDown	profile/UserInputReader.h	/^    void historyDown() {$/;"	f	class:souffle::profile::InputReader
historyUp	profile/UserInputReader.h	/^    void historyUp() {$/;"	f	class:souffle::profile::InputReader
host	Makefile	/^host = x86_64-apple-darwin18.5.0$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_cpu	Makefile	/^host_cpu = x86_64$/;"	m
host_os	Makefile	/^host_os = darwin18.5.0$/;"	m
host_triplet	Makefile	/^host_triplet = x86_64-apple-darwin18.5.0$/;"	m
host_vendor	Makefile	/^host_vendor = apple$/;"	m
html	profile/htmlCssChartist.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlCssStyle.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlJsChartistMin.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlJsChartistPlugin.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlJsMain.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlJsTableSort.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlJsUtil.h	/^namespace html {$/;"	n	namespace:souffle::profile
html	profile/htmlMain.h	/^namespace html {$/;"	n	namespace:souffle::profile
htmlBodyBottom	profile/htmlMain.h	/^std::string htmlBodyBottom = R"___($/;"	m	namespace:souffle::profile::html
htmlBodyTop	profile/htmlMain.h	/^std::string htmlBodyTop = R"___($/;"	m	namespace:souffle::profile::html
htmlHeadBottom	profile/htmlMain.h	/^std::string htmlHeadBottom = R"___($/;"	m	namespace:souffle::profile::html
htmlHeadTop	profile/htmlMain.h	/^std::string htmlHeadTop = R"___($/;"	m	namespace:souffle::profile::html
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
i	ParallelUtils.h	/^    int i;$/;"	m	class:souffle::detail::Waiter
i	json11.h	/^    size_t i;$/;"	m	struct:json11::__anon66::final
i2r	CompiledRecord.h	/^    block_index_type i2r;$/;"	m	class:souffle::detail::RecordMap
i2r	InterpreterRecords.cpp	/^    vector<vector<RamDomain>> i2r;$/;"	m	class:souffle::__anon67::RecordMap	file:
id	Constraints.h	/^    Id id;$/;"	m	struct:souffle::Variable
id	DebugReport.h	/^    std::string id;$/;"	m	class:souffle::DebugReportSection
id	InterpreterInterface.h	/^    uint32_t id;$/;"	m	class:souffle::InterpreterRelInterface
id	SouffleInterface.h	/^        uint32_t id;$/;"	m	class:souffle::Relation::iterator_base
id	Util.h	/^struct id {$/;"	s	namespace:souffle
id	profile/Relation.h	/^    const std::string id;$/;"	m	class:souffle::profile::Relation
id	profile/Tui.h	/^    void id(std::string col) {$/;"	f	namespace:souffle::profile
identifier	AstTranslator.h	/^        int identifier;$/;"	m	struct:souffle::AstTranslator::Location
identifier	RamExpression.h	/^    const size_t identifier;$/;"	m	class:souffle::RamElementAccess
identifier	RamOperation.h	/^    const size_t identifier;$/;"	m	class:souffle::RamSearch
identifier	profile/Rule.h	/^    const std::string identifier;$/;"	m	class:souffle::profile::Atom
identifier	profile/Rule.h	/^    std::string identifier;$/;"	m	class:souffle::profile::Rule
identifierToString	ProvenanceTransformer.cpp	/^const std::string identifierToString(const AstRelationIdentifier& name) {$/;"	f	namespace:souffle
identifiers	Synthesiser.h	/^    std::map<const std::string, const std::string> identifiers;$/;"	m	class:souffle::Synthesiser
identity	Brie.h	/^struct identity {$/;"	s	namespace:souffle::detail
idx	AstArgument.h	/^    AstDomain idx;$/;"	m	class:souffle::AstConstant
idxMap	Synthesiser.h	/^    std::map<std::string, unsigned> idxMap;$/;"	m	class:souffle::Synthesiser
ignore	test/test.h	/^void ignore(const T&) {}$/;"	f	namespace:testutil
ignoredAtoms	MagicSet.h	/^    std::set<AstRelationIdentifier> ignoredAtoms;$/;"	m	class:souffle::Adornment
igzfstream	gzfstream.h	/^    explicit igzfstream(const std::string& filename, std::ios_base::openmode mode = std::ios::in)$/;"	f	class:souffle::gzfstream::igzfstream
igzfstream	gzfstream.h	/^    igzfstream() : internal::gzfstream(), std::istream(&buf) {}$/;"	f	class:souffle::gzfstream::igzfstream
igzfstream	gzfstream.h	/^class igzfstream : public internal::gzfstream, public std::istream {$/;"	c	namespace:souffle::gzfstream
imply	AstGroundAnalysis.cpp	/^BoolDisjunctConstraint imply(const BoolDisjunctVar& a, const BoolDisjunctVar& b) {$/;"	f	namespace:souffle::__anon2
imply	AstGroundAnalysis.cpp	/^BoolDisjunctConstraint imply(const std::vector<BoolDisjunctVar>& vars, const BoolDisjunctVar& res) {$/;"	f	namespace:souffle::__anon2
inBoundaries	Brie.h	/^    bool inBoundaries(index_type a) const {$/;"	f	class:souffle::SparseArray
inBoundaries	Brie.h	/^    static bool inBoundaries(index_type a, uint32_t levels, index_type offset) {$/;"	f	class:souffle::SparseArray
in_history	profile/UserInputReader.h	/^    bool in_history = false;$/;"	m	class:souffle::profile::InputReader
in_range	json11.h	/^static inline bool in_range(long x, long lower, long upper) {$/;"	f	namespace:json11
in_tab_complete	profile/UserInputReader.h	/^    bool in_tab_complete = false;$/;"	m	class:souffle::profile::InputReader
inc	Brie.h	/^        bool inc() {$/;"	f	class:souffle::Trie::iterator_core
inc	Brie.h	/^        bool inc(Tuple& entry) {$/;"	f	class:souffle::Trie::iterator_core
inc	Brie.h	/^        bool inc(Tuple&) {$/;"	f	class:souffle::Trie::iterator_core
incCounter	Interpreter.h	/^    int incCounter() {$/;"	f	class:souffle::Interpreter
incCounter	Interpreter.h	/^   void incCounter() {counter ++;}$/;"	f	class:souffle::LowLevelMachine
incIterationNumber	Interpreter.h	/^    void incIterationNumber() {$/;"	f	class:souffle::Interpreter
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
increaseInterval	ProfileEvent.h	/^        void increaseInterval() {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
index	CompiledIndexUtils.h	/^    data_structure index;$/;"	m	struct:souffle::ram::index_utils::DirectIndex
index	CompiledIndexUtils.h	/^    data_structure index;$/;"	m	struct:souffle::ram::index_utils::IndirectIndex
index	CompiledIndexUtils.h	/^    index_t index;$/;"	m	class:souffle::ram::index_utils::Indices
index	CompiledIndexUtils.h	/^struct index {$/;"	s	namespace:souffle::ram
index	InterpreterRelation.h	/^        size_t index = 0;$/;"	m	class:souffle::InterpreterRelation::iterator
index	RamStatement.h	/^    const int index;$/;"	m	class:souffle::RamStratum
indexOfScc	PrecedenceGraph.h	/^    const size_t indexOfScc(const size_t scc) const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
indexOfScc	PrecedenceGraph.h	/^    const std::set<size_t> indexOfScc(const std::set<size_t>& sccs) const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
indexScanIteratorIndex	Interpreter.h	/^       size_t indexScanIteratorIndex = 0;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
indexValues	AstTranslator.cpp	/^void AstTranslator::ClauseTranslator::indexValues(const AstNode* curNode,$/;"	f	class:souffle::AstTranslator::ClauseTranslator
index_factory	CompiledIndexUtils.h	/^struct index_factory<T, Index, false> {$/;"	s	namespace:souffle::ram::index_utils
index_factory	CompiledIndexUtils.h	/^struct index_factory<T, Index, true> {$/;"	s	namespace:souffle::ram::index_utils
index_utils	CompiledIndexUtils.h	/^namespace index_utils {$/;"	n	namespace:souffle::ram
indices	CompiledRelation.h	/^    indices_t indices;$/;"	m	class:souffle::ram::detail::AutoRelation
indices	InterpreterRelation.h	/^    mutable std::map<InterpreterIndexOrder, std::unique_ptr<InterpreterIndex>> indices;$/;"	m	class:souffle::InterpreterRelation
indices	SynthesiserRelation.h	/^    const IndexSet& indices;$/;"	m	class:souffle::SynthesiserRelation
info	ExplainProvenanceSLD.h	/^    std::map<std::pair<std::string, size_t>, std::vector<std::string>> info;$/;"	m	class:souffle::ExplainProvenanceSLD
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
inherit	profile/htmlMain.h	/^<div id="wrapper" style="width:100%;height:inherit;">$/;"	m	namespace:souffle::profile::html
init	Mpi.h	/^inline int init(int argc, char* argv[]) {$/;"	f	namespace:souffle::mpi::__anon57
initialiseWindow	Explain.h	/^    void initialiseWindow() {$/;"	f
inlineBodyLiterals	InlineRelationsTransformer.cpp	/^std::pair<NullableVector<AstLiteral*>, std::vector<AstBinaryConstraint*>> inlineBodyLiterals($/;"	f	namespace:souffle
inner	BTree.h	/^        const bool inner;$/;"	m	struct:souffle::detail::btree::base
inner_node	BTree.h	/^        inner_node() : node(true) {}$/;"	f	struct:souffle::detail::btree::inner_node
inner_node	BTree.h	/^    struct inner_node : public node {$/;"	s	class:souffle::detail::btree
inputFactories	IOSystem.h	/^    std::map<std::string, std::shared_ptr<ReadStreamFactory>> inputFactories;$/;"	m	class:souffle::IOSystem
inputMap	ReadStreamCSV.h	/^    std::map<int, int> inputMap;$/;"	m	class:souffle::ReadStreamCSV
inputReceived	profile/UserInputReader.h	/^    bool inputReceived = false;$/;"	m	class:souffle::profile::InputReader
inputRelations	AstIOTypeAnalysis.h	/^    std::set<const AstRelation*> inputRelations;$/;"	m	class:souffle::IOType
inputRelations	SouffleInterface.h	/^    std::vector<Relation*> inputRelations;$/;"	m	class:souffle::SouffleProgram
input_dir	CompiledOptions.h	/^    std::string input_dir;$/;"	m	class:souffle::CmdOptions
insert	AstParserUtils.cpp	/^void RuleBody::insert(clause& cl, literal&& lit) {$/;"	f	class:souffle::RuleBody
insert	AstParserUtils.cpp	/^void RuleBody::insert(std::vector<clause>& cnf, clause&& cls) {$/;"	f	class:souffle::RuleBody
insert	BTree.h	/^    bool insert(const Key& k) {$/;"	f	class:souffle::detail::btree
insert	BTree.h	/^    bool insert(const Key& k, operation_hints& hints) {$/;"	f	class:souffle::detail::btree
insert	BTree.h	/^    void insert(const Iter& a, const Iter& b) {$/;"	f	class:souffle::detail::btree
insert	Brie.h	/^    bool insert(Values... values) {$/;"	f	class:souffle::detail::TrieBase
insert	Brie.h	/^    bool insert(const entry_type& tuple) {$/;"	f	class:souffle::Trie
insert	Brie.h	/^    bool insert(const entry_type& tuple, op_context& ctxt) {$/;"	f	class:souffle::Trie
insert	Brie.h	/^    bool insert(const entry_type& tuple, op_context&) {$/;"	f	class:souffle::Trie
insert	Brie.h	/^    bool insert(const entry_type&) {$/;"	f	class:souffle::Trie
insert	CompiledIndexUtils.h	/^    bool insert(const key_type& key, operation_hints& hints) {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
insert	CompiledIndexUtils.h	/^    bool insert(const key_type& key, operation_hints& hints) {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
insert	CompiledIndexUtils.h	/^    bool insert(const tuple_type& tuple, operation_hints& ctxt) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
insert	CompiledIndexUtils.h	/^    bool insert(const tuple_type& tuple, operation_hints& ctxt) {$/;"	f	class:souffle::ram::index_utils::TrieIndex
insert	CompiledIndexUtils.h	/^    void insert(const T& tuple, operation_context& c) {$/;"	f	class:souffle::ram::index_utils::Indices
insert	CompiledIndexUtils.h	/^    void insert(const T&, operation_context&) {}$/;"	f	class:souffle::ram::index_utils::Indices
insert	CompiledRelation.h	/^    bool insert(Args... args) {$/;"	f	struct:souffle::ram::detail::RelationBase
insert	CompiledRelation.h	/^    bool insert(const RamDomain* ramDomain) {$/;"	f	class:souffle::ram::detail::AutoRelation
insert	CompiledRelation.h	/^    bool insert(const RamDomain* ramDomain) {$/;"	f	struct:souffle::ram::detail::RelationBase
insert	CompiledRelation.h	/^    bool insert(const tuple_type& = tuple_type(), const operation_context& = operation_context()) {$/;"	f	class:souffle::ram::detail::AutoRelation
insert	CompiledRelation.h	/^    bool insert(const tuple_type& tuple) {$/;"	f	struct:souffle::ram::detail::RelationBase
insert	CompiledRelation.h	/^    bool insert(const tuple_type& tuple, operation_context& context) {$/;"	f	class:souffle::ram::detail::AutoRelation
insert	CompiledRelation.h	/^    bool insert(const tuple_type& tuple, operation_context& context) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
insert	CompiledRelation.h	/^    bool insert(const tuple_type& tuple, operation_context& ctxt) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
insert	CompiledRelation.h	/^    bool insert(const tuple_type& tuple, operation_context&) {$/;"	f	class:souffle::ram::detail::GenericRelation
insert	CompiledRelation.h	/^    void insert(const tuple_type& element) {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
insert	CompiledRelation.h	/^    void insert(const tuple_type&) {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
insert	CompiledSouffle.h	/^    bool insert() {$/;"	f	class:souffle::t_nullaries
insert	CompiledSouffle.h	/^    void insert(const RamDomain* ramDomain) {$/;"	f	class:souffle::t_nullaries
insert	CompiledSouffle.h	/^    void insert(const t_tuple& t) {$/;"	f	class:souffle::t_nullaries
insert	CompiledSouffle.h	/^    void insert(const t_tuple& t, context& \/* ctxt *\/) {$/;"	f	class:souffle::t_nullaries
insert	EquivalenceRelation.h	/^    bool insert(value_type x, value_type y) {$/;"	f	class:souffle::EquivalenceRelation
insert	EquivalenceRelation.h	/^    bool insert(value_type x, value_type y, operation_hints) {$/;"	f	class:souffle::EquivalenceRelation
insert	GraphUtils.h	/^    void insert(const Vertex& from, const Vertex& to) {$/;"	f	class:souffle::Graph
insert	GraphUtils.h	/^    void insert(const Vertex& vertex) {$/;"	f	class:souffle::Graph
insert	InterpreterIndex.h	/^    void insert(const Iter& a, const Iter& b) {$/;"	f	class:souffle::InterpreterIndex
insert	InterpreterIndex.h	/^    void insert(const RamDomain* tuple) {$/;"	f	class:souffle::InterpreterIndex
insert	InterpreterRelation.h	/^    virtual void insert(const RamDomain* tuple) {$/;"	f	class:souffle::InterpreterRelation
insert	InterpreterRelation.h	/^    void insert(const InterpreterRelation& other) {$/;"	f	class:souffle::InterpreterRelation
insert	LambdaBTree.h	/^    typename Functor::result_type insert($/;"	f	class:souffle::detail::LambdaBTree
insert	LambdaBTree.h	/^    typename Functor::result_type insert(Key& k, const Functor& f) {$/;"	f	class:souffle::detail::LambdaBTree
insert	LambdaBTree.h	/^    void insert(const Iter& a, const Iter& b) {$/;"	f	class:souffle::detail::LambdaBTree
insert	SymbolTable.h	/^    void insert(const std::string& symbol) {$/;"	f	class:souffle::SymbolTable
insert	SymbolTable.h	/^    void insert(const std::vector<std::string>& symbols) {$/;"	f	class:souffle::SymbolTable
insert	Table.h	/^    const T& insert(const T& element) {$/;"	f	class:souffle::Table
insert	TypeSystem.h	/^    void insert(const Type& type) {$/;"	f	struct:souffle::TypeSet
insert	TypeSystem.h	/^    void insert(const TypeSet& set) {$/;"	f	struct:souffle::TypeSet
insertAll	BTree.h	/^    void insertAll(const btree& other) {$/;"	f	class:souffle::detail::btree
insertAll	Brie.h	/^    void insertAll(const Trie& other) {$/;"	f	class:souffle::Trie
insertAll	CompiledIndexUtils.h	/^    void insertAll(const DirectIndex& other) {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
insertAll	CompiledIndexUtils.h	/^    void insertAll(const DisjointSetIndex& other) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
insertAll	CompiledIndexUtils.h	/^    void insertAll(const Indices& other) {$/;"	f	class:souffle::ram::index_utils::Indices
insertAll	CompiledIndexUtils.h	/^    void insertAll(const Indices&) {}$/;"	f	class:souffle::ram::index_utils::Indices
insertAll	CompiledIndexUtils.h	/^    void insertAll(const IndirectIndex& other) {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
insertAll	CompiledIndexUtils.h	/^    void insertAll(const TrieIndex& other) {$/;"	f	class:souffle::ram::index_utils::TrieIndex
insertAll	CompiledRelation.h	/^    void insertAll(const DirectIndexedRelation& other) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<Setup, 0, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::AutoRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::AutoRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::GenericRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<Setup, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
insertAll	CompiledRelation.h	/^    void insertAll(const Relation<souffle::ram::EqRel, arity, Idxs...>& other) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
insertAll	CompiledRelation.h	/^    void insertAll(const SingleIndexRelation& other) {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
insertAll	CompiledSouffle.h	/^    void insertAll(T& other) {$/;"	f	class:souffle::t_nullaries
insertAll	EquivalenceRelation.h	/^    void insertAll(const EquivalenceRelation<TupleType>& other) {$/;"	f	class:souffle::EquivalenceRelation
insertAll	LambdaBTree.h	/^    void insertAll(const LambdaBTree& other) {$/;"	f	class:souffle::detail::LambdaBTree
insertAt	PiggyList.h	/^    void insertAt(size_t index, T value) {$/;"	f	class:souffle::RandomInsertPiggyList
insertIndex	IndexSetAnalysis.h	/^    void insertIndex(std::vector<int>& ids, SearchColumns delta) {$/;"	f	class:souffle::IndexSet
insertStatement	WriteStreamSQLite.h	/^    sqlite3_stmt* insertStatement = nullptr;$/;"	m	class:souffle::WriteStreamSQLite
insert_inner	BTree.h	/^        void insert_inner(node** root, lock_type& root_lock, unsigned pos, node* predecessor, const Key& key,$/;"	f	struct:souffle::detail::btree::node
insert_internal	Brie.h	/^    bool insert_internal(const Tuple& tuple, op_context& ctxt) {$/;"	f	class:souffle::Trie
insert_internal	Brie.h	/^    bool insert_internal(const Tuple& tuple, op_context&) {$/;"	f	class:souffle::Trie
insert_lock	CompiledRelation.h	/^    Lock insert_lock;$/;"	m	class:souffle::ram::detail::AutoRelation
inserts	BTree.h	/^        CacheAccessCounter inserts;$/;"	m	struct:souffle::detail::btree::hint_statistics
inserts	Brie.h	/^        CacheAccessCounter inserts;$/;"	m	struct:souffle::detail::TrieBase::hint_statistics
install_sh	Makefile	/^install_sh = ${SHELL} \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
instance	Brie.h	/^    static const ram::Tuple<RamDomain, 0> instance;$/;"	m	class:souffle::Trie
instance	EventProcessor.h	/^    static EventProcessorSingleton& instance() {$/;"	f	class:souffle::profile::EventProcessorSingleton
instance	ProfileEvent.h	/^    static ProfileEventSingleton& instance() {$/;"	f	class:souffle::ProfileEventSingleton
instance	SignalHandler.h	/^    static SignalHandler* instance() {$/;"	f	class:souffle::SignalHandler
instance	StringPool.h	/^    static StringPool* instance() {$/;"	f	class:souffle::StringPool
instanceName	AstComponent.h	/^    std::string instanceName;$/;"	m	class:souffle::AstComponentInit
instantiations	AstComponent.h	/^    std::vector<std::unique_ptr<AstComponentInit>> instantiations;$/;"	m	class:souffle::AstComponent
instantiations	AstProgram.h	/^    std::vector<std::unique_ptr<AstComponentInit>> instantiations;$/;"	m	class:souffle::AstProgram
int_value	json11.h	/^inline int Json::int_value() const {$/;"	f	class:json11::Json
int_value	json11.h	/^inline int JsonValue::int_value() const {$/;"	f	class:json11::JsonValue
interfaces	InterpreterInterface.h	/^    std::vector<InterpreterRelInterface*> interfaces;$/;"	m	class:souffle::InterpreterProgInterface
internal	gzfstream.h	/^namespace internal {$/;"	n	namespace:souffle::gzfstream
internalRelations	SouffleInterface.h	/^    std::vector<Relation*> internalRelations;$/;"	m	class:souffle::SouffleProgram
invalidateAnalyses	AstTranslationUnit.h	/^    void invalidateAnalyses() {$/;"	f	class:souffle::AstTranslationUnit
invalidateAnalyses	RamTranslationUnit.h	/^    void invalidateAnalyses() {$/;"	f	class:souffle::RamTranslationUnit
ioDirectives	RamStatement.h	/^    const std::vector<IODirectives> ioDirectives;$/;"	m	class:souffle::RamLoad
ioDirectives	RamStatement.h	/^    const std::vector<IODirectives> ioDirectives;$/;"	m	class:souffle::RamStore
ioType	PrecedenceGraph.h	/^    IOType* ioType = nullptr;$/;"	m	class:souffle::SCCGraph
ioTypes	souffle2bdd.cpp	/^    const IOType* ioTypes;$/;"	m	class:souffle::BddBddBTranslator	file:
ioTypes	souffle2lb.cpp	/^    const IOType* ioTypes;$/;"	m	class:souffle::LogicbloxConverter	file:
iout	souffle2lb.cpp	/^    std::ostream& iout;$/;"	m	class:souffle::LogicbloxConverter	file:
iprobe	Mpi.h	/^inline Status iprobe() {$/;"	f	namespace:souffle::mpi::__anon62
iprobe	Mpi.h	/^inline Status iprobe(const Status& status) {$/;"	f	namespace:souffle::mpi::__anon62
iprobe	Mpi.h	/^inline Status iprobe(const int source, const int tag) {$/;"	f	namespace:souffle::mpi::__anon62
isA	TypeSystem.cpp	/^bool isA(const Type& type) {$/;"	f	namespace:souffle::__anon75
isAggRel	MagicSet.cpp	/^bool isAggRel(const AstRelationIdentifier& rel) {$/;"	f	namespace:souffle
isAggregator	AstTranslator.h	/^        bool isAggregator(const int level) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
isAll	TypeSystem.h	/^    bool isAll() const {$/;"	f	struct:souffle::TypeSet
isBindingConstraint	MagicSet.cpp	/^bool isBindingConstraint(AstArgument* lhs, AstArgument* rhs, std::set<std::string> boundArgs) {$/;"	f	namespace:souffle
isBoundArgument	MagicSet.cpp	/^bool isBoundArgument($/;"	f	namespace:souffle
isBoundComposite	MagicSet.cpp	/^bool isBoundComposite(const AstVariable* compositeVariable, const std::set<std::string>& boundArgs,$/;"	f	namespace:souffle
isCompatible	InterpreterIndex.h	/^    bool isCompatible(const InterpreterIndexOrder& other) const {$/;"	f	class:souffle::InterpreterIndexOrder
isComplete	AstClause.h	/^    bool isComplete() const {$/;"	f	class:souffle::AstExecutionOrder
isComplete	InterpreterIndex.h	/^    bool isComplete() const {$/;"	f	class:souffle::InterpreterIndexOrder
isConstant	RamConstValue.cpp	/^bool RamConstValueAnalysis::isConstant(const RamExpression* value) const {$/;"	f	class:souffle::RamConstValueAnalysis
isConstant	RamOperation.cpp	/^bool isConstant(const RamExpression* value) {$/;"	f	namespace:souffle
isConstantArithExpr	AstSemanticChecker.cpp	/^static bool isConstantArithExpr(const AstArgument& argument) {$/;"	f	namespace:souffle
isDefined	AstTranslator.h	/^        bool isDefined(const AstVariable& var) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
isEmpty	BTree.h	/^        bool isEmpty() const {$/;"	f	struct:souffle::detail::btree::node
isEmpty	IODirectives.h	/^    bool isEmpty() {$/;"	f	class:souffle::IODirectives
isEnd	Brie.h	/^        bool isEnd() const {$/;"	f	class:souffle::SparseArray::iterator
isEnd	Brie.h	/^        bool isEnd() const {$/;"	f	class:souffle::SparseBitMap::iterator
isEndVal	EquivalenceRelation.h	/^        bool isEndVal = false;$/;"	m	class:souffle::EquivalenceRelation::iterator
isEqualAdornment	MagicSet.cpp	/^bool isEqualAdornment(const AstRelationIdentifier& pred1, const std::string& adorn1,$/;"	f	namespace:souffle
isFact	AstClause.cpp	/^bool AstClause::isFact() const {$/;"	f	class:souffle::AstClause
isFull	BTree.h	/^        bool isFull() const {$/;"	f	struct:souffle::detail::btree::node
isFull	Table.h	/^        bool isFull() const {$/;"	f	struct:souffle::Table::Block
isGenerated	AstClause.h	/^    bool isGenerated() const {$/;"	f	class:souffle::AstClause
isIO	AstIOTypeAnalysis.h	/^    bool isIO(const AstRelation* relation) const {$/;"	f	class:souffle::IOType
isInfixFunctorOp	FunctorOps.h	/^inline bool isInfixFunctorOp(const FunctorOp op) {$/;"	f	namespace:souffle
isInline	AstRelation.h	/^    bool isInline() const {$/;"	f	class:souffle::AstRelation
isInner	BTree.h	/^        bool isInner() const {$/;"	f	struct:souffle::detail::btree::base
isInput	AstIOTypeAnalysis.h	/^    bool isInput(const AstRelation* relation) const {$/;"	f	class:souffle::IOType
isLeaf	BTree.h	/^        bool isLeaf() const {$/;"	f	struct:souffle::detail::btree::base
isLive	profile/Reader.h	/^    inline bool isLive() {$/;"	f	class:souffle::profile::Reader
isLoaded	profile/Reader.h	/^    inline bool isLoaded() {$/;"	f	class:souffle::profile::Reader
isNotSubtypeOf	test/type_system_test.cpp	/^bool isNotSubtypeOf(const Type& a, const Type& b) {$/;"	f	namespace:souffle::test
isNull	CompiledRecord.h	/^bool isNull(RamDomain ref) {$/;"	f	namespace:souffle
isNull	InterpreterRecords.cpp	/^bool isNull(RamDomain ref) {$/;"	f	namespace:souffle
isNullary	RamRelation.h	/^    const bool isNullary() const {$/;"	f	class:souffle::RamRelation
isNumber	Util.h	/^inline bool isNumber(const char* str) {$/;"	f	namespace:souffle
isNumberType	TypeSystem.cpp	/^bool isNumberType(const Type& type) {$/;"	f	namespace:souffle
isNumberType	TypeSystem.cpp	/^bool isNumberType(const TypeSet& s) {$/;"	f	namespace:souffle
isNumeric	AstType.h	/^    bool isNumeric() const {$/;"	f	class:souffle::AstPrimitiveType
isNumericBinaryConstraintOp	BinaryConstraintOps.h	/^inline bool isNumericBinaryConstraintOp(const BinaryConstraintOp op) {$/;"	f	namespace:souffle
isNumericFunctorOp	FunctorOps.h	/^inline bool isNumericFunctorOp(const FunctorOp op) {$/;"	f	namespace:souffle
isNumerical	AstArgument.h	/^    bool isNumerical() const {$/;"	f	class:souffle::AstIntrinsicFunctor
isNumerical	AstFunctorDeclaration.h	/^    bool isNumerical() const {$/;"	f	class:souffle::AstFunctorDeclaration
isNumerical	AstLiteral.h	/^    const bool isNumerical() const {$/;"	f	class:souffle::AstBinaryConstraint
isOfRootType	TypeSystem.cpp	/^bool isOfRootType(const Type& type, const Type& root) {$/;"	f	namespace:souffle::__anon75
isOpen	gzfstream.h	/^    bool isOpen = false;$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
isOutput	AstIOTypeAnalysis.h	/^    bool isOutput(const AstRelation* relation) const {$/;"	f	class:souffle::IOType
isOverridable	AstRelation.h	/^    bool isOverridable() const {$/;"	f	class:souffle::AstRelation
isPrefixOf	InterpreterIndex.h	/^    bool isPrefixOf(const InterpreterIndexOrder& other) const {$/;"	f	class:souffle::InterpreterIndexOrder
isPrintSize	AstIOTypeAnalysis.h	/^    bool isPrintSize(const AstRelation* relation) const {$/;"	f	class:souffle::IOType
isProfiling	CompiledOptions.h	/^    bool isProfiling() const {$/;"	f	class:souffle::CmdOptions
isProposition	ReorderLiteralsTransformer.cpp	/^inline bool isProposition(const AstAtom* atom) {$/;"	f	namespace:souffle
isProvenance	ReadStream.h	/^    const bool isProvenance;$/;"	m	class:souffle::ReadStream
isProvenance	SynthesiserRelation.h	/^    const bool isProvenance;$/;"	m	class:souffle::SynthesiserRelation
isProvenance	WriteStream.h	/^    const bool isProvenance;$/;"	m	class:souffle::WriteStream
isReady	profile/Relation.h	/^    bool isReady() {$/;"	f	class:souffle::profile::Relation
isRecordType	TypeSystem.cpp	/^bool isRecordType(const Type& type) {$/;"	f	namespace:souffle
isRecordType	TypeSystem.cpp	/^bool isRecordType(const TypeSet& s) {$/;"	f	namespace:souffle
isRecursive	PrecedenceGraph.h	/^    bool isRecursive(const size_t scc) const {$/;"	f	class:souffle::SCCGraph
isRecursive	PrecedenceGraph.h	/^    const bool isRecursive;$/;"	m	class:souffle::RelationScheduleStep
isRecursive	profile/Rule.h	/^    bool isRecursive() const {$/;"	f	class:souffle::profile::Rule
isRecursiveType	TypeSystem.cpp	/^bool isRecursiveType(const Type& type) {$/;"	f	namespace:souffle
isRule	AstClause.h	/^    bool isRule() const {$/;"	f	class:souffle::AstClause
isSet	SignalHandler.h	/^    bool isSet = false;$/;"	m	class:souffle::SignalHandler
isSomethingDefinedOn	AstTranslator.h	/^        bool isSomethingDefinedOn(int level) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
isStrictSubset	IndexSetAnalysis.h	/^    static bool isStrictSubset(SearchColumns a, SearchColumns b) {$/;"	f	class:souffle::IndexSet
isSubType	TypeSystem.cpp	/^bool isSubType(const Type& a, const UnionType& b) {$/;"	f	namespace:souffle::__anon75
isSubset	IndexSetAnalysis.h	/^    bool isSubset(SearchColumns cols) const {$/;"	f	class:souffle::IndexSet
isSubsetOf	AstParserUtils.cpp	/^bool RuleBody::isSubsetOf(const clause& a, const clause& b) {$/;"	f	class:souffle::RuleBody
isSubsetOf	TypeSystem.h	/^    bool isSubsetOf(const TypeSet& b) const {$/;"	f	struct:souffle::TypeSet
isSubtypeOf	AstTypeAnalysis.cpp	/^TypeConstraint isSubtypeOf(const TypeVar& a, const Type& b) {$/;"	f	namespace:souffle::__anon77
isSubtypeOf	AstTypeAnalysis.cpp	/^TypeConstraint isSubtypeOf(const TypeVar& a, const TypeVar& b) {$/;"	f	namespace:souffle::__anon77
isSubtypeOf	TypeSystem.cpp	/^bool isSubtypeOf(const Type& a, const Type& b) {$/;"	f	namespace:souffle
isSubtypeOfComponent	AstTypeAnalysis.cpp	/^TypeConstraint isSubtypeOfComponent(const TypeVar& a, const TypeVar& b, int index) {$/;"	f	namespace:souffle::__anon77
isSupertypeOf	AstTypeAnalysis.cpp	/^TypeConstraint isSupertypeOf(const TypeVar& a, const Type& b) {$/;"	f	namespace:souffle::__anon77
isSuppressed	AstRelation.h	/^    bool isSuppressed() const {$/;"	f	class:souffle::AstRelation
isSymbolType	TypeSystem.cpp	/^bool isSymbolType(const Type& type) {$/;"	f	namespace:souffle
isSymbolType	TypeSystem.cpp	/^bool isSymbolType(const TypeSet& s) {$/;"	f	namespace:souffle
isSymbolic	AstArgument.h	/^    bool isSymbolic() const {$/;"	f	class:souffle::AstIntrinsicFunctor
isSymbolic	AstFunctorDeclaration.h	/^    bool isSymbolic() const {$/;"	f	class:souffle::AstFunctorDeclaration
isSymbolic	AstLiteral.h	/^    const bool isSymbolic() const {$/;"	f	class:souffle::AstBinaryConstraint
isSymbolic	AstType.h	/^    bool isSymbolic() const {$/;"	f	class:souffle::AstPrimitiveType
isSymbolicBinaryConstraintOp	BinaryConstraintOps.h	/^inline bool isSymbolicBinaryConstraintOp(const BinaryConstraintOp op) {$/;"	f	namespace:souffle
isSymbolicFunctorOp	FunctorOps.h	/^inline bool isSymbolicFunctorOp(const FunctorOp op) {$/;"	f	namespace:souffle
isTemp	RamRelation.h	/^    const bool isTemp() const {$/;"	f	class:souffle::RamRelation
isTotal	RamExistenceCheckAnalysis.cpp	/^bool RamExistenceCheckAnalysis::isTotal(const RamExistenceCheck* existCheck) const {$/;"	f	class:souffle::RamExistenceCheckAnalysis
isTotal	RamProvenanceExistenceCheckAnalysis.cpp	/^bool RamProvenanceExistenceCheckAnalysis::isTotal(const RamProvenanceExistenceCheck* provExistCheck) const {$/;"	f	class:souffle::RamProvenanceExistenceCheckAnalysis
isTrue	AstGroundAnalysis.cpp	/^BoolDisjunctConstraint isTrue(const BoolDisjunctVar& var) {$/;"	f	namespace:souffle::__anon2
isTrue	AstLiteral.h	/^    bool isTrue() const {$/;"	f	class:souffle::AstBooleanConstraint
isType	TypeSystem.cpp	/^bool TypeEnvironment::isType(const Type& type) const {$/;"	f	class:souffle::TypeEnvironment
isType	TypeSystem.cpp	/^bool TypeEnvironment::isType(const identifier& ident) const {$/;"	f	class:souffle::TypeEnvironment
isUnion	TypeSystem.cpp	/^bool isUnion(const Type& type) {$/;"	f	namespace:souffle::__anon75
isValid	InlineRelationsTransformer.cpp	/^    bool isValid() const {$/;"	f	class:souffle::NullableVector
isValidMove	MinimiseProgramTransformer.cpp	/^bool isValidMove(const AstClause* left, size_t leftIdx, const AstClause* right, size_t rightIdx) {$/;"	f	namespace:souffle
isValidPermutation	MinimiseProgramTransformer.cpp	/^bool isValidPermutation($/;"	f	namespace:souffle
isVariableBoundComposite	MagicSet.h	/^    bool isVariableBoundComposite(const std::string& functorName) const {$/;"	f	class:souffle::BindingStore
is_array	json11.h	/^    bool is_array() const {$/;"	f	class:json11::final
is_ast_visitor	AstVisitor.h	/^struct is_ast_visitor {$/;"	s	namespace:souffle::detail
is_ast_visitor	AstVisitor.h	/^struct is_ast_visitor<T&> : public is_ast_visitor<T> {};$/;"	s	namespace:souffle::detail
is_ast_visitor	AstVisitor.h	/^struct is_ast_visitor<const T> : public is_ast_visitor<T> {};$/;"	s	namespace:souffle::detail
is_bool	json11.h	/^    bool is_bool() const {$/;"	f	class:json11::final
is_compatible_with	CompiledIndexUtils.h	/^struct is_compatible_with {$/;"	s	namespace:souffle::ram::index_utils
is_compatible_with	CompiledIndexUtils.h	/^struct is_compatible_with<index<C1...>, index<C2...>> {$/;"	s	namespace:souffle::ram::index_utils
is_compatible_with_aux	CompiledIndexUtils.h	/^struct is_compatible_with_aux {$/;"	s	namespace:souffle::ram::index_utils::detail
is_compatible_with_aux	CompiledIndexUtils.h	/^struct is_compatible_with_aux<index<A...>, index<>, index<B...>, index<R...>> {$/;"	s	namespace:souffle::ram::index_utils::detail
is_compatible_with_aux	CompiledIndexUtils.h	/^struct is_compatible_with_aux<index<A1...>, index<A, A2...>, index<B1...>, index<B, B2...>> {$/;"	s	namespace:souffle::ram::index_utils::detail
is_covered	CompiledIndexUtils.h	/^    struct is_covered {$/;"	s	class:souffle::ram::index_utils::Indices
is_full_index	CompiledIndexUtils.h	/^struct is_full_index {$/;"	s	namespace:souffle::ram::index_utils
is_null	json11.h	/^    bool is_null() const {$/;"	f	class:json11::final
is_number	json11.h	/^    bool is_number() const {$/;"	f	class:json11::final
is_object	json11.h	/^    bool is_object() const {$/;"	f	class:json11::final
is_open	gzfstream.h	/^    bool is_open() const {$/;"	f	class:souffle::gzfstream::internal::gzfstreambuf
is_open	gzfstream.h	/^    bool is_open() {$/;"	f	class:souffle::gzfstream::internal::gzfstream
is_permutation	CompiledIndexUtils.h	/^struct is_permutation {$/;"	s	namespace:souffle::ram::index_utils
is_permutation	CompiledIndexUtils.h	/^struct is_permutation<index<C1...>, index<C2...>> {$/;"	s	namespace:souffle::ram::index_utils
is_prefix	CompiledIndexUtils.h	/^struct is_prefix {$/;"	s	namespace:souffle::ram::index_utils
is_prefix	CompiledIndexUtils.h	/^struct is_prefix<index<>, index<Rest...>> {$/;"	s	namespace:souffle::ram::index_utils
is_prefix	CompiledIndexUtils.h	/^struct is_prefix<index<F, Ra...>, index<F, Rb...>> {$/;"	s	namespace:souffle::ram::index_utils
is_printable	Util.h	/^struct is_printable : public std::false_type {};$/;"	s	namespace:souffle::detail
is_ram_visitor	RamVisitor.h	/^struct is_ram_visitor {$/;"	s	namespace:souffle::detail
is_ram_visitor	RamVisitor.h	/^struct is_ram_visitor<T&> : public is_ram_visitor<T> {};$/;"	s	namespace:souffle::detail
is_ram_visitor	RamVisitor.h	/^struct is_ram_visitor<const T> : public is_ram_visitor<T> {};$/;"	s	namespace:souffle::detail
is_string	json11.h	/^    bool is_string() const {$/;"	f	class:json11::final
is_subset_of	CompiledIndexUtils.h	/^struct is_subset_of {$/;"	s	namespace:souffle::ram::index_utils
is_subset_of	CompiledIndexUtils.h	/^struct is_subset_of<index<>, index<Full...>> {$/;"	s	namespace:souffle::ram::index_utils
is_subset_of	CompiledIndexUtils.h	/^struct is_subset_of<index<First, Rest...>, index<Full...>> {$/;"	s	namespace:souffle::ram::index_utils
is_write_locked	ParallelUtils.h	/^    bool is_write_locked() const {$/;"	f	class:souffle::OptimisticReadWriteLock
is_write_locked	ParallelUtils.h	/^    bool is_write_locked() const {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
it	CompiledSouffle.h	/^        typename RelType::iterator it;$/;"	m	class:souffle::RelationWrapper::iterator_wrapper
it	InterpreterInterface.h	/^        InterpreterRelation::iterator it;$/;"	m	class:souffle::InterpreterRelInterface::iterator_base
iter	IterUtils.h	/^    Iter iter;$/;"	m	struct:souffle::IterDerefWrapper
iter	SouffleInterface.h	/^        iterator_base* iter = nullptr;$/;"	m	class:souffle::Relation::iterator
iterRel	profile/Tui.h	/^    void iterRel(std::string c, std::string col) {$/;"	f	namespace:souffle::profile
iterRul	profile/Tui.h	/^    void iterRul(std::string c, std::string col) {$/;"	f	namespace:souffle::profile
iter_type	CompiledIndexUtils.h	/^    struct iter_type {$/;"	s	class:souffle::ram::index_utils::Indices
iteration	Interpreter.h	/^    size_t iteration;$/;"	m	class:souffle::Interpreter
iteration	Logger.h	/^    size_t iteration;$/;"	m	class:souffle::Logger
iteration	profile/Reader.h	/^    Iteration& iteration;$/;"	m	class:souffle::profile::__anon72::RecursiveRulesVisitor
iterations	profile/Relation.h	/^    std::vector<std::shared_ptr<Iteration>> iterations;$/;"	m	class:souffle::profile::Relation
iterator	BTree.h	/^        iterator() : cur(nullptr) {}$/;"	f	class:souffle::detail::btree::iterator
iterator	BTree.h	/^        iterator(const iterator& other) : cur(other.cur), pos(other.pos) {}$/;"	f	class:souffle::detail::btree::iterator
iterator	BTree.h	/^        iterator(node const* cur, field_index_type pos) : cur(cur), pos(pos) {}$/;"	f	class:souffle::detail::btree::iterator
iterator	BTree.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, Key> {$/;"	c	class:souffle::detail::btree
iterator	Brie.h	/^        explicit iterator(const Param& param) : iter_core(param, value) {}$/;"	f	class:souffle::detail::TrieBase::iterator
iterator	Brie.h	/^        iterator() : node(nullptr) {}$/;"	f	class:souffle::SparseArray::iterator
iterator	Brie.h	/^        iterator(const Node* first, index_type firstOffset) : node(first), value(firstOffset, 0) {$/;"	f	class:souffle::SparseArray::iterator
iterator	Brie.h	/^        iterator(const Node* node, pair_type value) : node(node), value(std::move(value)) {}$/;"	f	class:souffle::SparseArray::iterator
iterator	Brie.h	/^        iterator(const nested_iterator& iter)$/;"	f	class:souffle::SparseBitMap::iterator
iterator	Brie.h	/^        iterator(const nested_iterator& iter, uint64_t m, index_type value)$/;"	f	class:souffle::SparseBitMap::iterator
iterator	Brie.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, entry_type> {$/;"	c	class:souffle::detail::TrieBase
iterator	Brie.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, index_type> {$/;"	c	class:souffle::SparseBitMap
iterator	Brie.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, std::pair<index_type, value_type>> {$/;"	c	class:souffle::SparseArray
iterator	CompiledIndexUtils.h	/^        iterator(const nested_iterator& iter) : nested(iter), value(orderOut(*iter)) {}$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
iterator	CompiledIndexUtils.h	/^        iterator(const nested_iterator& iter) : nested(iter), value(orderOut(*iter)){};$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
iterator	CompiledIndexUtils.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, tuple_type> {$/;"	c	class:souffle::ram::index_utils::DisjointSetIndex
iterator	CompiledIndexUtils.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, tuple_type> {$/;"	c	class:souffle::ram::index_utils::TrieIndex
iterator	CompiledRelation.h	/^        iterator(bool begin = false) : begin(begin) {}$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
iterator	CompiledRelation.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, tuple_type> {$/;"	c	class:souffle::ram::detail::AutoRelation
iterator	CompiledSouffle.h	/^        iterator(bool v = false) : value(v) {}$/;"	f	class:souffle::t_nullaries::iterator
iterator	CompiledSouffle.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, RamDomain*> {$/;"	c	class:souffle::t_nullaries
iterator	EquivalenceRelation.h	/^        explicit iterator(const EquivalenceRelation* br)$/;"	f	class:souffle::EquivalenceRelation::iterator
iterator	EquivalenceRelation.h	/^        explicit iterator(const EquivalenceRelation* br, bool \/* signalIsEndIterator *\/)$/;"	f	class:souffle::EquivalenceRelation::iterator
iterator	EquivalenceRelation.h	/^        explicit iterator(const EquivalenceRelation* br, const StatesBucket within)$/;"	f	class:souffle::EquivalenceRelation::iterator
iterator	EquivalenceRelation.h	/^        explicit iterator(const EquivalenceRelation* br, const value_type former, const StatesBucket within)$/;"	f	class:souffle::EquivalenceRelation::iterator
iterator	EquivalenceRelation.h	/^        explicit iterator(const EquivalenceRelation* br, const value_type former, value_type latter,$/;"	f	class:souffle::EquivalenceRelation::iterator
iterator	EquivalenceRelation.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, TupleType> {$/;"	c	class:souffle::EquivalenceRelation
iterator	InterpreterRelation.h	/^        iterator(const InterpreterRelation* const relation)$/;"	f	class:souffle::InterpreterRelation::iterator
iterator	InterpreterRelation.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, RamDomain*> {$/;"	c	class:souffle::InterpreterRelation
iterator	PiggyList.h	/^        iterator(PiggyList* bl) : bl(bl){};$/;"	f	class:souffle::PiggyList::iterator
iterator	PiggyList.h	/^        iterator(PiggyList* bl, size_t beginInd) : cIndex(beginInd), bl(bl){};$/;"	f	class:souffle::PiggyList::iterator
iterator	PiggyList.h	/^    class iterator : std::iterator<std::forward_iterator_tag, T> {$/;"	c	class:souffle::PiggyList
iterator	SouffleInterface.h	/^        iterator(const iterator& o) : iter(o.iter->clone()) {}$/;"	f	class:souffle::Relation::iterator
iterator	SouffleInterface.h	/^        iterator(iterator_base* arg) : iter(arg) {}$/;"	f	class:souffle::Relation::iterator
iterator	SouffleInterface.h	/^    class iterator {$/;"	c	class:souffle::Relation
iterator	Table.h	/^        iterator(Block* block = nullptr, unsigned pos = 0) : block(block), pos(pos) {}$/;"	f	class:souffle::Table::iterator
iterator	Table.h	/^    class iterator : public std::iterator<std::forward_iterator_tag, T> {$/;"	c	class:souffle::Table
iterator	parser.hh	/^      typedef typename S::reverse_iterator iterator;$/;"	t	class:yy::parser::stack
iterator_base	InterpreterInterface.h	/^        iterator_base(uint32_t arg_id, const InterpreterRelInterface* r, InterpreterRelation::iterator i)$/;"	f	class:souffle::InterpreterRelInterface::iterator_base
iterator_base	InterpreterInterface.h	/^    class iterator_base : public Relation::iterator_base {$/;"	c	class:souffle::InterpreterRelInterface
iterator_base	SouffleInterface.h	/^        iterator_base(uint32_t arg_id) : id(arg_id) {}$/;"	f	class:souffle::Relation::iterator_base
iterator_base	SouffleInterface.h	/^    class iterator_base {$/;"	c	class:souffle::Relation
iterator_core	Brie.h	/^        iterator_core(bool end = true) : end(end) {}$/;"	f	class:souffle::Trie::iterator_core
iterator_core	Brie.h	/^        iterator_core(bool end, Tuple&) : end(end) {}$/;"	f	class:souffle::Trie::iterator_core
iterator_core	Brie.h	/^        iterator_core(const iter_type& iter, Tuple& entry) : iter(iter) {$/;"	f	class:souffle::Trie::iterator_core
iterator_core	Brie.h	/^        iterator_core(const store_iter_t& iter, Tuple& entry) : iter(iter) {$/;"	f	class:souffle::Trie::iterator_core
iterator_core	Brie.h	/^    class iterator_core {$/;"	c	class:souffle::Trie
iterator_utils	CompiledIndexUtils.h	/^namespace iterator_utils {$/;"	n	namespace:souffle::ram
iterator_wrapper	CompiledSouffle.h	/^        iterator_wrapper(uint32_t arg_id, const Relation* rel, const typename RelType::iterator& arg_it)$/;"	f	class:souffle::RelationWrapper::iterator_wrapper
iterator_wrapper	CompiledSouffle.h	/^    class iterator_wrapper : public iterator_base {$/;"	c	class:souffle::RelationWrapper
ityp	EquivalenceRelation.h	/^        IterType ityp;$/;"	m	class:souffle::EquivalenceRelation::iterator
j	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
join	Util.h	/^detail::joined_sequence<Iter, Printer> join($/;"	f	namespace:souffle
join	Util.h	/^detail::joined_sequence<Iter, Printer> join(const Container& c, const std::string& sep, const Printer& p) {$/;"	f	namespace:souffle
join	Util.h	/^detail::joined_sequence<Iter, detail::print<id<T>>> join($/;"	f	namespace:souffle
join	Util.h	/^detail::joined_sequence<Iter, detail::print<id<T>>> join(const Container& c, const std::string& sep = ",") {$/;"	f	namespace:souffle
joined_sequence	Util.h	/^    joined_sequence(const Iter& a, const Iter& b, std::string sep, Printer p)$/;"	f	class:souffle::detail::joined_sequence
joined_sequence	Util.h	/^class joined_sequence {$/;"	c	namespace:souffle::detail
jsChartistMin	profile/htmlJsChartistMin.h	/^std::string jsChartistMin = R"___($/;"	m	namespace:souffle::profile::html
jsChartistPlugin	profile/htmlJsChartistPlugin.h	/^std::string jsChartistPlugin = R"___($/;"	m	namespace:souffle::profile::html
jsTableSort	profile/htmlJsTableSort.h	/^std::string jsTableSort = R"___($/;"	m	namespace:souffle::profile::html
jsUtil	profile/htmlJsUtil.h	/^std::string jsUtil = R"___($/;"	m	namespace:souffle::profile::html
json	Explain.h	/^    bool json;$/;"	m	class:souffle::Explain
json11	json11.h	/^namespace json11 {$/;"	n
k	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
key	AstPragma.h	/^    std::string key;$/;"	m	class:souffle::AstPragma
key	ProfileDatabase.h	/^    std::string key;$/;"	m	class:souffle::profile::Entry
keys	BTree.h	/^        Key keys[maxKeys];$/;"	m	struct:souffle::detail::btree::node
keys	RamOperation.h	/^    SearchColumns keys = 0;$/;"	m	class:souffle::RamAggregate
kind_type	parser.hh	/^      typedef state_type kind_type;$/;"	t	struct:yy::parser::by_state
kind_type	parser.hh	/^      typedef token_type kind_type;$/;"	t	struct:yy::parser::by_type
kvps	AstIO.h	/^    std::map<std::string, std::string> kvps;$/;"	m	class:souffle::AstIO
l	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
label	ExplainTree.h	/^    std::string label;$/;"	m	class:souffle::InnerNode
label	Logger.h	/^    std::string label;$/;"	m	class:souffle::Logger
lambda	AstNode.h	/^    const Lambda& lambda;$/;"	m	class:souffle::detail::LambdaNodeMapper
lambda	AstVisitor.h	/^    std::function<R(const N&)> lambda;$/;"	m	struct:souffle::detail::LambdaAstVisitor
lambda	RamNode.h	/^    const Lambda& lambda;$/;"	m	class:souffle::detail::LambdaRamNodeMapper
lambda	RamVisitor.h	/^    std::function<R(const N&)> lambda;$/;"	m	struct:souffle::detail::LambdaRamVisitor
last_find_end	BTree.h	/^        node_cache last_find_end;$/;"	m	struct:souffle::detail::btree::btree_operation_hints
last_lower_bound_end	BTree.h	/^        node_cache last_lower_bound_end;$/;"	m	struct:souffle::detail::btree::btree_operation_hints
last_upper_bound_end	BTree.h	/^        node_cache last_upper_bound_end;$/;"	m	struct:souffle::detail::btree::btree_operation_hints
lck	ParallelUtils.h	/^    std::atomic<int> lck;$/;"	m	class:souffle::ReadWriteLock
lck	ParallelUtils.h	/^    std::atomic<int> lck;$/;"	m	class:souffle::SpinLock
leaf_node	BTree.h	/^        leaf_node() : node(false) {}$/;"	f	struct:souffle::detail::btree::leaf_node
leaf_node	BTree.h	/^    struct leaf_node : public node {$/;"	s	class:souffle::detail::btree
lease	ParallelUtils.h	/^        Lease(const Lease& lease) = default;$/;"	m	class:souffle::OptimisticReadWriteLock::Lease
lease	WriteStreamCSV.h	/^    Lock::Lease lease;$/;"	m	class:souffle::WriteCoutPrintSize
leftmost	BTree.h	/^    leaf_node* leftmost;$/;"	m	class:souffle::detail::btree
less	BTree.h	/^    bool less(const Key& a, const Key& b) const {$/;"	f	class:souffle::detail::btree
less	BTree.h	/^    bool less(const T& a, const T& b) const {$/;"	f	struct:souffle::detail::comparator
less	CompiledIndexUtils.h	/^    bool less(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::comparator
less	CompiledIndexUtils.h	/^    bool less(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::deref_compare
less	InterpreterIndex.h	/^        bool less(const RamDomain* x, const RamDomain* y) const {$/;"	f	struct:souffle::InterpreterIndex::comparator
less	UnionFind.h	/^    bool less(const StorePair& a, const StorePair& b) {$/;"	f	struct:souffle::EqrelMapComparator
level	AstTranslator.h	/^        int level = 0;$/;"	m	class:souffle::AstTranslator::ClauseTranslator
level	Interpreter.h	/^    int level = 0;$/;"	m	class:souffle::LowLevelMachine
level	profile/Rule.h	/^    const size_t level;$/;"	m	class:souffle::profile::Atom
levelConditions	RamTransforms.cpp	/^bool LevelConditionsTransformer::levelConditions(RamProgram& program) {$/;"	f	class:souffle::LevelConditionsTransformer
levels	Brie.h	/^        uint32_t levels;$/;"	m	struct:souffle::SparseArray::RootInfo
levels	Brie.h	/^        uint32_t levels;$/;"	m	struct:souffle::SparseArray::RootInfoSnapshot
lhs	AstLiteral.h	/^    std::unique_ptr<AstArgument> lhs;$/;"	m	class:souffle::AstBinaryConstraint
lhs	RamCondition.h	/^    std::unique_ptr<RamCondition> lhs;$/;"	m	class:souffle::RamConjunction
lhs	RamCondition.h	/^    std::unique_ptr<RamExpression> lhs;$/;"	m	class:souffle::RamConstraint
lhs	ResolveAliasesTransformer.cpp	/^    std::unique_ptr<AstArgument> lhs;$/;"	m	class:souffle::__anon71::Equation	file:
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libsouffle_la_CXXFLAGS	Makefile	/^libsouffle_la_CXXFLAGS = $(souffle_CPPFLAGS) $(FFI_CFLAGS)$/;"	m
libsouffle_la_LDFLAGS	Makefile	/^libsouffle_la_LDFLAGS = --static --dlopen --pic -ldl -lffi$/;"	m
libsouffle_la_LIBADD	Makefile	/^libsouffle_la_LIBADD =$/;"	m
libsouffle_la_LINK	Makefile	/^libsouffle_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
libsouffle_la_OBJECTS	Makefile	/^libsouffle_la_OBJECTS = $(am_libsouffle_la_OBJECTS)$/;"	m
libsouffle_la_SOURCES	Makefile	/^libsouffle_la_SOURCES = $(souffle_sources)$/;"	m
libz_sources	Makefile	/^libz_sources = gzfstream.h$/;"	m
likely	UnionFind.h	/^#define likely(/;"	d
line	SrcLocation.h	/^        int line;$/;"	m	struct:souffle::SrcLocation::Point
lineNumber	ReadStreamCSV.h	/^    size_t lineNumber;$/;"	m	class:souffle::ReadStreamCSV
linear	BTree.h	/^struct linear : public strategy_selection<linear_search> {};$/;"	s	namespace:souffle::detail
linear_search	BTree.h	/^struct linear_search : public search_strategy {$/;"	s	namespace:souffle::detail
linereader	profile/Tui.h	/^    InputReader linereader;$/;"	m	class:souffle::profile::Tui
link	SouffleInterface.h	/^    ProgramFactory* link = nullptr;$/;"	m	class:souffle::ProgramFactory
literal	AstParserUtils.h	/^    struct literal {$/;"	s	class:souffle::RuleBody
load	BTree.h	/^    load(const Iter& a, const Iter& b) {$/;"	f	class:souffle::detail::btree
load	BTree.h	/^    static btree_multiset load(const Iter& a, const Iter& b) {$/;"	f	class:souffle::btree_multiset
load	BTree.h	/^    static btree_set load(const Iter& a, const Iter& b) {$/;"	f	class:souffle::btree_set
load	LambdaBTree.h	/^    static LambdaBTreeSet load(const Iter& a, const Iter& b) {$/;"	f	class:souffle::LambdaBTreeSet
loadDLL	Interpreter.h	/^    void* loadDLL() {$/;"	f	class:souffle::Interpreter
loaded	profile/Reader.h	/^    bool loaded = false;$/;"	m	class:souffle::profile::Reader
loaded	profile/Tui.h	/^    bool loaded;$/;"	m	class:souffle::profile::Tui
loads	AstComponent.h	/^    std::vector<std::unique_ptr<AstLoad>> loads;$/;"	m	class:souffle::AstComponent
loads	AstProgram.h	/^    std::vector<std::unique_ptr<AstLoad>> loads;$/;"	m	class:souffle::AstProgram
loads	AstRelation.h	/^    std::vector<std::unique_ptr<AstLoad>> loads;$/;"	m	class:souffle::AstRelation
loads	ComponentModel.cpp	/^    std::vector<std::unique_ptr<AstLoad>> loads;$/;"	m	struct:souffle::__anon73::ComponentContent	file:
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
location	AstNode.h	/^    SrcLocation location;$/;"	m	class:souffle::AstNode
location	ErrorReport.h	/^    SrcLocation location;$/;"	m	class:souffle::DiagnosticMessage
location	parser.hh	/^      location_type location;$/;"	m	struct:yy::parser::basic_symbol
location	parser.hh	/^      location_type location;$/;"	m	struct:yy::parser::syntax_error
location_type	parser.hh	/^    typedef SrcLocation location_type;$/;"	t	class:yy::parser
locator	profile/Iteration.h	/^    std::string locator = "";$/;"	m	class:souffle::profile::Iteration
locator	profile/Relation.h	/^    std::string locator;$/;"	m	class:souffle::profile::Relation
lock	BTree.h	/^        lock_type lock;$/;"	m	struct:souffle::detail::btree::base
lock	CompiledRelation.h	/^    std::mutex lock;$/;"	m	class:souffle::ram::detail::GenericRelation
lock	InterpreterRelation.h	/^    mutable Lock lock;$/;"	m	class:souffle::InterpreterRelation
lock	ParallelUtils.h	/^    void lock() {$/;"	f	class:souffle::Lock
lock	ParallelUtils.h	/^    void lock() {$/;"	f	class:souffle::SpinLock
lock	ParallelUtils.h	/^    void lock() {}$/;"	f	class:souffle::souffle::SpinLock
lock	ParallelUtils.h	/^    void lock() {}$/;"	f	struct:souffle::souffle::Lock
lock	ProfileDatabase.h	/^    mutable std::mutex lock;$/;"	m	class:souffle::profile::DirectoryEntry
logMessages	SignalHandler.h	/^    bool logMessages = false;$/;"	m	class:souffle::SignalHandler
logstream	test/test.h	/^    std::ostream& logstream;  \/\/ logfile$/;"	m	class:TestCase
longName	Global.h	/^    std::string longName;  \/* The long name for this option, e.g. 'option' for '--option'. *\/$/;"	m	struct:souffle::MainOption
long_value	json11.h	/^inline long long Json::long_value() const {$/;"	f	class:json11::Json
long_value	json11.h	/^inline long long JsonValue::long_value() const {$/;"	f	class:json11::JsonValue
lookUpIndexScanIterator	Interpreter.h	/^    std::pair<index_set::iterator, index_set::iterator>& lookUpIndexScanIterator(size_t idx) {$/;"	f	class:souffle::LowLevelMachine
lookUpScanIterator	Interpreter.h	/^    std::pair<InterpreterRelation::iterator, InterpreterRelation::iterator>& lookUpScanIterator(size_t idx) {$/;"	f	class:souffle::LowLevelMachine
lookup	Brie.h	/^    value_type lookup(index_type i) const {$/;"	f	class:souffle::SparseArray
lookup	Brie.h	/^    value_type lookup(index_type i, op_context& ctxt) const {$/;"	f	class:souffle::SparseArray
lookup	StringPool.h	/^    inline const char* lookup(const char* str) {$/;"	f	class:souffle::StringPool
lookup	SymbolTable.h	/^    RamDomain lookup(const std::string& symbol) {$/;"	f	class:souffle::SymbolTable
lookupAddress	Interpreter.h	/^       size_t lookupAddress(size_t addressLabel) {$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
lookupExisting	SymbolTable.h	/^    RamDomain lookupExisting(const std::string& symbol) const {$/;"	f	class:souffle::SymbolTable
lookupFreqIdx	Synthesiser.cpp	/^unsigned Synthesiser::lookupFreqIdx(const std::string& txt) {$/;"	f	class:souffle::Synthesiser
lookupReadIdx	Synthesiser.cpp	/^size_t Synthesiser::lookupReadIdx(const std::string& txt) {$/;"	f	class:souffle::Synthesiser
lower	CompiledIndexUtils.h	/^T lower(T tuple) {$/;"	f	namespace:souffle::ram::index_utils
lowerBound	Brie.h	/^    iterator lowerBound(index_type i) const {$/;"	f	class:souffle::SparseArray
lowerBound	Brie.h	/^    iterator lowerBound(index_type i, op_context&) const {$/;"	f	class:souffle::SparseArray
lowerUpperBound	InterpreterIndex.h	/^    inline std::pair<iterator, iterator> lowerUpperBound(const RamDomain* low, const RamDomain* high) const {$/;"	f	class:souffle::InterpreterIndex
lower_bound	BTree.h	/^        CacheAccessCounter lower_bound;$/;"	m	struct:souffle::detail::btree::hint_statistics
lower_bound	BTree.h	/^    Iter lower_bound(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::binary_search
lower_bound	BTree.h	/^    inline Iter lower_bound(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::linear_search
lower_bound	BTree.h	/^    iterator lower_bound(const Key& k) const {$/;"	f	class:souffle::detail::btree
lower_bound	BTree.h	/^    iterator lower_bound(const Key& k, operation_hints& hints) const {$/;"	f	class:souffle::detail::btree
m	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
mDebug	main.cpp	/^bool mDebug = false;    \/\/TODO Owen$/;"	m	namespace:souffle	file:
m_ptr	json11.h	/^    std::shared_ptr<JsonValue> m_ptr;$/;"	m	class:json11::final
m_size	PiggyList.h	/^    std::atomic<size_t> m_size;$/;"	m	class:souffle::PiggyList
m_value	json11.h	/^    const T m_value;$/;"	m	class:json11::Value
main	RamProgram.h	/^    std::unique_ptr<RamStatement> main;$/;"	m	class:souffle::RamProgram
main	main.cpp	/^int main(int argc, char** argv) {$/;"	f
main	main.cpp	/^int main(int argc, char** argv) {$/;"	f	namespace:souffle
main	souffle2bdd.cpp	/^int main(int argc, char** argv) {$/;"	f
main	souffle2bdd.cpp	/^int main(int argc, char** argv) {$/;"	f	namespace:souffle
main	souffle2lb.cpp	/^int main(int argc, char** argv) {$/;"	f
main	souffle2lb.cpp	/^int main(int argc, char** argv) {$/;"	f	namespace:souffle
main	souffle_prof.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	test/test.h	/^int main(int argc, char** argv) {$/;"	f
makeConfigRecord	ProfileEvent.h	/^    void makeConfigRecord(const std::string& key, const std::string& value) {$/;"	f	class:souffle::ProfileEventSingleton
makeIODirective	AstTranslator.cpp	/^void AstTranslator::makeIODirective(IODirectives& ioDirective, const AstRelation* rel,$/;"	f	class:souffle::AstTranslator
makeInfoRelation	ProvenanceTransformer.cpp	/^std::unique_ptr<AstRelation> makeInfoRelation($/;"	f	namespace:souffle
makeLambdaAstMapper	AstNode.h	/^detail::LambdaNodeMapper<Lambda> makeLambdaAstMapper(const Lambda& lambda) {$/;"	f	namespace:souffle
makeLambdaAstVisitor	AstVisitor.h	/^LambdaAstVisitor<R, N> makeLambdaAstVisitor(const std::function<R(const N&)>& fun) {$/;"	f	namespace:souffle::detail
makeLambdaRamMapper	RamNode.h	/^detail::LambdaRamNodeMapper<Lambda> makeLambdaRamMapper(const Lambda& lambda) {$/;"	f	namespace:souffle
makeLambdaRamVisitor	RamVisitor.h	/^LambdaRamVisitor<R, N> makeLambdaRamVisitor(const std::function<R(const N&)>& fun) {$/;"	f	namespace:souffle::detail
makeNode	UnionFind.h	/^    inline block_t makeNode() {$/;"	f	class:souffle::DisjointSet
makeNode	UnionFind.h	/^    inline void makeNode(SparseDomain val) {$/;"	f	class:souffle::SparseDisjointSet
makeQuantityEvent	ProfileEvent.h	/^    void makeQuantityEvent(const std::string& txt, size_t number, int iteration) {$/;"	f	class:souffle::ProfileEventSingleton
makeRamElementAccess	AstTranslator.cpp	/^std::unique_ptr<RamElementAccess> AstTranslator::makeRamElementAccess(const Location& loc) {$/;"	f	class:souffle::AstTranslator
makeRelationName	ProvenanceTransformer.cpp	/^inline AstRelationIdentifier makeRelationName($/;"	f	namespace:souffle
makeStratumRecord	ProfileEvent.h	/^    void makeStratumRecord(size_t index, const std::string& type, const std::string& relName,$/;"	f	class:souffle::ProfileEventSingleton
makeSubproofSubroutine	AstTranslator.cpp	/^std::unique_ptr<RamStatement> AstTranslator::makeSubproofSubroutine(const AstClause& clause) {$/;"	f	class:souffle::AstTranslator
makeTimeEvent	ProfileEvent.h	/^    void makeTimeEvent(const std::string& txt) {$/;"	f	class:souffle::ProfileEventSingleton
makeTimingEvent	ProfileEvent.h	/^    void makeTimingEvent(const std::string& txt, time_point start, time_point end, size_t startMaxRSS,$/;"	f	class:souffle::ProfileEventSingleton
makeUtilisationEvent	ProfileEvent.h	/^    void makeUtilisationEvent(const std::string& txt) {$/;"	f	class:souffle::ProfileEventSingleton
make_AS	parser.hh	/^      make_AS (const location_type& l)$/;"	f	class:yy::parser
make_AS	parser.hh	/^      make_AS (location_type l)$/;"	f	class:yy::parser
make_AT	parser.hh	/^      make_AT (const location_type& l)$/;"	f	class:yy::parser
make_AT	parser.hh	/^      make_AT (location_type l)$/;"	f	class:yy::parser
make_BRIE_QUALIFIER	parser.hh	/^      make_BRIE_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_BRIE_QUALIFIER	parser.hh	/^      make_BRIE_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_BTREE_QUALIFIER	parser.hh	/^      make_BTREE_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_BTREE_QUALIFIER	parser.hh	/^      make_BTREE_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_BW_AND	parser.hh	/^      make_BW_AND (const location_type& l)$/;"	f	class:yy::parser
make_BW_AND	parser.hh	/^      make_BW_AND (location_type l)$/;"	f	class:yy::parser
make_BW_NOT	parser.hh	/^      make_BW_NOT (const location_type& l)$/;"	f	class:yy::parser
make_BW_NOT	parser.hh	/^      make_BW_NOT (location_type l)$/;"	f	class:yy::parser
make_BW_OR	parser.hh	/^      make_BW_OR (const location_type& l)$/;"	f	class:yy::parser
make_BW_OR	parser.hh	/^      make_BW_OR (location_type l)$/;"	f	class:yy::parser
make_BW_XOR	parser.hh	/^      make_BW_XOR (const location_type& l)$/;"	f	class:yy::parser
make_BW_XOR	parser.hh	/^      make_BW_XOR (location_type l)$/;"	f	class:yy::parser
make_CARET	parser.hh	/^      make_CARET (const location_type& l)$/;"	f	class:yy::parser
make_CARET	parser.hh	/^      make_CARET (location_type l)$/;"	f	class:yy::parser
make_CAT	parser.hh	/^      make_CAT (const location_type& l)$/;"	f	class:yy::parser
make_CAT	parser.hh	/^      make_CAT (location_type l)$/;"	f	class:yy::parser
make_COLON	parser.hh	/^      make_COLON (const location_type& l)$/;"	f	class:yy::parser
make_COLON	parser.hh	/^      make_COLON (location_type l)$/;"	f	class:yy::parser
make_COMMA	parser.hh	/^      make_COMMA (const location_type& l)$/;"	f	class:yy::parser
make_COMMA	parser.hh	/^      make_COMMA (location_type l)$/;"	f	class:yy::parser
make_COMPONENT	parser.hh	/^      make_COMPONENT (const location_type& l)$/;"	f	class:yy::parser
make_COMPONENT	parser.hh	/^      make_COMPONENT (location_type l)$/;"	f	class:yy::parser
make_COUNT	parser.hh	/^      make_COUNT (const location_type& l)$/;"	f	class:yy::parser
make_COUNT	parser.hh	/^      make_COUNT (location_type l)$/;"	f	class:yy::parser
make_DECL	parser.hh	/^      make_DECL (const location_type& l)$/;"	f	class:yy::parser
make_DECL	parser.hh	/^      make_DECL (location_type l)$/;"	f	class:yy::parser
make_DOLLAR	parser.hh	/^      make_DOLLAR (const location_type& l)$/;"	f	class:yy::parser
make_DOLLAR	parser.hh	/^      make_DOLLAR (location_type l)$/;"	f	class:yy::parser
make_DOT	parser.hh	/^      make_DOT (const location_type& l)$/;"	f	class:yy::parser
make_DOT	parser.hh	/^      make_DOT (location_type l)$/;"	f	class:yy::parser
make_END	parser.hh	/^      make_END (const location_type& l)$/;"	f	class:yy::parser
make_END	parser.hh	/^      make_END (location_type l)$/;"	f	class:yy::parser
make_EQREL_QUALIFIER	parser.hh	/^      make_EQREL_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_EQREL_QUALIFIER	parser.hh	/^      make_EQREL_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_EQUALS	parser.hh	/^      make_EQUALS (const location_type& l)$/;"	f	class:yy::parser
make_EQUALS	parser.hh	/^      make_EQUALS (location_type l)$/;"	f	class:yy::parser
make_EXCLAMATION	parser.hh	/^      make_EXCLAMATION (const location_type& l)$/;"	f	class:yy::parser
make_EXCLAMATION	parser.hh	/^      make_EXCLAMATION (location_type l)$/;"	f	class:yy::parser
make_FALSE	parser.hh	/^      make_FALSE (const location_type& l)$/;"	f	class:yy::parser
make_FALSE	parser.hh	/^      make_FALSE (location_type l)$/;"	f	class:yy::parser
make_FUNCTOR	parser.hh	/^      make_FUNCTOR (const location_type& l)$/;"	f	class:yy::parser
make_FUNCTOR	parser.hh	/^      make_FUNCTOR (location_type l)$/;"	f	class:yy::parser
make_GT	parser.hh	/^      make_GT (const location_type& l)$/;"	f	class:yy::parser
make_GT	parser.hh	/^      make_GT (location_type l)$/;"	f	class:yy::parser
make_IDENT	parser.hh	/^      make_IDENT (const std::string& v, const location_type& l)$/;"	f	class:yy::parser
make_IDENT	parser.hh	/^      make_IDENT (std::string v, location_type l)$/;"	f	class:yy::parser
make_IF	parser.hh	/^      make_IF (const location_type& l)$/;"	f	class:yy::parser
make_IF	parser.hh	/^      make_IF (location_type l)$/;"	f	class:yy::parser
make_INLINE_QUALIFIER	parser.hh	/^      make_INLINE_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_INLINE_QUALIFIER	parser.hh	/^      make_INLINE_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_INPUT_DECL	parser.hh	/^      make_INPUT_DECL (const location_type& l)$/;"	f	class:yy::parser
make_INPUT_DECL	parser.hh	/^      make_INPUT_DECL (location_type l)$/;"	f	class:yy::parser
make_INPUT_QUALIFIER	parser.hh	/^      make_INPUT_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_INPUT_QUALIFIER	parser.hh	/^      make_INPUT_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_INSTANTIATE	parser.hh	/^      make_INSTANTIATE (const location_type& l)$/;"	f	class:yy::parser
make_INSTANTIATE	parser.hh	/^      make_INSTANTIATE (location_type l)$/;"	f	class:yy::parser
make_LBRACE	parser.hh	/^      make_LBRACE (const location_type& l)$/;"	f	class:yy::parser
make_LBRACE	parser.hh	/^      make_LBRACE (location_type l)$/;"	f	class:yy::parser
make_LBRACKET	parser.hh	/^      make_LBRACKET (const location_type& l)$/;"	f	class:yy::parser
make_LBRACKET	parser.hh	/^      make_LBRACKET (location_type l)$/;"	f	class:yy::parser
make_LPAREN	parser.hh	/^      make_LPAREN (const location_type& l)$/;"	f	class:yy::parser
make_LPAREN	parser.hh	/^      make_LPAREN (location_type l)$/;"	f	class:yy::parser
make_LT	parser.hh	/^      make_LT (const location_type& l)$/;"	f	class:yy::parser
make_LT	parser.hh	/^      make_LT (location_type l)$/;"	f	class:yy::parser
make_L_AND	parser.hh	/^      make_L_AND (const location_type& l)$/;"	f	class:yy::parser
make_L_AND	parser.hh	/^      make_L_AND (location_type l)$/;"	f	class:yy::parser
make_L_NOT	parser.hh	/^      make_L_NOT (const location_type& l)$/;"	f	class:yy::parser
make_L_NOT	parser.hh	/^      make_L_NOT (location_type l)$/;"	f	class:yy::parser
make_L_OR	parser.hh	/^      make_L_OR (const location_type& l)$/;"	f	class:yy::parser
make_L_OR	parser.hh	/^      make_L_OR (location_type l)$/;"	f	class:yy::parser
make_MAX	parser.hh	/^      make_MAX (const location_type& l)$/;"	f	class:yy::parser
make_MAX	parser.hh	/^      make_MAX (location_type l)$/;"	f	class:yy::parser
make_MIN	parser.hh	/^      make_MIN (const location_type& l)$/;"	f	class:yy::parser
make_MIN	parser.hh	/^      make_MIN (location_type l)$/;"	f	class:yy::parser
make_MINUS	parser.hh	/^      make_MINUS (const location_type& l)$/;"	f	class:yy::parser
make_MINUS	parser.hh	/^      make_MINUS (location_type l)$/;"	f	class:yy::parser
make_NEG	parser.hh	/^      make_NEG (const location_type& l)$/;"	f	class:yy::parser
make_NEG	parser.hh	/^      make_NEG (location_type l)$/;"	f	class:yy::parser
make_NIL	parser.hh	/^      make_NIL (const location_type& l)$/;"	f	class:yy::parser
make_NIL	parser.hh	/^      make_NIL (location_type l)$/;"	f	class:yy::parser
make_NUMBER	parser.hh	/^      make_NUMBER (AstDomain v, location_type l)$/;"	f	class:yy::parser
make_NUMBER	parser.hh	/^      make_NUMBER (const AstDomain& v, const location_type& l)$/;"	f	class:yy::parser
make_NUMBER_TYPE	parser.hh	/^      make_NUMBER_TYPE (const location_type& l)$/;"	f	class:yy::parser
make_NUMBER_TYPE	parser.hh	/^      make_NUMBER_TYPE (location_type l)$/;"	f	class:yy::parser
make_ORD	parser.hh	/^      make_ORD (const location_type& l)$/;"	f	class:yy::parser
make_ORD	parser.hh	/^      make_ORD (location_type l)$/;"	f	class:yy::parser
make_OUTPUT_DECL	parser.hh	/^      make_OUTPUT_DECL (const location_type& l)$/;"	f	class:yy::parser
make_OUTPUT_DECL	parser.hh	/^      make_OUTPUT_DECL (location_type l)$/;"	f	class:yy::parser
make_OUTPUT_QUALIFIER	parser.hh	/^      make_OUTPUT_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_OUTPUT_QUALIFIER	parser.hh	/^      make_OUTPUT_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_OVERRIDABLE_QUALIFIER	parser.hh	/^      make_OVERRIDABLE_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_OVERRIDABLE_QUALIFIER	parser.hh	/^      make_OVERRIDABLE_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_OVERRIDE	parser.hh	/^      make_OVERRIDE (const location_type& l)$/;"	f	class:yy::parser
make_OVERRIDE	parser.hh	/^      make_OVERRIDE (location_type l)$/;"	f	class:yy::parser
make_PERCENT	parser.hh	/^      make_PERCENT (const location_type& l)$/;"	f	class:yy::parser
make_PERCENT	parser.hh	/^      make_PERCENT (location_type l)$/;"	f	class:yy::parser
make_PIPE	parser.hh	/^      make_PIPE (const location_type& l)$/;"	f	class:yy::parser
make_PIPE	parser.hh	/^      make_PIPE (location_type l)$/;"	f	class:yy::parser
make_PLAN	parser.hh	/^      make_PLAN (const location_type& l)$/;"	f	class:yy::parser
make_PLAN	parser.hh	/^      make_PLAN (location_type l)$/;"	f	class:yy::parser
make_PLUS	parser.hh	/^      make_PLUS (const location_type& l)$/;"	f	class:yy::parser
make_PLUS	parser.hh	/^      make_PLUS (location_type l)$/;"	f	class:yy::parser
make_PRAGMA	parser.hh	/^      make_PRAGMA (const location_type& l)$/;"	f	class:yy::parser
make_PRAGMA	parser.hh	/^      make_PRAGMA (location_type l)$/;"	f	class:yy::parser
make_PRINTSIZE_DECL	parser.hh	/^      make_PRINTSIZE_DECL (const location_type& l)$/;"	f	class:yy::parser
make_PRINTSIZE_DECL	parser.hh	/^      make_PRINTSIZE_DECL (location_type l)$/;"	f	class:yy::parser
make_PRINTSIZE_QUALIFIER	parser.hh	/^      make_PRINTSIZE_QUALIFIER (const location_type& l)$/;"	f	class:yy::parser
make_PRINTSIZE_QUALIFIER	parser.hh	/^      make_PRINTSIZE_QUALIFIER (location_type l)$/;"	f	class:yy::parser
make_RBRACE	parser.hh	/^      make_RBRACE (const location_type& l)$/;"	f	class:yy::parser
make_RBRACE	parser.hh	/^      make_RBRACE (location_type l)$/;"	f	class:yy::parser
make_RBRACKET	parser.hh	/^      make_RBRACKET (const location_type& l)$/;"	f	class:yy::parser
make_RBRACKET	parser.hh	/^      make_RBRACKET (location_type l)$/;"	f	class:yy::parser
make_RELOP	parser.hh	/^      make_RELOP (const std::string& v, const location_type& l)$/;"	f	class:yy::parser
make_RELOP	parser.hh	/^      make_RELOP (std::string v, location_type l)$/;"	f	class:yy::parser
make_RESERVED	parser.hh	/^      make_RESERVED (const std::string& v, const location_type& l)$/;"	f	class:yy::parser
make_RESERVED	parser.hh	/^      make_RESERVED (std::string v, location_type l)$/;"	f	class:yy::parser
make_RPAREN	parser.hh	/^      make_RPAREN (const location_type& l)$/;"	f	class:yy::parser
make_RPAREN	parser.hh	/^      make_RPAREN (location_type l)$/;"	f	class:yy::parser
make_SEMICOLON	parser.hh	/^      make_SEMICOLON (const location_type& l)$/;"	f	class:yy::parser
make_SEMICOLON	parser.hh	/^      make_SEMICOLON (location_type l)$/;"	f	class:yy::parser
make_SLASH	parser.hh	/^      make_SLASH (const location_type& l)$/;"	f	class:yy::parser
make_SLASH	parser.hh	/^      make_SLASH (location_type l)$/;"	f	class:yy::parser
make_STAR	parser.hh	/^      make_STAR (const location_type& l)$/;"	f	class:yy::parser
make_STAR	parser.hh	/^      make_STAR (location_type l)$/;"	f	class:yy::parser
make_STRICT	parser.hh	/^      make_STRICT (const location_type& l)$/;"	f	class:yy::parser
make_STRICT	parser.hh	/^      make_STRICT (location_type l)$/;"	f	class:yy::parser
make_STRING	parser.hh	/^      make_STRING (const std::string& v, const location_type& l)$/;"	f	class:yy::parser
make_STRING	parser.hh	/^      make_STRING (std::string v, location_type l)$/;"	f	class:yy::parser
make_STRLEN	parser.hh	/^      make_STRLEN (const location_type& l)$/;"	f	class:yy::parser
make_STRLEN	parser.hh	/^      make_STRLEN (location_type l)$/;"	f	class:yy::parser
make_SUBSTR	parser.hh	/^      make_SUBSTR (const location_type& l)$/;"	f	class:yy::parser
make_SUBSTR	parser.hh	/^      make_SUBSTR (location_type l)$/;"	f	class:yy::parser
make_SUM	parser.hh	/^      make_SUM (const location_type& l)$/;"	f	class:yy::parser
make_SUM	parser.hh	/^      make_SUM (location_type l)$/;"	f	class:yy::parser
make_SYMBOL_TYPE	parser.hh	/^      make_SYMBOL_TYPE (const location_type& l)$/;"	f	class:yy::parser
make_SYMBOL_TYPE	parser.hh	/^      make_SYMBOL_TYPE (location_type l)$/;"	f	class:yy::parser
make_TCONTAINS	parser.hh	/^      make_TCONTAINS (const location_type& l)$/;"	f	class:yy::parser
make_TCONTAINS	parser.hh	/^      make_TCONTAINS (location_type l)$/;"	f	class:yy::parser
make_TMATCH	parser.hh	/^      make_TMATCH (const location_type& l)$/;"	f	class:yy::parser
make_TMATCH	parser.hh	/^      make_TMATCH (location_type l)$/;"	f	class:yy::parser
make_TONUMBER	parser.hh	/^      make_TONUMBER (const location_type& l)$/;"	f	class:yy::parser
make_TONUMBER	parser.hh	/^      make_TONUMBER (location_type l)$/;"	f	class:yy::parser
make_TOSTRING	parser.hh	/^      make_TOSTRING (const location_type& l)$/;"	f	class:yy::parser
make_TOSTRING	parser.hh	/^      make_TOSTRING (location_type l)$/;"	f	class:yy::parser
make_TRUE	parser.hh	/^      make_TRUE (const location_type& l)$/;"	f	class:yy::parser
make_TRUE	parser.hh	/^      make_TRUE (location_type l)$/;"	f	class:yy::parser
make_TYPE	parser.hh	/^      make_TYPE (const location_type& l)$/;"	f	class:yy::parser
make_TYPE	parser.hh	/^      make_TYPE (location_type l)$/;"	f	class:yy::parser
make_UNDERSCORE	parser.hh	/^      make_UNDERSCORE (const location_type& l)$/;"	f	class:yy::parser
make_UNDERSCORE	parser.hh	/^      make_UNDERSCORE (location_type l)$/;"	f	class:yy::parser
make_range	Util.h	/^range<Iter> make_range(const Iter& a, const Iter& b) {$/;"	f	namespace:souffle
make_unique	Util.h	/^typename _Unique_if<T>::_Single_object make_unique(Args&&... args) {$/;"	f	namespace:std
make_unique	Util.h	/^typename _Unique_if<T>::_Unknown_bound make_unique(size_t n) {$/;"	f	namespace:std
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
map	IndexSetAnalysis.h	/^    int map(SearchColumns cols) const {$/;"	f	class:souffle::IndexSet
mask	Brie.h	/^        uint64_t mask = 0;$/;"	m	class:souffle::SparseBitMap::iterator
mask	CompiledIndexUtils.h	/^struct mask<index<>, index<M...>, value> {$/;"	s	namespace:souffle::ram::index_utils
mask	CompiledIndexUtils.h	/^struct mask<index<F, R...>, index<M...>, value> {$/;"	s	namespace:souffle::ram::index_utils
masterIndex	SynthesiserRelation.h	/^    size_t masterIndex = -1;$/;"	m	class:souffle::SynthesiserRelation
matching	IndexSetAnalysis.h	/^    MaxMatching matching;         \/\/ matching problem for finding minimal number of orders$/;"	m	class:souffle::IndexSet
materializeAggregationQueries	AstTransforms.cpp	/^bool MaterializeAggregationQueriesTransformer::materializeAggregationQueries($/;"	f	class:souffle::MaterializeAggregationQueriesTransformer
max	AstArgument.h	/^    enum Op { min, max, count, sum };$/;"	e	enum:souffle::AstAggregator::Op
maxContainers	PiggyList.h	/^    static constexpr size_t maxContainers = 64;$/;"	m	class:souffle::RandomInsertPiggyList
maxKeys	BTree.h	/^            maxKeys = (desiredNumKeys > 3) ? desiredNumKeys : 3$/;"	e	enum:souffle::detail::btree::node::__anon69
maxRSS	profile/Tui.h	/^        uint64_t maxRSS;$/;"	m	struct:souffle::profile::Tui::Usage
maxVersion	AstClause.h	/^    int maxVersion = -1;$/;"	m	class:souffle::AstExecutionPlan
max_conts	PiggyList.h	/^    static constexpr size_t max_conts = 64;$/;"	m	class:souffle::PiggyList
max_depth	json11.h	/^static const int max_depth = 200;$/;"	m	namespace:json11
max_keys_per_node	BTree.h	/^        max_keys_per_node = node::maxKeys$/;"	e	enum:souffle::detail::btree::__anon70
maxx	Explain.h	/^    int maxx = 0, maxy = 0;$/;"	m	class:souffle::Explain
maxy	Explain.h	/^    int maxx = 0, maxy = 0;$/;"	m	class:souffle::Explain
memoryUsage	profile/Tui.h	/^    void memoryUsage($/;"	f	namespace:souffle::profile
memoryUsage	profile/Tui.h	/^    void memoryUsage(uint32_t height = 20) {$/;"	f	namespace:souffle::profile
merge	Brie.h	/^    static void merge(const Node* parent, Node*& trg, const Node* src, int levels) {$/;"	f	class:souffle::SparseArray
merge_op	Brie.h	/^    struct merge_op {$/;"	s	class:souffle::SparseBitMap
message	ErrorReport.h	/^    std::string message;$/;"	m	class:souffle::DiagnosticMessage
message	RamStatement.h	/^    std::string message;$/;"	m	class:souffle::RamDebugInfo
message	RamStatement.h	/^    std::string message;$/;"	m	class:souffle::RamLogSize
message	RamStatement.h	/^    std::string message;$/;"	m	class:souffle::RamLogTimer
min	AstArgument.h	/^    enum Op { min, max, count, sum };$/;"	e	enum:souffle::AstAggregator::Op
mkdir_p	Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mode	gzfstream.h	/^    std::ios_base::openmode mode = std::ios_base::in;$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
move	parser.cc	/^  parser::by_state::move (by_state& that)$/;"	f	class:yy::parser::by_state
move	parser.hh	/^    move (self_type& that)$/;"	f	class:yy::parser::semantic_type
move	parser.hh	/^    move (self_type&& that)$/;"	f	class:yy::parser::semantic_type
move	parser.hh	/^  parser::basic_symbol<Base>::move (basic_symbol& s)$/;"	f	class:yy::parser::basic_symbol
move	parser.hh	/^  parser::by_type::move (by_type& that)$/;"	f	class:yy::parser::by_type
moveCursor	profile/UserInputReader.h	/^    void moveCursor(char direction) {$/;"	f	class:souffle::profile::InputReader
moveCursorLeft	profile/UserInputReader.h	/^    void moveCursorLeft() {$/;"	f	class:souffle::profile::InputReader
moveCursorRight	profile/UserInputReader.h	/^    void moveCursorRight() {$/;"	f	class:souffle::profile::InputReader
movePtrVector	Util.h	/^void movePtrVector(std::vector<std::unique_ptr<X>>& source, std::vector<std::unique_ptr<Y>>& destination) {$/;"	f	namespace:souffle
moveToNextInMask	Brie.h	/^        bool moveToNextInMask() {$/;"	f	class:souffle::SparseBitMap::iterator
mpi	Mpi.h	/^namespace mpi {$/;"	n	namespace:souffle
msg	SignalHandler.h	/^    std::atomic<const char*> msg;$/;"	m	class:souffle::SignalHandler
msg	souffle2bdd.cpp	/^    std::string msg;$/;"	m	class:souffle::UnsupportedConstructException	file:
msg	souffle2lb.cpp	/^    std::string msg;$/;"	m	class:souffle::UnsupportedConstructException	file:
mux	ParallelUtils.h	/^        std::mutex* mux;$/;"	m	struct:souffle::Lock::Lease
mux	ParallelUtils.h	/^    std::mutex mux;$/;"	m	class:souffle::Lock
n	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
nNonrecursiveRelation	LogStatement.h	/^    static const std::string nNonrecursiveRelation($/;"	f	class:souffle::LogStatement
nNonrecursiveRule	LogStatement.h	/^    static const std::string nNonrecursiveRule($/;"	f	class:souffle::LogStatement
nRecursiveRelation	LogStatement.h	/^    static const std::string nRecursiveRelation($/;"	f	class:souffle::LogStatement
nRecursiveRule	LogStatement.h	/^    static const std::string nRecursiveRule(const std::string& relationName, const int version,$/;"	f	class:souffle::LogStatement
name	AstArgument.h	/^    std::string name;$/;"	m	class:souffle::AstUserDefinedFunctor
name	AstArgument.h	/^    std::string name;$/;"	m	class:souffle::AstVariable
name	AstAttribute.h	/^    std::string name;$/;"	m	class:souffle::AstAttribute
name	AstComponent.h	/^    std::string name;$/;"	m	class:souffle::AstComponentType
name	AstFunctorDeclaration.h	/^    const std::string name;$/;"	m	class:souffle::AstFunctorDeclaration
name	AstIOTypeAnalysis.h	/^    static constexpr const char* name = "IO=type-analysis";$/;"	m	class:souffle::IOType
name	AstLiteral.h	/^    AstRelationIdentifier name;$/;"	m	class:souffle::AstAtom
name	AstProfileUse.h	/^    static constexpr const char* name = "profile-use";$/;"	m	class:souffle::AstProfileUse
name	AstRelation.h	/^    AstRelationIdentifier name;$/;"	m	class:souffle::AstRelation
name	AstType.h	/^        std::string name;        \/\/ < the field name$/;"	m	struct:souffle::AstRecordType::Field
name	AstType.h	/^    AstTypeIdentifier name;$/;"	m	class:souffle::AstType
name	AstTypeAnalysis.h	/^    static constexpr const char* name = "type-analysis";$/;"	m	class:souffle::TypeAnalysis
name	AstTypeEnvironmentAnalysis.h	/^    static constexpr const char* name = "type-environment";$/;"	m	class:souffle::TypeEnvironmentAnalysis
name	CompiledSouffle.h	/^    std::string name;$/;"	m	class:souffle::RelationWrapper
name	ComponentModel.h	/^    static constexpr const char* name = "component-lookup";$/;"	m	class:souffle::ComponentLookup
name	IndexSetAnalysis.h	/^    static constexpr const char* name = "index-analysis";$/;"	m	class:souffle::IndexSetAnalysis
name	InterpreterInterface.h	/^    std::string name;$/;"	m	class:souffle::InterpreterRelInterface
name	MagicSet.h	/^    static constexpr const char* name = "adorned-clauses";$/;"	m	class:souffle::Adornment
name	PrecedenceGraph.h	/^    static constexpr const char* name = "precedence-graph";$/;"	m	class:souffle::PrecedenceGraph
name	PrecedenceGraph.h	/^    static constexpr const char* name = "recursive-clauses";$/;"	m	class:souffle::RecursiveClauses
name	PrecedenceGraph.h	/^    static constexpr const char* name = "redundant-relations";$/;"	m	class:souffle::RedundantRelations
name	PrecedenceGraph.h	/^    static constexpr const char* name = "relation-schedule";$/;"	m	class:souffle::RelationSchedule
name	PrecedenceGraph.h	/^    static constexpr const char* name = "scc-graph";$/;"	m	class:souffle::SCCGraph
name	PrecedenceGraph.h	/^    static constexpr const char* name = "topological-scc-graph";$/;"	m	class:souffle::TopologicallySortedSCCGraph
name	RamConditionLevel.h	/^    static constexpr const char* name = "condition-level-analysis";$/;"	m	class:souffle::RamConditionLevelAnalysis
name	RamConstValue.h	/^    static constexpr const char* name = "const-value-analysis";$/;"	m	class:souffle::RamConstValueAnalysis
name	RamExistenceCheckAnalysis.h	/^    static constexpr const char* name = "existence-check-analysis";$/;"	m	class:souffle::RamExistenceCheckAnalysis
name	RamExpression.h	/^    const std::string name;$/;"	m	class:souffle::RamUserDefinedOperator
name	RamExpressionLevel.h	/^    static constexpr const char* name = "value-level-analysis";$/;"	m	class:souffle::RamExpressionLevelAnalysis
name	RamIndexScanKeys.h	/^    static constexpr const char* name = "index-scan-keys-analysis";$/;"	m	class:souffle::RamIndexScanKeysAnalysis
name	RamOperationDepth.h	/^    static constexpr const char* name = "operation-depth-analysis";$/;"	m	class:souffle::RamOperationDepthAnalysis
name	RamProvenanceExistenceCheckAnalysis.h	/^    static constexpr const char* name = "provenance-existence-check-analysis";$/;"	m	class:souffle::RamProvenanceExistenceCheckAnalysis
name	RamRelation.h	/^    const std::string name;$/;"	m	class:souffle::RamRelation
name	SouffleInterface.h	/^    std::string name;$/;"	m	class:souffle::ProgramFactory
name	TypeSystem.h	/^        std::string name;  \/\/ < the name of the field$/;"	m	struct:souffle::RecordType::Field
name	TypeSystem.h	/^    AstTypeIdentifier name;$/;"	m	class:souffle::Type
name	profile/Relation.h	/^    const std::string name;$/;"	m	class:souffle::profile::Relation
name	profile/Rule.h	/^    const std::string name;$/;"	m	class:souffle::profile::Rule
nameInlinedUnderscores	InlineRelationsTransformer.cpp	/^void nameInlinedUnderscores(AstProgram& program) {$/;"	f	namespace:souffle
nameUnnamedVariables	AstTranslator.cpp	/^void AstTranslator::nameUnnamedVariables(AstClause* clause) {$/;"	f	class:souffle::AstTranslator
names	AstIO.h	/^    std::set<AstRelationIdentifier> names;$/;"	m	class:souffle::AstIO
names	AstRelationIdentifier.h	/^    std::vector<std::string> names;$/;"	m	class:souffle::AstRelationIdentifier
names	AstType.h	/^    std::vector<std::string> names;$/;"	m	class:souffle::AstTypeIdentifier
ncurses	Explain.h	/^    bool ncurses;$/;"	m	class:souffle::Explain
neIdxMap	Synthesiser.h	/^    std::map<std::string, size_t> neIdxMap;$/;"	m	class:souffle::Synthesiser
needsMaterializedRelation	AstTransforms.cpp	/^bool MaterializeAggregationQueriesTransformer::needsMaterializedRelation(const AstAggregator& agg) {$/;"	f	class:souffle::MaterializeAggregationQueriesTransformer
negate	AstParserUtils.cpp	/^void RuleBody::negate() {$/;"	f	class:souffle::RuleBody
negateLiteral	InlineRelationsTransformer.cpp	/^AstLiteral* negateLiteral(AstLiteral* lit) {$/;"	f	namespace:souffle
negated	AstParserUtils.h	/^        bool negated;$/;"	m	struct:souffle::RuleBody::literal
negatedAtoms	MagicSet.h	/^    std::set<AstRelationIdentifier> negatedAtoms;$/;"	m	class:souffle::Adornment
negatedConstraintOp	BinaryConstraintOps.h	/^inline BinaryConstraintOp negatedConstraintOp(BinaryConstraintOp op) {$/;"	f	namespace:souffle
negations	AstClause.h	/^    std::vector<std::unique_ptr<AstNegation>> negations;$/;"	m	class:souffle::AstClause
nested	Brie.h	/^        nested_iter_core nested;$/;"	m	class:souffle::Trie::iterator_core
nested	CompiledIndexUtils.h	/^        typename nested_indices::operation_context nested;$/;"	m	struct:souffle::ram::index_utils::Indices::operation_context
nested	CompiledRelation.h	/^    nested_group nested;$/;"	m	class:souffle::ram::detail::GenericRelationGroup
nestedComponents	ComponentModel.h	/^    std::map<const AstComponent*, std::set<const AstComponent*>> nestedComponents;$/;"	m	class:souffle::ComponentLookup
nestedOperation	RamOperation.h	/^    std::unique_ptr<RamOperation> nestedOperation;$/;"	m	class:souffle::RamNestedOperation
nested_trie_cloner	Brie.h	/^    struct nested_trie_cloner {$/;"	s	class:souffle::Trie
nested_trie_merger	Brie.h	/^    struct nested_trie_merger {$/;"	s	class:souffle::Trie
newInstance	SouffleInterface.h	/^    static SouffleProgram* newInstance(const std::string& name) {$/;"	f	class:souffle::ProgramFactory
newNode	Brie.h	/^    static Node* newNode() {$/;"	f	class:souffle::SparseArray
newSymbol	SymbolTable.h	/^    inline void newSymbol(const std::string& symbol) {$/;"	f	class:souffle::SymbolTable
newSymbolOfIndex	SymbolTable.h	/^    inline size_t newSymbolOfIndex(const std::string& symbol) {$/;"	f	class:souffle::SymbolTable
next	StringPool.h	/^        hashentry* next;$/;"	m	struct:souffle::StringPool::hashentry
next	Table.h	/^        Block* next;$/;"	m	struct:souffle::Table::Block
next	test/test.h	/^    TestCase* next;     \/\/ next test case (linked by constructor)$/;"	m	class:TestCase
nextSrcLoc	MagicSet.cpp	/^SrcLocation nextSrcLoc(SrcLocation orig) {$/;"	f	namespace:souffle
nextTestCase	test/test.h	/^    TestCase* nextTestCase() {$/;"	f	class:TestCase
node	BTree.h	/^        node(bool inner) : base(inner) {}$/;"	f	struct:souffle::detail::btree::node
node	BTree.h	/^    struct node : public base {$/;"	s	class:souffle::detail::btree
node	Brie.h	/^        Node* node;$/;"	m	struct:souffle::SparseArray::FirstInfoSnapshot
node	Brie.h	/^        const Node* node;$/;"	m	class:souffle::SparseArray::iterator
nodeExists	UnionFind.h	/^    inline bool nodeExists(const SparseDomain val) const {$/;"	f	class:souffle::SparseDisjointSet
nodist_souffle_OBJECTS	Makefile	/^nodist_souffle_OBJECTS =$/;"	m
nodist_souffle_SOURCES	Makefile	/^nodist_souffle_SOURCES = $(BUILT_SOURCES)$/;"	m
nodist_souffle_profile_OBJECTS	Makefile	/^nodist_souffle_profile_OBJECTS =$/;"	m
nodist_souffle_profile_SOURCES	Makefile	/^nodist_souffle_profile_SOURCES = $(BUILT_SOURCES)$/;"	m
noexcept	AstProgram.h	/^    AstProgram(AstProgram&& other) noexcept;$/;"	m	class:souffle::AstProgram
noexcept	TypeSystem.h	/^    TypeSet(TypeSet&& other) noexcept : all(other.all), types() {$/;"	m	struct:souffle::TypeSet
noexcept	json11.h	/^    Json() noexcept;                 \/\/ NUL$/;"	m	class:json11::final
noexcept	json11.h	/^    Json(std::nullptr_t) noexcept;   \/\/ NUL$/;"	m	class:json11::final
noexcept	json11.h	/^#define noexcept /;"	d
noinst_LTLIBRARIES	Makefile	/^noinst_LTLIBRARIES = libsouffle.la$/;"	m
nonRecTuples	profile/Relation.h	/^    long nonRecTuples = 0;$/;"	m	class:souffle::profile::Relation
nonRecursiveRelationNumberProcessor	EventProcessor.h	/^} nonRecursiveRelationNumberProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::NonRecursiveRelationNumberProcessor
nonRecursiveRelationTimingProcessor	EventProcessor.h	/^} nonRecursiveRelationTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::NonRecursiveRelationTimingProcessor
nonRecursiveRuleNumberProcessor	EventProcessor.h	/^} nonRecursiveRuleNumberProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::NonRecursiveRuleNumberProcessor
nonRecursiveRuleTimingProcessor	EventProcessor.h	/^} nonRecursiveRuleTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::NonRecursiveRuleTimingProcessor
none	profile/htmlMain.h	/^        <li id="chart-tab" style="display:none;"><a id="chart_tab" onclick="changeTab(event, 'Chart')" class="tablinks">Chart<\/a><\/li>$/;"	m	namespace:souffle::profile::html
none	profile/htmlMain.h	/^    <div id="atoms" style="display:none;">$/;"	m	namespace:souffle::profile::html
none	profile/htmlMain.h	/^    <div id="rulesofrel" style="display:none;">$/;"	m	namespace:souffle::profile::html
none	profile/htmlMain.h	/^    <div id="rulver" style="display:none;">$/;"	m	namespace:souffle::profile::html
normaliseInlinedHeads	InlineRelationsTransformer.cpp	/^void normaliseInlinedHeads(AstProgram& program) {$/;"	f	namespace:souffle
now	test/btree_multiset_test.cpp	/^time_point now() {$/;"	f	namespace:souffle::test
now	test/btree_set_test.cpp	/^time_point now() {$/;"	f	namespace:souffle::test
nowarn	ErrorReport.h	/^    bool nowarn;$/;"	m	class:souffle::ErrorReport
null	json11.h	/^    const std::shared_ptr<JsonValue> null = make_shared<JsonNull>();$/;"	m	struct:json11::Statics
num	AstType.h	/^    bool num;$/;"	m	class:souffle::AstPrimitiveType
numBoundArguments	ReorderLiteralsTransformer.cpp	/^unsigned int numBoundArguments(const AstAtom* atom, const std::set<std::string>& boundVariables) {$/;"	f	namespace:souffle
numElements	BTree.h	/^        volatile size_type numElements;$/;"	m	struct:souffle::detail::btree::base
numToStr	SymbolTable.h	/^    std::deque<std::string> numToStr;$/;"	m	class:souffle::SymbolTable
numToStrCache	SymbolTable.h	/^    mutable std::unordered_map<size_t, std::string> numToStrCache;$/;"	m	class:souffle::SymbolTable
numTuples	profile/Iteration.h	/^    size_t numTuples = 0;$/;"	m	class:souffle::profile::Iteration
num_checks	test/test.h	/^    size_t num_checks;  \/\/ number of checks$/;"	m	class:TestCase
num_containers	PiggyList.h	/^    std::atomic<size_t> num_containers;$/;"	m	class:souffle::PiggyList
num_failed	test/test.h	/^    size_t num_failed;  \/\/ number of failed checks$/;"	m	class:TestCase
num_jobs	CompiledOptions.h	/^    size_t num_jobs;$/;"	m	class:souffle::CmdOptions
num_tuples	InterpreterRelation.h	/^    size_t num_tuples;$/;"	m	class:souffle::InterpreterRelation
number	AstArgument.h	/^    size_t number;$/;"	m	class:souffle::AstSubroutineArgument
number	RamExpression.h	/^    const size_t number;$/;"	m	class:souffle::RamArgument
numberOfTags	SymbolTable.h	/^    static int numberOfTags() {$/;"	f	class:souffle::SymbolTable
number_value	json11.h	/^inline double Json::number_value() const {$/;"	f	class:json11::Json
number_value	json11.h	/^inline double JsonValue::number_value() const {$/;"	f	class:json11::JsonValue
numsToArgs	ExplainProvenance.h	/^    std::vector<std::string> numsToArgs(const std::string& relName, const std::vector<RamDomain>& nums,$/;"	f	class:souffle::ExplainProvenance
o	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
object_items	json11.h	/^inline const map<string, Json>& Json::object_items() const {$/;"	f	class:json11::Json
object_items	json11.h	/^inline const map<string, Json>& JsonValue::object_items() const {$/;"	f	class:json11::JsonValue
offset	Brie.h	/^        index_type offset;$/;"	m	struct:souffle::SparseArray::FirstInfoSnapshot
offset	Brie.h	/^        index_type offset;$/;"	m	struct:souffle::SparseArray::RootInfo
offset	Brie.h	/^        index_type offset;$/;"	m	struct:souffle::SparseArray::RootInfoSnapshot
ogzfstream	gzfstream.h	/^    explicit ogzfstream(const std::string& filename, std::ios_base::openmode mode = std::ios::out)$/;"	f	class:souffle::gzfstream::ogzfstream
ogzfstream	gzfstream.h	/^    ogzfstream() : std::ostream(&buf) {}$/;"	f	class:souffle::gzfstream::ogzfstream
ogzfstream	gzfstream.h	/^class ogzfstream : public internal::gzfstream, public std::ostream {$/;"	c	namespace:souffle::gzfstream
old	gzfstream.h	/^    gzfstreambuf(gzfstreambuf&& old) = default;$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
op	RamCondition.h	/^    BinaryConstraintOp op;$/;"	m	class:souffle::RamConstraint
op_context	Brie.h	/^    struct op_context {$/;"	s	class:souffle::SparseArray
op_context	Brie.h	/^    struct op_context {$/;"	s	class:souffle::Trie
op_context	Brie.h	/^    struct op_context {};$/;"	s	class:souffle::Trie
op_nesting	AstTranslator.h	/^        std::vector<const AstNode*> op_nesting;$/;"	m	class:souffle::AstTranslator::ClauseTranslator
open	gzfstream.h	/^    gzfstreambuf* open(const std::string& filename, std::ios_base::openmode mode) {$/;"	f	class:souffle::gzfstream::internal::gzfstreambuf
open	gzfstream.h	/^    void open(const std::string& filename, std::ios_base::openmode mode = std::ios::in) {$/;"	f	class:souffle::gzfstream::igzfstream
open	gzfstream.h	/^    void open(const std::string& filename, std::ios_base::openmode mode = std::ios::out) {$/;"	f	class:souffle::gzfstream::ogzfstream
open	gzfstream.h	/^    void open(const std::string& filename, std::ios_base::openmode mode) {$/;"	f	class:souffle::gzfstream::internal::gzfstream
openDB	ReadStreamSQLite.h	/^    void openDB() {$/;"	f	class:souffle::ReadStreamSQLite
openDB	WriteStreamSQLite.h	/^    void openDB() {$/;"	f	class:souffle::WriteStreamSQLite
operand	RamCondition.h	/^    std::unique_ptr<RamCondition> operand;$/;"	m	class:souffle::RamNegation
operation	AstLiteral.h	/^    BinaryConstraintOp operation;$/;"	m	class:souffle::AstBinaryConstraint
operation	RamExpression.h	/^    const FunctorOp operation;$/;"	m	class:souffle::RamIntrinsicOperator
operation	RamStatement.h	/^    std::unique_ptr<RamOperation> operation;$/;"	m	class:souffle::RamQuery
operation_context	CompiledIndexUtils.h	/^    struct operation_context {$/;"	s	class:souffle::ram::index_utils::Indices
operation_context	CompiledRelation.h	/^    struct operation_context {};$/;"	s	class:souffle::ram::detail::AutoRelation
operation_context	CompiledRelation.h	/^    struct operation_context {};$/;"	s	class:souffle::ram::detail::GenericRelation
operation_hints	EquivalenceRelation.h	/^    struct operation_hints {$/;"	s	class:souffle::EquivalenceRelation
operator !=	AstNode.h	/^    bool operator!=(const AstNode& other) const {$/;"	f	class:souffle::AstNode
operator !=	AstRelationIdentifier.h	/^    bool operator!=(const AstRelationIdentifier& other) const {$/;"	f	class:souffle::AstRelationIdentifier
operator !=	AstTranslator.h	/^        bool operator!=(const Location& loc) const {$/;"	f	struct:souffle::AstTranslator::Location
operator !=	AstType.h	/^    bool operator!=(const AstTypeIdentifier& other) const {$/;"	f	class:souffle::AstTypeIdentifier
operator !=	BTree.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::detail::btree::iterator
operator !=	BTree.h	/^    bool operator!=(const btree& other) const {$/;"	f	class:souffle::detail::btree
operator !=	Brie.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::SparseArray::iterator
operator !=	Brie.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::SparseBitMap::iterator
operator !=	Brie.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::detail::TrieBase::iterator
operator !=	Brie.h	/^        bool operator!=(const iterator_core& other) const {$/;"	f	class:souffle::Trie::iterator_core
operator !=	CompiledIndexUtils.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
operator !=	CompiledIndexUtils.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
operator !=	CompiledIndexUtils.h	/^    bool operator!=(const filter_iterator& other) const {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
operator !=	CompiledRelation.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
operator !=	CompiledSouffle.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::t_nullaries::iterator
operator !=	CompiledTuple.h	/^    bool operator!=(const Tuple& other) const {$/;"	f	struct:souffle::ram::Tuple
operator !=	Constraints.h	/^    bool operator!=(const Variable& other) const {$/;"	f	struct:souffle::Variable
operator !=	EquivalenceRelation.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::EquivalenceRelation::iterator
operator !=	IODirectives.h	/^    bool operator!=(const IODirectives& other) const {$/;"	f	class:souffle::IODirectives
operator !=	InterpreterRelation.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::InterpreterRelation::iterator
operator !=	IterUtils.h	/^    bool operator!=(const IterDerefWrapper& other) const {$/;"	f	struct:souffle::IterDerefWrapper
operator !=	IterUtils.h	/^    bool operator!=(const SingleValueIterator& other) const {$/;"	f	class:souffle::SingleValueIterator
operator !=	LambdaBTree.h	/^    bool operator!=(const LambdaBTree& other) const {$/;"	f	class:souffle::detail::LambdaBTree
operator !=	PiggyList.h	/^        bool operator!=(const iterator& x) const {$/;"	f	class:souffle::PiggyList::iterator
operator !=	RamNode.h	/^    bool operator!=(const RamNode& other) const {$/;"	f	class:souffle::RamNode
operator !=	SouffleInterface.h	/^        bool operator!=(const iterator& o) const {$/;"	f	class:souffle::Relation::iterator
operator !=	Table.h	/^        bool operator!=(const iterator& other) const {$/;"	f	class:souffle::Table::iterator
operator !=	TypeSystem.h	/^    bool operator!=(const Type& other) const {$/;"	f	class:souffle::Type
operator !=	TypeSystem.h	/^    bool operator!=(const TypeSet& other) const {$/;"	f	struct:souffle::TypeSet
operator !=	json11.h	/^    bool operator!=(const Json& rhs) const {$/;"	f	class:json11::final
operator ()	AstGroundAnalysis.cpp	/^    bool operator()() const {$/;"	f	struct:souffle::__anon2::false_factory
operator ()	AstGroundAnalysis.cpp	/^    bool operator()(bool& a, bool b) const {$/;"	f	struct:souffle::__anon2::bool_or
operator ()	AstNode.h	/^    std::unique_ptr<T> operator()(std::unique_ptr<T> node) const {$/;"	f	class:souffle::AstNodeMapper
operator ()	AstRelation.h	/^    bool operator()(const AstRelation* x, const AstRelation* y) const {$/;"	f	struct:souffle::AstNameComparison
operator ()	AstTypeAnalysis.cpp	/^    TypeSet operator()() const {$/;"	f	struct:souffle::__anon77::all_type_factory
operator ()	AstTypeAnalysis.cpp	/^    bool operator()(TypeSet& a, const TypeSet& b) const {$/;"	f	struct:souffle::__anon77::sub_type
operator ()	AstVisitor.h	/^    R operator()(const AstNode& node, Params... args) {$/;"	f	struct:souffle::AstVisitor
operator ()	BTree.h	/^    Iter operator()(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::binary_search
operator ()	BTree.h	/^    inline Iter operator()(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::linear_search
operator ()	BTree.h	/^    int operator()(const T& a, const T& b) const {$/;"	f	struct:souffle::detail::comparator
operator ()	Brie.h	/^        nested_trie_type* operator()(nested_trie_type* a) const {$/;"	f	struct:souffle::Trie::nested_trie_cloner
operator ()	Brie.h	/^        nested_trie_type* operator()(nested_trie_type* a, const nested_trie_type* b) const {$/;"	f	struct:souffle::Trie::nested_trie_merger
operator ()	Brie.h	/^        value_t operator()(value_t a, value_t b) const {$/;"	f	struct:souffle::SparseBitMap::merge_op
operator ()	Brie.h	/^    IterCore& operator()(IterCore& core) {$/;"	f	struct:souffle::detail::get_nested_iter_core
operator ()	Brie.h	/^    T operator()() const {$/;"	f	struct:souffle::detail::default_factory
operator ()	Brie.h	/^    T operator()(T a, T b) const {$/;"	f	struct:souffle::detail::default_merge
operator ()	Brie.h	/^    T operator()(T v) const {$/;"	f	struct:souffle::detail::identity
operator ()	Brie.h	/^    bool operator()($/;"	f	struct:souffle::detail::fix_binding
operator ()	Brie.h	/^    bool operator()(const Store& store, iterator& begin, iterator& end, const entry_type& entry) const {$/;"	f	struct:souffle::detail::fix_binding
operator ()	Brie.h	/^    void operator()(const SparseBitMap<bits>& store, iterator& iter) const {$/;"	f	struct:souffle::detail::fix_first
operator ()	Brie.h	/^    void operator()(const Store& store, iterator& iter) const {$/;"	f	struct:souffle::detail::fix_first
operator ()	CompiledIndexUtils.h	/^    int operator()(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::comparator
operator ()	CompiledIndexUtils.h	/^    int operator()(const T& a, const T& b) const {$/;"	f	struct:souffle::ram::index_utils::deref_compare
operator ()	CompiledIndexUtils.h	/^    void operator()(T& t) const {$/;"	f	struct:souffle::ram::index_utils::mask
operator ()	CompiledIndexUtils.h	/^    void operator()(T& t) const {}$/;"	f	struct:souffle::ram::index_utils::mask
operator ()	CompiledRelation.h	/^    bool operator()(const Tuple<RamDomain, S>& a, const Tuple<RamDomain, S>& b) const {$/;"	f	struct:souffle::ram::detail::tuple_equal
operator ()	CompiledRelation.h	/^    bool operator()(const Tuple<RamDomain, S>& a, const Tuple<RamDomain, S>& b) const {$/;"	f	struct:souffle::ram::detail::tuple_less
operator ()	CompiledRelation.h	/^    bool operator()(const Tuple<RamDomain, S>&, const Tuple<RamDomain, S>&) const {$/;"	f	struct:souffle::ram::detail::tuple_equal
operator ()	CompiledRelation.h	/^    bool operator()(const Tuple<RamDomain, S>&, const Tuple<RamDomain, S>&) const {$/;"	f	struct:souffle::ram::detail::tuple_less
operator ()	CompiledRelation.h	/^    std::size_t operator()(const Tuple<RamDomain, S>& a) const {$/;"	f	struct:souffle::ram::detail::tuple_hasher
operator ()	CompiledTuple.h	/^    size_t operator()(const souffle::ram::Tuple<Domain, arity>& value) const {$/;"	f	struct:std::hash
operator ()	Constraints.h	/^    T operator()() const {$/;"	f	struct:souffle::detail::default_bottom_factory
operator ()	Constraints.h	/^    T operator()(const T& a, const T& b) {$/;"	f	struct:souffle::detail::default_meet_op
operator ()	Constraints.h	/^    bool operator()(std::set<T>& a, const std::set<T>& b) {$/;"	f	struct:souffle::detail::set_meet_assign_op
operator ()	InterpreterIndex.h	/^        int operator()(const RamDomain* x, const RamDomain* y) const {$/;"	f	struct:souffle::InterpreterIndex::comparator
operator ()	ParallelUtils.h	/^    void operator()() {$/;"	f	class:souffle::detail::Waiter
operator ()	RamNode.h	/^    std::unique_ptr<T> operator()(std::unique_ptr<T> node) const {$/;"	f	class:souffle::RamNodeMapper
operator ()	RamVisitor.h	/^    R operator()(const RamNode& node, Params... args) {$/;"	f	struct:souffle::RamVisitor
operator ()	RamVisitor.h	/^    R operator()(const RamNode* node, Params... args) {$/;"	f	struct:souffle::RamVisitor
operator ()	ResolveAliasesTransformer.cpp	/^    std::unique_ptr<AstNode> operator()(std::unique_ptr<AstNode> node) const {$/;"	f	class:souffle::__anon71::Substitution
operator ()	ResolveAliasesTransformer.cpp	/^    std::unique_ptr<T> operator()(std::unique_ptr<T> node) const {$/;"	f	class:souffle::__anon71::Substitution
operator ()	TypeSystem.cpp	/^    R operator()(const Type& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
operator ()	UnionFind.h	/^    int operator()(const StorePair& a, const StorePair& b) {$/;"	f	struct:souffle::EqrelMapComparator
operator ()	Util.h	/^    T& operator()(T& t) const {$/;"	f	struct:souffle::id
operator ()	Util.h	/^    bool operator()(const T& a, const T& b) const {$/;"	f	struct:souffle::comp_deref
operator ()	Util.h	/^    const T& operator()(const T& t) const {$/;"	f	struct:souffle::id
operator ()	Util.h	/^    void operator()(std::ostream& out, const T& value) const {$/;"	f	struct:souffle::detail::print
operator ()	parser.cc	/^  parser::operator() ()$/;"	f	class:yy::parser
operator ()	test/btree_multiset_test.cpp	/^    std::size_t operator()(const tuple<A, B>& t) const {$/;"	f	struct:std::hash
operator ()	test/btree_multiset_test.cpp	/^    void operator()(C&, unsigned) const {$/;"	f	struct:souffle::test::reserver
operator ()	test/btree_multiset_test.cpp	/^    void operator()(std::unordered_set<A, B, C, D>& set, unsigned size) const {$/;"	f	struct:souffle::test::reserver
operator ()	test/btree_set_test.cpp	/^    std::size_t operator()(const tuple<A, B>& t) const {$/;"	f	struct:std::hash
operator ()	test/btree_set_test.cpp	/^    void operator()(C&, unsigned) const {$/;"	f	struct:souffle::test::reserver
operator ()	test/btree_set_test.cpp	/^    void operator()(std::unordered_set<A, B, C, D>& set, unsigned size) const {$/;"	f	struct:souffle::test::reserver
operator *	BTree.h	/^        const Key& operator*() const {$/;"	f	class:souffle::detail::btree::iterator
operator *	Brie.h	/^        const entry_type& operator*() const {$/;"	f	class:souffle::detail::TrieBase::iterator
operator *	Brie.h	/^        const index_type& operator*() const {$/;"	f	class:souffle::SparseBitMap::iterator
operator *	Brie.h	/^        const pair_type& operator*() const {$/;"	f	class:souffle::SparseArray::iterator
operator *	CompiledIndexUtils.h	/^        const tuple_type& operator*() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
operator *	CompiledIndexUtils.h	/^        const tuple_type& operator*() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
operator *	CompiledIndexUtils.h	/^    const tuple_type& operator*() const {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
operator *	CompiledRelation.h	/^        const tuple_type& operator*() const {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
operator *	CompiledSouffle.h	/^        const RamDomain* operator*() {$/;"	f	class:souffle::t_nullaries::iterator
operator *	EquivalenceRelation.h	/^        const TupleType& operator*() const {$/;"	f	class:souffle::EquivalenceRelation::iterator
operator *	InterpreterRelation.h	/^        const RamDomain* operator*() {$/;"	f	class:souffle::InterpreterRelation::iterator
operator *	IterUtils.h	/^    const T& operator*() const {$/;"	f	class:souffle::SingleValueIterator
operator *	IterUtils.h	/^    const T& operator*() const {$/;"	f	struct:souffle::IterDerefWrapper
operator *	PiggyList.h	/^        T operator*() {$/;"	f	class:souffle::PiggyList::iterator
operator *	PiggyList.h	/^        const T operator*() const {$/;"	f	class:souffle::PiggyList::iterator
operator *	SouffleInterface.h	/^        tuple& operator*() const {$/;"	f	class:souffle::Relation::iterator
operator *	Table.h	/^        const T& operator*() const {$/;"	f	class:souffle::Table::iterator
operator +	AstRelationIdentifier.h	/^inline AstRelationIdentifier operator+(const std::string& name, const AstRelationIdentifier& id) {$/;"	f	namespace:souffle
operator +	AstType.h	/^inline AstTypeIdentifier operator+(const std::string& name, const AstTypeIdentifier& id) {$/;"	f	namespace:souffle
operator ++	BTree.h	/^        iterator& operator++() {$/;"	f	class:souffle::detail::btree::iterator
operator ++	Brie.h	/^        iterator& operator++() {$/;"	f	class:souffle::SparseArray::iterator
operator ++	Brie.h	/^        iterator& operator++() {$/;"	f	class:souffle::SparseBitMap::iterator
operator ++	Brie.h	/^        iterator& operator++() {$/;"	f	class:souffle::detail::TrieBase::iterator
operator ++	CompiledIndexUtils.h	/^        iterator& operator++() {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
operator ++	CompiledIndexUtils.h	/^        iterator& operator++() {$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
operator ++	CompiledIndexUtils.h	/^    filter_iterator& operator++() {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
operator ++	CompiledRelation.h	/^        iterator& operator++() {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
operator ++	CompiledSouffle.h	/^        iterator& operator++() {$/;"	f	class:souffle::t_nullaries::iterator
operator ++	EquivalenceRelation.h	/^        iterator& operator++() {$/;"	f	class:souffle::EquivalenceRelation::iterator
operator ++	InterpreterRelation.h	/^        iterator& operator++() {$/;"	f	class:souffle::InterpreterRelation::iterator
operator ++	IterUtils.h	/^    IterDerefWrapper& operator++() {$/;"	f	struct:souffle::IterDerefWrapper
operator ++	IterUtils.h	/^    SingleValueIterator& operator++() {$/;"	f	class:souffle::SingleValueIterator
operator ++	PiggyList.h	/^        iterator operator++() {$/;"	f	class:souffle::PiggyList::iterator
operator ++	PiggyList.h	/^        iterator& operator++(int) {$/;"	f	class:souffle::PiggyList::iterator
operator ++	SouffleInterface.h	/^        iterator& operator++() {$/;"	f	class:souffle::Relation::iterator
operator ++	Table.h	/^        iterator& operator++() {$/;"	f	class:souffle::Table::iterator
operator ->	Brie.h	/^        const entry_type* operator->() const {$/;"	f	class:souffle::detail::TrieBase::iterator
operator ->	Brie.h	/^        const index_type* operator->() const {$/;"	f	class:souffle::SparseBitMap::iterator
operator ->	Brie.h	/^        const pair_type* operator->() const {$/;"	f	class:souffle::SparseArray::iterator
operator ->	CompiledIndexUtils.h	/^        const tuple_type* operator->() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
operator ->	CompiledIndexUtils.h	/^        const tuple_type* operator->() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
operator ->	CompiledIndexUtils.h	/^    const tuple_type* operator->() const {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
operator ->	CompiledRelation.h	/^        const tuple_type* operator->() const {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
operator ->	EquivalenceRelation.h	/^        const TupleType* operator->() const {$/;"	f	class:souffle::EquivalenceRelation::iterator
operator ->	IterUtils.h	/^    const T* operator->() const {$/;"	f	class:souffle::SingleValueIterator
operator ->	IterUtils.h	/^    const T* operator->() const {$/;"	f	struct:souffle::IterDerefWrapper
operator <	AstRelationIdentifier.h	/^    bool operator<(const AstRelationIdentifier& other) const {$/;"	f	class:souffle::AstRelationIdentifier
operator <	AstTranslator.h	/^        bool operator<(const Location& loc) const {$/;"	f	struct:souffle::AstTranslator::Location
operator <	AstType.h	/^    bool operator<(const AstTypeIdentifier& other) const {$/;"	f	class:souffle::AstTypeIdentifier
operator <	CompiledTuple.h	/^    bool operator<(const Tuple& other) const {$/;"	f	struct:souffle::ram::Tuple
operator <	Constraints.h	/^    bool operator<(const Variable& other) const {$/;"	f	struct:souffle::Variable
operator <	ErrorReport.h	/^    bool operator<(const Diagnostic& other) const {$/;"	f	class:souffle::Diagnostic
operator <	InterpreterIndex.h	/^    bool operator<(const InterpreterIndexOrder& other) const {$/;"	f	class:souffle::InterpreterIndexOrder
operator <	MagicSet.h	/^    friend bool operator<(const AdornedPredicate& p1, const AdornedPredicate& p2) {$/;"	f	class:souffle::AdornedPredicate
operator <	RamRelation.h	/^    bool operator<(const RamRelation& other) const {$/;"	f	class:souffle::RamRelation
operator <	SrcLocation.h	/^        bool operator<(const Point& other) const {$/;"	f	struct:souffle::SrcLocation::Point
operator <	SrcLocation.h	/^    bool operator<(const SrcLocation& other) const {$/;"	f	class:souffle::SrcLocation
operator <	TypeSystem.h	/^    bool operator<(const Type& other) const {$/;"	f	class:souffle::Type
operator <	json11.h	/^    bool operator<(NullStruct) const {$/;"	f	struct:json11::NullStruct
operator <	json11.h	/^inline bool Json::operator<(const Json& other) const {$/;"	f	class:json11::Json
operator <	profile/Rule.h	/^    bool operator<(const Atom& other) const {$/;"	f	class:souffle::profile::Atom
operator <	profile/Tui.h	/^        bool operator<(const Usage& other) const {$/;"	f	struct:souffle::profile::Tui::Usage
operator <<	AstAnalysis.h	/^    friend std::ostream& operator<<(std::ostream& out, const AstAnalysis& other) {$/;"	f	class:souffle::AstAnalysis
operator <<	AstNode.h	/^    friend std::ostream& operator<<(std::ostream& out, const AstNode& node) {$/;"	f	class:souffle::AstNode
operator <<	AstParserUtils.cpp	/^std::ostream& operator<<(std::ostream& out, const RuleBody& body) {$/;"	f	namespace:souffle
operator <<	AstPragma.h	/^    friend std::ostream& operator<<(std::ostream& out, const AstPragma& arg) {$/;"	f	class:souffle::AstPragma
operator <<	AstRelation.h	/^    friend std::ostream& operator<<(std::ostream& os, const AstRelation& rel) {$/;"	f	class:souffle::AstRelation
operator <<	AstRelation.h	/^    friend std::ostream& operator<<(std::ostream& os, const AstRelation* rel) {$/;"	f	class:souffle::AstRelation
operator <<	AstRelationIdentifier.h	/^    friend std::ostream& operator<<(std::ostream& out, const AstRelationIdentifier& id) {$/;"	f	class:souffle::AstRelationIdentifier
operator <<	AstTranslator.h	/^        friend std::ostream& operator<<(std::ostream& out, const Location& loc) {$/;"	f	struct:souffle::AstTranslator::Location
operator <<	AstTranslator.h	/^        friend std::ostream& operator<<(std::ostream& out, const ValueIndex& index) __attribute__((unused)) {$/;"	f	class:souffle::AstTranslator::ValueIndex
operator <<	AstType.h	/^    friend std::ostream& operator<<(std::ostream& out, const AstTypeIdentifier& id) {$/;"	f	class:souffle::AstTypeIdentifier
operator <<	Brie.h	/^        friend std::ostream& operator<<(std::ostream& out, const iterator& iter) {$/;"	f	class:souffle::SparseArray::iterator
operator <<	Brie.h	/^        friend std::ostream& operator<<(std::ostream& out, const iterator& iter) {$/;"	f	class:souffle::SparseBitMap::iterator
operator <<	Brie.h	/^        friend std::ostream& operator<<(std::ostream& out, const iterator& iter) {$/;"	f	class:souffle::detail::TrieBase::iterator
operator <<	Brie.h	/^        friend std::ostream& operator<<(std::ostream& out, const iterator_core& iter) {$/;"	f	class:souffle::Trie::iterator_core
operator <<	CompiledIndexUtils.h	/^    friend std::ostream& operator<<(std::ostream& out, const index& index) {$/;"	f	struct:souffle::ram::index
operator <<	CompiledIndexUtils.h	/^    friend std::ostream& operator<<(std::ostream& out, const print&) {$/;"	f	struct:souffle::ram::index_utils::print
operator <<	CompiledTuple.h	/^    friend std::ostream& operator<<(std::ostream& out, const Tuple& tuple) {$/;"	f	struct:souffle::ram::Tuple
operator <<	Constraints.h	/^    friend std::ostream& operator<<(std::ostream& out, const Assignment& ass) {$/;"	f	class:souffle::Assignment
operator <<	Constraints.h	/^    friend std::ostream& operator<<(std::ostream& out, const Constraint& c) {$/;"	f	class:souffle::Constraint
operator <<	Constraints.h	/^    friend std::ostream& operator<<(std::ostream& out, const Problem& p) {$/;"	f	class:souffle::Problem
operator <<	Constraints.h	/^    friend std::ostream& operator<<(std::ostream& out, const Variable& var) {$/;"	f	struct:souffle::Variable
operator <<	DebugReport.h	/^    friend std::ostream& operator<<(std::ostream& out, const DebugReport& report) {$/;"	f	class:souffle::DebugReport
operator <<	ErrorReport.h	/^    friend std::ostream& operator<<(std::ostream& out, const Diagnostic& diagnostic) {$/;"	f	class:souffle::Diagnostic
operator <<	ErrorReport.h	/^    friend std::ostream& operator<<(std::ostream& out, const DiagnosticMessage& diagnosticMessage) {$/;"	f	class:souffle::DiagnosticMessage
operator <<	ErrorReport.h	/^    friend std::ostream& operator<<(std::ostream& out, const ErrorReport& report) {$/;"	f	class:souffle::ErrorReport
operator <<	GraphUtils.h	/^    friend std::ostream& operator<<(std::ostream& out, const Graph& g) {$/;"	f	class:souffle::Graph
operator <<	IODirectives.h	/^    friend std::ostream& operator<<(std::ostream& out, const IODirectives& ioDirectives) {$/;"	f	class:souffle::IODirectives
operator <<	InterpreterIndex.h	/^    friend std::ostream& operator<<(std::ostream& out, const InterpreterIndexOrder& order) {$/;"	f	class:souffle::InterpreterIndexOrder
operator <<	MagicSet.h	/^    friend std::ostream& operator<<(std::ostream& out, const AdornedClause& arg) {$/;"	f	class:souffle::AdornedClause
operator <<	MagicSet.h	/^    friend std::ostream& operator<<(std::ostream& out, const AdornedPredicate& arg) {$/;"	f	class:souffle::AdornedPredicate
operator <<	PrecedenceGraph.h	/^    friend std::ostream& operator<<(std::ostream& out, const RelationScheduleStep& other) {$/;"	f	class:souffle::RelationScheduleStep
operator <<	RamAnalysis.h	/^    friend std::ostream& operator<<(std::ostream& out, const RamAnalysis& other) {$/;"	f	class:souffle::RamAnalysis
operator <<	RamNode.h	/^    friend std::ostream& operator<<(std::ostream& out, const RamNode& node) {$/;"	f	class:souffle::RamNode
operator <<	RelationRepresentation.h	/^inline std::ostream& operator<<(std::ostream& os, RelationRepresentation structure) {$/;"	f	namespace:souffle
operator <<	ResolveAliasesTransformer.cpp	/^    friend std::ostream& operator<<(std::ostream& out, const Equation& e) __attribute__((unused)) {$/;"	f	class:souffle::__anon71::Equation
operator <<	ResolveAliasesTransformer.cpp	/^    friend std::ostream& operator<<(std::ostream& out, const Substitution& s) __attribute__((unused)) {$/;"	f	class:souffle::__anon71::Substitution
operator <<	SouffleInterface.h	/^    tuple& operator<<(RamDomain number) {$/;"	f	class:souffle::tuple
operator <<	SouffleInterface.h	/^    tuple& operator<<(const std::string& str) {$/;"	f	class:souffle::tuple
operator <<	SrcLocation.h	/^        friend std::ostream& operator<<(std::ostream& out, const Point& loc) {$/;"	f	struct:souffle::SrcLocation::Point
operator <<	SrcLocation.h	/^    friend std::ostream& operator<<(std::ostream& out, const SrcLocation& range) {$/;"	f	class:souffle::SrcLocation
operator <<	SymbolTable.h	/^    friend std::ostream& operator<<(std::ostream& out, const SymbolTable& table) {$/;"	f	class:souffle::SymbolTable
operator <<	TypeSystem.h	/^    friend std::ostream& operator<<(std::ostream& out, const Type& t) {$/;"	f	class:souffle::Type
operator <<	TypeSystem.h	/^    friend std::ostream& operator<<(std::ostream& out, const Type* t) {$/;"	f	class:souffle::Type
operator <<	TypeSystem.h	/^    friend std::ostream& operator<<(std::ostream& out, const TypeEnvironment& environment) {$/;"	f	class:souffle::TypeEnvironment
operator <<	TypeSystem.h	/^    friend std::ostream& operator<<(std::ostream& out, const TypeSet& set) {$/;"	f	struct:souffle::TypeSet
operator <<	Util.h	/^    friend std::ostream& operator<<(std::ostream& out, const joined_sequence& s) {$/;"	f	class:souffle::detail::joined_sequence
operator <<	Util.h	/^ostream& operator<<(ostream& out, const map<K, T, C, A>& m) {$/;"	f	namespace:std
operator <<	Util.h	/^ostream& operator<<(ostream& out, const pair<A, B>& p) {$/;"	f	namespace:std
operator <<	Util.h	/^ostream& operator<<(ostream& out, const set<K, C, A>& s) {$/;"	f	namespace:std
operator <<	Util.h	/^ostream& operator<<(ostream& out, const vector<T, A>& v) {$/;"	f	namespace:std
operator <<	test/btree_multiset_test.cpp	/^std::ostream& operator<<(std::ostream& out, const tuple<A, B>& t) {$/;"	f	namespace:std
operator <<	test/btree_set_test.cpp	/^std::ostream& operator<<(std::ostream& out, const tuple<A, B>& t) {$/;"	f	namespace:std
operator <=	json11.h	/^    bool operator<=(const Json& rhs) const {$/;"	f	class:json11::final
operator =	AstTranslator.h	/^        Location& operator=(Location other) {$/;"	f	struct:souffle::AstTranslator::Location
operator =	BTree.h	/^        iterator& operator=(const iterator& other) {$/;"	f	class:souffle::detail::btree::iterator
operator =	BTree.h	/^    btree& operator=(const btree& other) {$/;"	f	class:souffle::detail::btree
operator =	BTree.h	/^    btree_multiset& operator=(const btree_multiset& other) {$/;"	f	class:souffle::btree_multiset
operator =	BTree.h	/^    btree_set& operator=(const btree_set& other) {$/;"	f	class:souffle::btree_set
operator =	Brie.h	/^    SparseArray& operator=(SparseArray&& other) {$/;"	f	class:souffle::SparseArray
operator =	Brie.h	/^    SparseArray& operator=(const SparseArray& other) {$/;"	f	class:souffle::SparseArray
operator =	Global.h	/^    BaseTable& operator=(const BaseTable& other) {$/;"	f	class:souffle::BaseTable
operator =	LambdaBTree.h	/^    LambdaBTree& operator=(const LambdaBTree& other) {$/;"	f	class:souffle::detail::LambdaBTree
operator =	LambdaBTree.h	/^    LambdaBTreeSet& operator=(const LambdaBTreeSet& other) {$/;"	f	class:souffle::LambdaBTreeSet
operator =	SouffleInterface.h	/^        iterator& operator=(const iterator& o) {$/;"	f	class:souffle::Relation::iterator
operator =	SymbolTable.h	/^    SymbolTable& operator=(const SymbolTable& other) {$/;"	f	class:souffle::SymbolTable
operator =	parser.cc	/^  parser::stack_symbol_type::operator= (stack_symbol_type& that)$/;"	f	class:yy::parser::stack_symbol_type
operator ==	AstNode.h	/^    bool operator==(const AstNode& other) const {$/;"	f	class:souffle::AstNode
operator ==	AstRelationIdentifier.h	/^    bool operator==(const AstRelationIdentifier& other) const {$/;"	f	class:souffle::AstRelationIdentifier
operator ==	AstTranslator.h	/^        bool operator==(const Location& loc) const {$/;"	f	struct:souffle::AstTranslator::Location
operator ==	AstType.h	/^        bool operator==(const Field& other) const {$/;"	f	struct:souffle::AstRecordType::Field
operator ==	AstType.h	/^    bool operator==(const AstTypeIdentifier& other) const {$/;"	f	class:souffle::AstTypeIdentifier
operator ==	BTree.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::detail::btree::iterator
operator ==	BTree.h	/^    bool operator==(const btree& other) const {$/;"	f	class:souffle::detail::btree
operator ==	Brie.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::SparseArray::iterator
operator ==	Brie.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::SparseBitMap::iterator
operator ==	Brie.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::detail::TrieBase::iterator
operator ==	Brie.h	/^        bool operator==(const iterator_core& other) const {$/;"	f	class:souffle::Trie::iterator_core
operator ==	CompiledIndexUtils.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex::iterator
operator ==	CompiledIndexUtils.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex::iterator
operator ==	CompiledIndexUtils.h	/^    bool operator==(const filter_iterator& other) const {$/;"	f	class:souffle::ram::iterator_utils::filter_iterator
operator ==	CompiledRelation.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::ram::detail::AutoRelation::iterator
operator ==	CompiledSouffle.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::t_nullaries::iterator
operator ==	CompiledTuple.h	/^    bool operator==(const Tuple& other) const {$/;"	f	struct:souffle::ram::Tuple
operator ==	Constraints.h	/^    bool operator==(const Variable& other) const {$/;"	f	struct:souffle::Variable
operator ==	EquivalenceRelation.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::EquivalenceRelation::iterator
operator ==	IODirectives.h	/^    bool operator==(const IODirectives& other) const {$/;"	f	class:souffle::IODirectives
operator ==	InterpreterRelation.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::InterpreterRelation::iterator
operator ==	IterUtils.h	/^    bool operator==(const IterDerefWrapper& other) const {$/;"	f	struct:souffle::IterDerefWrapper
operator ==	IterUtils.h	/^    bool operator==(const SingleValueIterator& other) const {$/;"	f	class:souffle::SingleValueIterator
operator ==	LambdaBTree.h	/^    bool operator==(const LambdaBTree& other) const {$/;"	f	class:souffle::detail::LambdaBTree
operator ==	PiggyList.h	/^        bool operator==(const iterator& x) const {$/;"	f	class:souffle::PiggyList::iterator
operator ==	RamNode.h	/^    bool operator==(const RamNode& other) const {$/;"	f	class:souffle::RamNode
operator ==	SouffleInterface.h	/^        bool operator==(const iterator& o) const {$/;"	f	class:souffle::Relation::iterator
operator ==	SouffleInterface.h	/^        bool operator==(const iterator_base& o) const {$/;"	f	class:souffle::Relation::iterator_base
operator ==	Table.h	/^        bool operator==(const iterator& other) const {$/;"	f	class:souffle::Table::iterator
operator ==	TypeSystem.h	/^    bool operator==(const Type& other) const {$/;"	f	class:souffle::Type
operator ==	TypeSystem.h	/^    bool operator==(const TypeSet& other) const {$/;"	f	struct:souffle::TypeSet
operator ==	json11.h	/^    bool operator==(NullStruct) const {$/;"	f	struct:json11::NullStruct
operator ==	json11.h	/^inline bool Json::operator==(const Json& other) const {$/;"	f	class:json11::Json
operator >	CompiledTuple.h	/^    bool operator>(const Tuple& other) const {$/;"	f	struct:souffle::ram::Tuple
operator >	SrcLocation.h	/^        bool operator>(const Point& other) const {$/;"	f	struct:souffle::SrcLocation::Point
operator >	json11.h	/^    bool operator>(const Json& rhs) const {$/;"	f	class:json11::final
operator >=	json11.h	/^    bool operator>=(const Json& rhs) const {$/;"	f	class:json11::final
operator >>	SouffleInterface.h	/^    tuple& operator>>(RamDomain& number) {$/;"	f	class:souffle::tuple
operator >>	SouffleInterface.h	/^    tuple& operator>>(std::string& str) {$/;"	f	class:souffle::tuple
operator []	AstClause.h	/^    int operator[](unsigned index) const {$/;"	f	class:souffle::AstExecutionOrder
operator []	Brie.h	/^    bool operator[](index_type i) const {$/;"	f	class:souffle::SparseBitMap
operator []	Brie.h	/^    value_type operator[](index_type i) const {$/;"	f	class:souffle::SparseArray
operator []	CompiledTuple.h	/^    Domain& operator[](std::size_t index) {$/;"	f	struct:souffle::ram::Tuple
operator []	CompiledTuple.h	/^    const Domain& operator[](std::size_t index) const {$/;"	f	struct:souffle::ram::Tuple
operator []	Constraints.h	/^    const value_type& operator[](const Var& var) const {$/;"	f	class:souffle::Assignment
operator []	Constraints.h	/^    value_type& operator[](const Var& var) {$/;"	f	class:souffle::Assignment
operator []	InterpreterContext.h	/^    const RamDomain* const& operator[](size_t index) const {$/;"	f	class:souffle::InterpreterContext
operator []	InterpreterContext.h	/^    const RamDomain*& operator[](size_t index) {$/;"	f	class:souffle::InterpreterContext
operator []	InterpreterIndex.h	/^    unsigned char operator[](std::size_t pos) const {$/;"	f	class:souffle::InterpreterIndexOrder
operator []	SouffleInterface.h	/^    RamDomain& operator[](size_t idx) {$/;"	f	class:souffle::tuple
operator []	SouffleInterface.h	/^    const RamDomain& operator[](size_t idx) const {$/;"	f	class:souffle::tuple
operator []	json11.h	/^inline const Json& Json::operator[](const string& key) const {$/;"	f	class:json11::Json
operator []	json11.h	/^inline const Json& Json::operator[](size_t i) const {$/;"	f	class:json11::Json
operator []	json11.h	/^inline const Json& JsonArray::operator[](size_t i) const {$/;"	f	class:json11::JsonArray
operator []	json11.h	/^inline const Json& JsonObject::operator[](const string& key) const {$/;"	f	class:json11::JsonObject
operator []	json11.h	/^inline const Json& JsonValue::operator[](const string&) const {$/;"	f	class:json11::JsonValue
operator []	json11.h	/^inline const Json& JsonValue::operator[](size_t) const {$/;"	f	class:json11::JsonValue
operator []	parser.hh	/^        operator[] (int i) const$/;"	f	class:yy::parser::stack::slice
operator []	parser.hh	/^      operator[] (int i) const$/;"	f	class:yy::parser::stack
operator []	parser.hh	/^      operator[] (int i)$/;"	f	class:yy::parser::stack
operator []	parser.hh	/^      operator[] (size_type i) const$/;"	f	class:yy::parser::stack
operator []	parser.hh	/^      operator[] (size_type i)$/;"	f	class:yy::parser::stack
operator []	profile/Row.h	/^    std::shared_ptr<CellInterface>& operator[](unsigned long i) {$/;"	f	class:souffle::profile::Row
operator bool	test/test.h	/^        operator bool() const {$/;"	f	struct:TestCase::test_result
order	AstClause.h	/^    std::vector<unsigned int> order;$/;"	m	class:souffle::AstExecutionOrder
order	CompiledIndexUtils.h	/^struct order<index<Columns...>> {$/;"	s	namespace:souffle::ram::index_utils
order	InterpreterIndex.h	/^        const InterpreterIndexOrder& order;$/;"	m	struct:souffle::InterpreterIndex::comparator
order	InterpreterIndex.h	/^    const InterpreterIndexOrder& order() const {$/;"	f	class:souffle::InterpreterIndex
order	PrecedenceGraph.h	/^    const std::vector<size_t>& order() const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
orderIn	CompiledIndexUtils.h	/^    static tuple_type orderIn(const tuple_type& tuple) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
orderIn	CompiledIndexUtils.h	/^    static tuple_type orderIn(const tuple_type& tuple) {$/;"	f	class:souffle::ram::index_utils::TrieIndex
orderOut	CompiledIndexUtils.h	/^    static tuple_type orderOut(const tuple_type& tuple) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
orderOut	CompiledIndexUtils.h	/^    static tuple_type orderOut(const tuple_type& tuple) {$/;"	f	class:souffle::ram::index_utils::TrieIndex
order_in	CompiledIndexUtils.h	/^    void order_in(tuple_type& res, const tuple_type& in) const {$/;"	f	struct:souffle::ram::index_utils::aux_order
order_in	CompiledIndexUtils.h	/^    void order_in(tuple_type& res, const tuple_type& in) const {$/;"	f	struct:souffle::ram::index_utils::order
order_in	CompiledIndexUtils.h	/^    void order_in(tuple_type&, const tuple_type&) const {}$/;"	f	struct:souffle::ram::index_utils::aux_order
order_out	CompiledIndexUtils.h	/^    void order_out(tuple_type& res, const tuple_type& in) const {$/;"	f	struct:souffle::ram::index_utils::aux_order
order_out	CompiledIndexUtils.h	/^    void order_out(tuple_type& res, const tuple_type& in) const {$/;"	f	struct:souffle::ram::index_utils::order
order_out	CompiledIndexUtils.h	/^    void order_out(tuple_type&, const tuple_type&) const {}$/;"	f	struct:souffle::ram::index_utils::aux_order
ordering	MagicSet.h	/^    std::vector<unsigned int> ordering;$/;"	m	class:souffle::AdornedClause
orders	IndexSetAnalysis.h	/^    OrderCollection orders;       \/\/ collection of lexicographical orders$/;"	m	class:souffle::IndexSet
originalArguments	MagicSet.h	/^    std::map<std::string, std::unique_ptr<AstArgument>> originalArguments;$/;"	m	class:souffle::BindingStore
original_hist_cursor_pos	profile/UserInputReader.h	/^    size_t original_hist_cursor_pos = 0;$/;"	m	class:souffle::profile::InputReader
original_hist_val	profile/UserInputReader.h	/^    std::string original_hist_val;$/;"	m	class:souffle::profile::InputReader
original_tab_val	profile/UserInputReader.h	/^    std::string original_tab_val;$/;"	m	class:souffle::profile::InputReader
other	Brie.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::SparseArray::iterator
other	Brie.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::SparseBitMap::iterator
other	Brie.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::detail::TrieBase::iterator
other	Brie.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::SparseArray::iterator
other	Brie.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::SparseBitMap::iterator
other	Brie.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::detail::TrieBase::iterator
other	Brie.h	/^        iterator(iterator&& other) = default;$/;"	m	class:souffle::detail::TrieBase::iterator
other	CompiledIndexUtils.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::ram::index_utils::DisjointSetIndex::iterator
other	CompiledIndexUtils.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::ram::index_utils::TrieIndex::iterator
other	CompiledIndexUtils.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::ram::index_utils::DisjointSetIndex::iterator
other	CompiledIndexUtils.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::ram::index_utils::TrieIndex::iterator
other	EquivalenceRelation.h	/^        iterator& operator=(const iterator& other) = default;$/;"	m	class:souffle::EquivalenceRelation::iterator
other	EquivalenceRelation.h	/^        iterator(const iterator& other) = default;$/;"	m	class:souffle::EquivalenceRelation::iterator
other	EquivalenceRelation.h	/^        iterator(iterator&& other) = default;$/;"	m	class:souffle::EquivalenceRelation::iterator
other	ErrorReport.h	/^    ErrorReport(const ErrorReport& other) = default;$/;"	m	class:souffle::ErrorReport
other	InterpreterRelation.h	/^    InterpreterRelation(const InterpreterRelation& other) = delete;$/;"	m	class:souffle::InterpreterRelation
other	IterUtils.h	/^    SingleValueIterator& operator=(const SingleValueIterator& other) = default;$/;"	m	class:souffle::SingleValueIterator
other	IterUtils.h	/^    SingleValueIterator(const SingleValueIterator& other) = default;$/;"	m	class:souffle::SingleValueIterator
other	ParallelUtils.h	/^        Lease& operator=(Lease&& other) = default;$/;"	m	class:souffle::OptimisticReadWriteLock::Lease
other	ParallelUtils.h	/^        Lease& operator=(const Lease& other) = default;$/;"	m	class:souffle::OptimisticReadWriteLock::Lease
other	ParallelUtils.h	/^        Lease(const Lease& other) = delete;$/;"	m	struct:souffle::Lock::Lease
other	PiggyList.h	/^    PiggyList& operator=(const PiggyList& other) = delete;$/;"	m	class:souffle::PiggyList
other	PiggyList.h	/^    PiggyList(PiggyList&& other) = delete;$/;"	m	class:souffle::PiggyList
other	PiggyList.h	/^    RandomInsertPiggyList& operator=(RandomInsertPiggyList& other) = delete;$/;"	m	class:souffle::RandomInsertPiggyList
other	PiggyList.h	/^    RandomInsertPiggyList& operator=(RandomInsertPiggyList&& other) = delete;$/;"	m	class:souffle::RandomInsertPiggyList
other	PiggyList.h	/^    RandomInsertPiggyList(RandomInsertPiggyList&& other) = delete;$/;"	m	class:souffle::RandomInsertPiggyList
other	ResolveAliasesTransformer.cpp	/^    Equation(Equation&& other) = default;$/;"	m	class:souffle::__anon71::Equation	file:
other	TypeSystem.h	/^    Type(const Type& other) = delete;$/;"	m	class:souffle::Type
other	TypeSystem.h	/^    TypeSet& operator=(const TypeSet& other) = default;$/;"	m	struct:souffle::TypeSet
other	TypeSystem.h	/^    TypeSet(const TypeSet& other) = default;$/;"	m	struct:souffle::TypeSet
other	UnionFind.h	/^    DisjointSet(DisjointSet& other) = delete;$/;"	m	class:souffle::DisjointSet
other	UnionFind.h	/^    DisjointSet(DisjointSet&& other) = delete;$/;"	m	class:souffle::DisjointSet
other	UnionFind.h	/^    SparseDisjointSet& operator=(SparseDisjointSet& other) = delete;$/;"	m	class:souffle::SparseDisjointSet
other	UnionFind.h	/^    SparseDisjointSet& operator=(SparseDisjointSet&& other) = delete;$/;"	m	class:souffle::SparseDisjointSet
other	UnionFind.h	/^    SparseDisjointSet(SparseDisjointSet& other) = delete;$/;"	m	class:souffle::SparseDisjointSet
other	UnionFind.h	/^    SparseDisjointSet(SparseDisjointSet&& other) = delete;$/;"	m	class:souffle::SparseDisjointSet
other	profile/UserInputReader.h	/^    InputReader(const InputReader& other) = default;$/;"	m	class:souffle::profile::InputReader
out	profile/Tui.h	/^    OutputProcessor out;$/;"	m	class:souffle::profile::Tui
out	test/test.h	/^        std::ostream& out;$/;"	m	struct:TestCase::test_result
output	Explain.h	/^    std::ostream* output;$/;"	m	class:souffle::Explain
output	profile/UserInputReader.h	/^    std::string output;$/;"	m	class:souffle::profile::InputReader
outputFactories	IOSystem.h	/^    std::map<std::string, std::shared_ptr<WriteStreamFactory>> outputFactories;$/;"	m	class:souffle::IOSystem
outputHtml	profile/Tui.h	/^    void outputHtml(std::string filename = "profiler_html\/") {$/;"	f	namespace:souffle::profile
outputRelations	AstIOTypeAnalysis.h	/^    std::set<const AstRelation*> outputRelations;$/;"	m	class:souffle::IOType
outputRelations	SouffleInterface.h	/^    std::vector<Relation*> outputRelations;$/;"	m	class:souffle::SouffleProgram
output_dir	CompiledOptions.h	/^    std::string output_dir;$/;"	m	class:souffle::CmdOptions
override	AstArgument.h	/^    AstAggregator* clone() const override;$/;"	m	class:souffle::AstAggregator
override	AstArgument.h	/^    AstArgument* clone() const override = 0;$/;"	m	class:souffle::AstArgument
override	AstArgument.h	/^    std::vector<const AstNode*> getChildNodes() const override;$/;"	m	class:souffle::AstAggregator
override	AstArgument.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::AstAggregator
override	AstArgument.h	/^    ~AstAggregator() override = default;$/;"	m	class:souffle::AstAggregator
override	AstArgument.h	/^    ~AstArgument() override = default;$/;"	m	class:souffle::AstArgument
override	AstArgument.h	/^    ~AstRecordInit() override = default;$/;"	m	class:souffle::AstRecordInit
override	AstArgument.h	/^    ~AstUserDefinedFunctor() override = default;$/;"	m	class:souffle::AstUserDefinedFunctor
override	AstClause.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::AstClause
override	AstClause.h	/^    ~AstClause() override = default;$/;"	m	class:souffle::AstClause
override	AstComponent.h	/^    ~AstComponent() override = default;$/;"	m	class:souffle::AstComponent
override	AstComponentChecker.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::AstComponentChecker
override	AstComponentChecker.h	/^    ~AstComponentChecker() override = default;$/;"	m	class:souffle::AstComponentChecker
override	AstIO.h	/^    ~AstIO() override = default;$/;"	m	class:souffle::AstIO
override	AstIO.h	/^    ~AstLoad() override = default;$/;"	m	class:souffle::AstLoad
override	AstIO.h	/^    ~AstPrintSize() override = default;$/;"	m	class:souffle::AstPrintSize
override	AstIO.h	/^    ~AstStore() override = default;$/;"	m	class:souffle::AstStore
override	AstIOTypeAnalysis.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::IOType
override	AstIOTypeAnalysis.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::IOType
override	AstLiteral.h	/^    AstConstraint* clone() const override = 0;$/;"	m	class:souffle::AstConstraint
override	AstLiteral.h	/^    AstLiteral* clone() const override = 0;$/;"	m	class:souffle::AstLiteral
override	AstLiteral.h	/^    ~AstAtom() override = default;$/;"	m	class:souffle::AstAtom
override	AstLiteral.h	/^    ~AstBinaryConstraint() override = default;$/;"	m	class:souffle::AstBinaryConstraint
override	AstLiteral.h	/^    ~AstBooleanConstraint() override = default;$/;"	m	class:souffle::AstBooleanConstraint
override	AstLiteral.h	/^    ~AstConstraint() override = default;$/;"	m	class:souffle::AstConstraint
override	AstLiteral.h	/^    ~AstLiteral() override = default;$/;"	m	class:souffle::AstLiteral
override	AstLiteral.h	/^    ~AstNegation() override = default;$/;"	m	class:souffle::AstNegation
override	AstLiteral.h	/^    ~AstProvenanceNegation() override = default;$/;"	m	class:souffle::AstProvenanceNegation
override	AstPragma.h	/^    bool transform(AstTranslationUnit&) override;$/;"	m	class:souffle::AstPragmaChecker
override	AstPragma.h	/^    ~AstPragma() override = default;$/;"	m	class:souffle::AstPragma
override	AstProfileUse.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::AstProfileUse
override	AstProfileUse.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::AstProfileUse
override	AstProgram.h	/^    AstProgram* clone() const override;$/;"	m	class:souffle::AstProgram
override	AstProgram.h	/^    void apply(const AstNodeMapper& map) override;$/;"	m	class:souffle::AstProgram
override	AstProgram.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::AstProgram
override	AstProgram.h	/^    ~AstProgram() override = default;$/;"	m	class:souffle::AstProgram
override	AstRelation.h	/^    ~AstRelation() override = default;$/;"	m	class:souffle::AstRelation
override	AstSemanticChecker.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::AstExecutionPlanChecker
override	AstSemanticChecker.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::AstSemanticChecker
override	AstSemanticChecker.h	/^    ~AstSemanticChecker() override = default;$/;"	m	class:souffle::AstSemanticChecker
override	AstTransformer.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::NullTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ConditionalTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::FixpointTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::InlineRelationsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::MagicSetTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::MinimiseProgramTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::NormaliseConstraintsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::PartitionBodyLiteralsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::PipelineTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ProvenanceTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ReduceExistentialsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RemoveBooleanConstraintsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RemoveRedundantRelationsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ReorderLiteralsTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ReplaceSingletonVariablesTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ResolveAliasesTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::UniqueAggregationVariablesTransformer
override	AstTransforms.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::WhileTransformer
override	AstTranslator.h	/^        std::unique_ptr<RamCondition> createCondition(const AstClause& originalClause) override;$/;"	m	class:souffle::AstTranslator::ProvenanceClauseTranslator
override	AstTranslator.h	/^        std::unique_ptr<RamOperation> createOperation(const AstClause& clause) override;$/;"	m	class:souffle::AstTranslator::ProvenanceClauseTranslator
override	AstType.h	/^    AstType* clone() const override = 0;$/;"	m	class:souffle::AstType
override	AstTypeAnalysis.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::TypeAnalysis
override	AstTypeAnalysis.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::TypeAnalysis
override	AstTypeEnvironmentAnalysis.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::TypeEnvironmentAnalysis
override	AstTypeEnvironmentAnalysis.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::TypeEnvironmentAnalysis
override	ComponentModel.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ComponentInstantiationTransformer
override	ComponentModel.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::ComponentLookup
override	DebugReport.h	/^    bool transform(AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::DebugReporter
override	IndexSetAnalysis.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::IndexSetAnalysis
override	IndexSetAnalysis.h	/^    void run(const RamTranslationUnit& translationUnit) override;$/;"	m	class:souffle::IndexSetAnalysis
override	InterpreterInterface.h	/^        ~iterator_base() override = default;$/;"	m	class:souffle::InterpreterRelInterface::iterator_base
override	InterpreterInterface.h	/^    ~InterpreterRelInterface() override = default;$/;"	m	class:souffle::InterpreterRelInterface
override	MagicSet.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::Adornment
override	MagicSet.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::Adornment
override	MagicSet.h	/^    ~Adornment() override = default;$/;"	m	class:souffle::Adornment
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::PrecedenceGraph
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::RecursiveClauses
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::RedundantRelations
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::RelationSchedule
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::SCCGraph
override	PrecedenceGraph.h	/^    void print(std::ostream& os) const override;$/;"	m	class:souffle::TopologicallySortedSCCGraph
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::PrecedenceGraph
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RecursiveClauses
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RedundantRelations
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RelationSchedule
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::SCCGraph
override	PrecedenceGraph.h	/^    void run(const AstTranslationUnit& translationUnit) override;$/;"	m	class:souffle::TopologicallySortedSCCGraph
override	RamCondition.h	/^    RamCondition* clone() const override = 0;$/;"	m	class:souffle::RamCondition
override	RamConditionLevel.h	/^    void run(const RamTranslationUnit& translationUnit) override;$/;"	m	class:souffle::RamConditionLevelAnalysis
override	RamExpression.h	/^    RamExpression* clone() const override = 0;$/;"	m	class:souffle::RamExpression
override	RamOperation.h	/^    RamOperation* clone() const override = 0;$/;"	m	class:souffle::RamOperation
override	RamOperation.h	/^    bool equal(const RamNode& node) const override = 0;$/;"	m	class:souffle::RamOperation
override	RamOperation.h	/^    std::vector<const RamNode*> getChildNodes() const override = 0;$/;"	m	class:souffle::RamOperation
override	RamOperation.h	/^    void apply(const RamNodeMapper& map) override = 0;$/;"	m	class:souffle::RamOperation
override	RamStatement.h	/^    RamStatement* clone() const override = 0;$/;"	m	class:souffle::RamStatement
override	ReadStreamCSV.h	/^    ~ReadCinCSVFactory() override = default;$/;"	m	class:souffle::ReadCinCSVFactory
override	ReadStreamCSV.h	/^    ~ReadFileCSV() override = default;$/;"	m	class:souffle::ReadFileCSV
override	ReadStreamCSV.h	/^    ~ReadFileCSVFactory() override = default;$/;"	m	class:souffle::ReadFileCSVFactory
override	ReadStreamCSV.h	/^    ~ReadStreamCSV() override = default;$/;"	m	class:souffle::ReadStreamCSV
override	ReadStreamSQLite.h	/^    ~ReadSQLiteFactory() override = default;$/;"	m	class:souffle::ReadSQLiteFactory
override	SynthesiserRelation.h	/^    std::string getTypeName() override;$/;"	m	class:souffle::SynthesiserBrieRelation
override	SynthesiserRelation.h	/^    std::string getTypeName() override;$/;"	m	class:souffle::SynthesiserDirectRelation
override	SynthesiserRelation.h	/^    std::string getTypeName() override;$/;"	m	class:souffle::SynthesiserEqrelRelation
override	SynthesiserRelation.h	/^    std::string getTypeName() override;$/;"	m	class:souffle::SynthesiserIndirectRelation
override	SynthesiserRelation.h	/^    std::string getTypeName() override;$/;"	m	class:souffle::SynthesiserNullaryRelation
override	SynthesiserRelation.h	/^    void computeIndices() override;$/;"	m	class:souffle::SynthesiserBrieRelation
override	SynthesiserRelation.h	/^    void computeIndices() override;$/;"	m	class:souffle::SynthesiserDirectRelation
override	SynthesiserRelation.h	/^    void computeIndices() override;$/;"	m	class:souffle::SynthesiserEqrelRelation
override	SynthesiserRelation.h	/^    void computeIndices() override;$/;"	m	class:souffle::SynthesiserIndirectRelation
override	SynthesiserRelation.h	/^    void computeIndices() override;$/;"	m	class:souffle::SynthesiserNullaryRelation
override	SynthesiserRelation.h	/^    void generateTypeStruct(std::ostream& out) override;$/;"	m	class:souffle::SynthesiserBrieRelation
override	SynthesiserRelation.h	/^    void generateTypeStruct(std::ostream& out) override;$/;"	m	class:souffle::SynthesiserDirectRelation
override	SynthesiserRelation.h	/^    void generateTypeStruct(std::ostream& out) override;$/;"	m	class:souffle::SynthesiserEqrelRelation
override	SynthesiserRelation.h	/^    void generateTypeStruct(std::ostream& out) override;$/;"	m	class:souffle::SynthesiserIndirectRelation
override	SynthesiserRelation.h	/^    void generateTypeStruct(std::ostream& out) override;$/;"	m	class:souffle::SynthesiserNullaryRelation
override	TypeSystem.h	/^    void print(std::ostream& out) const override;$/;"	m	class:souffle::PrimitiveType
override	TypeSystem.h	/^    void print(std::ostream& out) const override;$/;"	m	class:souffle::UnionType
override	TypeSystem.h	/^    void print(std::ostream& out) const override;$/;"	m	struct:souffle::RecordType
override	WriteStreamCSV.h	/^    ~WriteCoutCSVFactory() override = default;$/;"	m	class:souffle::WriteCoutCSVFactory
override	WriteStreamCSV.h	/^    ~WriteCoutPrintSize() override = default;$/;"	m	class:souffle::WriteCoutPrintSize
override	WriteStreamCSV.h	/^    ~WriteCoutPrintSizeFactory() override = default;$/;"	m	class:souffle::WriteCoutPrintSizeFactory
override	WriteStreamCSV.h	/^    ~WriteFileCSV() override = default;$/;"	m	class:souffle::WriteFileCSV
override	WriteStreamCSV.h	/^    ~WriteFileCSVFactory() override = default;$/;"	m	class:souffle::WriteFileCSVFactory
override	WriteStreamCSV.h	/^    ~WriteGZipFileCSV() override = default;$/;"	m	class:souffle::WriteGZipFileCSV
override	WriteStreamSQLite.h	/^    ~WriteSQLiteFactory() override = default;$/;"	m	class:souffle::WriteSQLiteFactory
override	gzfstream.h	/^    ~gzfstream() override = default;$/;"	m	class:souffle::gzfstream::internal::gzfstream
override	json11.h	/^    const Json& operator[](const string& key) const override;$/;"	m	class:json11::final
override	json11.h	/^    const Json& operator[](size_t i) const override;$/;"	m	class:json11::final
override	profile/Cell.h	/^    ~Cell() override = default;$/;"	m	class:souffle::profile::Cell
overrideRules	AstComponent.h	/^    std::set<std::string> overrideRules;$/;"	m	class:souffle::AstComponent
p	Util.h	/^    Printer p;$/;"	m	class:souffle::detail::joined_sequence
p	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
pProofCounter	LogStatement.h	/^    static const std::string pProofCounter($/;"	f	class:souffle::LogStatement
pack	CompiledRecord.h	/^    RamDomain pack(const tuple_type& tuple) {$/;"	f	class:souffle::detail::RecordMap
pack	CompiledRecord.h	/^RamDomain pack(const Tuple& tuple) {$/;"	f	namespace:souffle
pack	InterpreterRecords.cpp	/^    RamDomain pack(const RamDomain* tuple) {$/;"	f	class:souffle::__anon67::RecordMap
pack	InterpreterRecords.cpp	/^RamDomain pack(RamDomain* tuple, int arity) {$/;"	f	namespace:souffle
pack	Mpi.h	/^inline void pack<std::vector<std::string>>($/;"	f	namespace:souffle::mpi::__anon55
pack_lock	CompiledRecord.h	/^    Lock pack_lock;$/;"	m	class:souffle::detail::RecordMap
parent	BTree.h	/^        node* volatile parent;$/;"	m	struct:souffle::detail::btree::base
parent	Brie.h	/^        const Node* parent;$/;"	m	struct:souffle::SparseArray::Node
parse	CompiledOptions.h	/^    bool parse(int argc, char** argv) {$/;"	f	class:souffle::CmdOptions
parse	ParserDriver.cpp	/^std::unique_ptr<AstTranslationUnit> ParserDriver::parse(const std::string& code, SymbolTable& symbolTable,$/;"	f	class:souffle::ParserDriver
parse	ParserDriver.cpp	/^std::unique_ptr<AstTranslationUnit> ParserDriver::parse(const std::string& filename, FILE* in,$/;"	f	class:souffle::ParserDriver
parse	json11.h	/^    static Json parse(const char* in, std::string& err, JsonParse strategy = JsonParse::STANDARD) {$/;"	f	class:json11::final
parse	json11.h	/^inline Json Json::parse(const string& in, string& err, JsonParse strategy) {$/;"	f	class:json11::Json
parse	parser.cc	/^  parser::parse ()$/;"	f	class:yy::parser
parse	profile/Cli.h	/^    void parse() {$/;"	f	class:souffle::profile::Cli
parseTranslationUnit	ParserDriver.cpp	/^std::unique_ptr<AstTranslationUnit> ParserDriver::parseTranslationUnit(const std::string& code,$/;"	f	class:souffle::ParserDriver
parseTranslationUnit	ParserDriver.cpp	/^std::unique_ptr<AstTranslationUnit> ParserDriver::parseTranslationUnit(const std::string& filename, FILE* in,$/;"	f	class:souffle::ParserDriver
parseTuple	Explain.h	/^    std::pair<std::string, std::vector<std::string>> parseTuple(const std::string& str) {$/;"	f	class:souffle::Explain
parse_json	json11.h	/^    Json parse_json(int depth) {$/;"	f	struct:json11::__anon66::final
parse_multi	json11.h	/^    static inline std::vector<Json> parse_multi($/;"	f	class:json11::final
parse_multi	json11.h	/^inline vector<Json> Json::parse_multi($/;"	f	class:json11::Json
parse_number	json11.h	/^    Json parse_number() {$/;"	f	struct:json11::__anon66::final
parse_string	json11.h	/^    string parse_string() {$/;"	f	struct:json11::__anon66::final
parser	parser.cc	/^  parser::parser (ParserDriver &driver_yyarg, yyscan_t yyscanner_yyarg)$/;"	f	class:yy::parser
parser	parser.hh	/^  class parser$/;"	c	namespace:yy
partition	Brie.h	/^    std::vector<range<iterator>> partition(unsigned chunks = 500) const {$/;"	f	class:souffle::Trie
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition(const First&) const {$/;"	f	class:souffle::ram::index_utils::Indices
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition(const I&) const {$/;"	f	class:souffle::ram::index_utils::Indices
partition	CompiledIndexUtils.h	/^    std::vector<range<iterator>> partition(std::size_t np = 400) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
partition	CompiledRelation.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	class:souffle::ram::detail::AutoRelation
partition	CompiledRelation.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	class:souffle::ram::detail::GenericRelation
partition	CompiledRelation.h	/^    std::vector<range<iterator>> partition() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
partition	EquivalenceRelation.h	/^    std::vector<souffle::range<iterator>> partition(size_t chunks) const {$/;"	f	class:souffle::EquivalenceRelation
partition	Util.h	/^    std::vector<range> partition(int np = 100) {$/;"	f	struct:souffle::range
pattern	RamOperation.h	/^    std::vector<std::unique_ptr<RamExpression>> pattern;$/;"	m	class:souffle::RamAggregate
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
pfor	ParallelUtils.h	/^#define pfor /;"	d
pipeline	AstTransforms.h	/^    std::vector<std::unique_ptr<AstTransformer>> pipeline;$/;"	m	class:souffle::PipelineTransformer
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/souffle$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/souffle$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/souffle$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/souffle$/;"	m
plan	AstClause.h	/^    std::unique_ptr<AstExecutionPlan> plan;$/;"	m	class:souffle::AstClause
plans	AstClause.h	/^    std::map<int, std::unique_ptr<AstExecutionOrder>> plans;$/;"	m	class:souffle::AstExecutionPlan
pos	BTree.h	/^        field_index_type pos = 0;$/;"	m	class:souffle::detail::btree::iterator
pos	SouffleInterface.h	/^    size_t pos;$/;"	m	class:souffle::tuple
pos	Table.h	/^        unsigned pos;$/;"	m	class:souffle::Table::iterator
position	BTree.h	/^        volatile field_index_type position;$/;"	m	struct:souffle::detail::btree::base
postMaxRSS	profile/Relation.h	/^    size_t postMaxRSS = 0;$/;"	m	class:souffle::profile::Relation
pr2b	UnionFind.h	/^    static inline block_t pr2b(const parent_t parent, const rank_t rank) {$/;"	f	class:souffle::DisjointSet
pragmaDirectives	AstProgram.h	/^    std::vector<std::unique_ptr<AstPragma>> pragmaDirectives;$/;"	m	class:souffle::AstProgram
preMaxRSS	profile/Relation.h	/^    size_t preMaxRSS = 0;$/;"	m	class:souffle::profile::Relation
preSize	Logger.h	/^    size_t preSize;$/;"	m	class:souffle::Logger
precedenceGraph	PrecedenceGraph.h	/^    PrecedenceGraph* precedenceGraph = nullptr;$/;"	m	class:souffle::RedundantRelations
precedenceGraph	PrecedenceGraph.h	/^    PrecedenceGraph* precedenceGraph = nullptr;$/;"	m	class:souffle::RelationSchedule
precedenceGraph	PrecedenceGraph.h	/^    PrecedenceGraph* precedenceGraph = nullptr;$/;"	m	class:souffle::SCCGraph
precision	profile/Tui.h	/^    int precision = 3;$/;"	m	class:souffle::profile::Tui
predecessors	GraphUtils.h	/^    const std::set<Vertex, Compare>& predecessors(const Vertex& to) const {$/;"	f	class:souffle::Graph
predecessors	PrecedenceGraph.h	/^    std::vector<std::set<size_t>> predecessors;$/;"	m	class:souffle::SCCGraph
predicateName	MagicSet.h	/^    AstRelationIdentifier predicateName;$/;"	m	class:souffle::AdornedPredicate
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
prepareInsertStatement	WriteStreamSQLite.h	/^    void prepareInsertStatement() {$/;"	f	class:souffle::WriteStreamSQLite
prepareSelectStatement	ReadStreamSQLite.h	/^    void prepareSelectStatement() {$/;"	f	class:souffle::ReadStreamSQLite
prepareStatements	WriteStreamSQLite.h	/^    void prepareStatements() {$/;"	f	class:souffle::WriteStreamSQLite
prepareSymbolInsertStatement	WriteStreamSQLite.h	/^    void prepareSymbolInsertStatement() {$/;"	f	class:souffle::WriteStreamSQLite
prepareSymbolSelectStatement	WriteStreamSQLite.h	/^    void prepareSymbolSelectStatement() {$/;"	f	class:souffle::WriteStreamSQLite
prepend	AstRelationIdentifier.h	/^    void prepend(const std::string& name) {$/;"	f	class:souffle::AstRelationIdentifier
prepend	AstType.h	/^    void prepend(const std::string& name) {$/;"	f	class:souffle::AstTypeIdentifier
present	Brie.h	/^    bool present = false;$/;"	m	class:souffle::Trie
prevFpeHandler	SignalHandler.h	/^    void (*prevFpeHandler)(int) = nullptr;$/;"	m	class:souffle::SignalHandler
prevIntHandler	SignalHandler.h	/^    void (*prevIntHandler)(int) = nullptr;$/;"	m	class:souffle::SignalHandler
prevSegVHandler	SignalHandler.h	/^    void (*prevSegVHandler)(int) = nullptr;$/;"	m	class:souffle::SignalHandler
primaryMessage	ErrorReport.h	/^    DiagnosticMessage primaryMessage;$/;"	m	class:souffle::Diagnostic
print	AstAnalysis.h	/^    virtual void print(std::ostream& os) const {}$/;"	f	class:souffle::AstAnalysis
print	AstArgument.cpp	/^void AstAggregator::print(std::ostream& os) const {$/;"	f	class:souffle::AstAggregator
print	AstClause.cpp	/^void AstClause::print(std::ostream& os) const {$/;"	f	class:souffle::AstClause
print	AstIOTypeAnalysis.cpp	/^void IOType::print(std::ostream& os) const {$/;"	f	class:souffle::IOType
print	AstProfileUse.cpp	/^void AstProfileUse::print(std::ostream& os) const {}$/;"	f	class:souffle::AstProfileUse
print	AstProgram.cpp	/^void AstProgram::print(std::ostream& os) const {$/;"	f	class:souffle::AstProgram
print	AstRelationIdentifier.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::AstRelationIdentifier
print	AstTranslator.h	/^        void print(std::ostream& out) const {$/;"	f	class:souffle::AstTranslator::ValueIndex
print	AstTranslator.h	/^        void print(std::ostream& out) const {$/;"	f	struct:souffle::AstTranslator::Location
print	AstType.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::AstTypeIdentifier
print	AstTypeAnalysis.cpp	/^void TypeAnalysis::print(std::ostream& os) const {$/;"	f	class:souffle::TypeAnalysis
print	AstTypeEnvironmentAnalysis.cpp	/^void TypeEnvironmentAnalysis::print(std::ostream& os) const {$/;"	f	class:souffle::TypeEnvironmentAnalysis
print	BTree.h	/^        void print(std::ostream& out = std::cout) const {$/;"	f	class:souffle::detail::btree::iterator
print	Brie.h	/^        void print(std::ostream& out) const {$/;"	f	class:souffle::SparseArray::iterator
print	Brie.h	/^        void print(std::ostream& out) const {$/;"	f	class:souffle::SparseBitMap::iterator
print	Brie.h	/^        void print(std::ostream& out) const {$/;"	f	class:souffle::Trie::iterator_core
print	Brie.h	/^        void print(std::ostream& out) const {$/;"	f	class:souffle::detail::TrieBase::iterator
print	CompiledIndexUtils.h	/^struct print<> {$/;"	s	namespace:souffle::ram::index_utils
print	CompiledIndexUtils.h	/^struct print<First, Second, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
print	CompiledIndexUtils.h	/^struct print<Last> {$/;"	s	namespace:souffle::ram::index_utils
print	Constraints.h	/^    virtual void print(std::ostream& out) const {$/;"	f	struct:souffle::Variable
print	Constraints.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::Assignment
print	Constraints.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::Problem
print	DebugReport.cpp	/^void DebugReport::print(std::ostream& out) const {$/;"	f	class:souffle::DebugReport
print	ErrorReport.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::Diagnostic
print	ErrorReport.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::DiagnosticMessage
print	ErrorReport.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::ErrorReport
print	ExplainTree.h	/^    void print(std::ostream& os) {$/;"	f	class:souffle::ScreenBuffer
print	Global.h	/^    void print(std::ostream& os) {$/;"	f	class:souffle::BaseTable
print	GraphUtils.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::Graph
print	IODirectives.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::IODirectives
print	IndexSetAnalysis.cpp	/^void IndexSetAnalysis::print(std::ostream& os) const {$/;"	f	class:souffle::IndexSetAnalysis
print	Interpreter.cpp	/^void LowLevelMachine::print() {$/;"	f	class:souffle::LowLevelMachine
print	InterpreterIndex.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::InterpreterIndex
print	InterpreterIndex.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::InterpreterIndexOrder
print	MagicSet.cpp	/^void Adornment::print(std::ostream& os) const {$/;"	f	class:souffle::Adornment
print	PrecedenceGraph.cpp	/^void PrecedenceGraph::print(std::ostream& os) const {$/;"	f	class:souffle::PrecedenceGraph
print	PrecedenceGraph.cpp	/^void RecursiveClauses::print(std::ostream& os) const {$/;"	f	class:souffle::RecursiveClauses
print	PrecedenceGraph.cpp	/^void RedundantRelations::print(std::ostream& os) const {$/;"	f	class:souffle::RedundantRelations
print	PrecedenceGraph.cpp	/^void RelationSchedule::print(std::ostream& os) const {$/;"	f	class:souffle::RelationSchedule
print	PrecedenceGraph.cpp	/^void RelationScheduleStep::print(std::ostream& os) const {$/;"	f	class:souffle::RelationScheduleStep
print	PrecedenceGraph.cpp	/^void SCCGraph::print(std::ostream& os) const {$/;"	f	class:souffle::SCCGraph
print	PrecedenceGraph.cpp	/^void TopologicallySortedSCCGraph::print(std::ostream& os) const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
print	RamAnalysis.h	/^    virtual void print(std::ostream& os) const {}$/;"	f	class:souffle::RamAnalysis
print	ResolveAliasesTransformer.cpp	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::__anon71::Equation
print	ResolveAliasesTransformer.cpp	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::__anon71::Substitution
print	SrcLocation.h	/^        void print(std::ostream& out) const {$/;"	f	struct:souffle::SrcLocation::Point
print	SrcLocation.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::SrcLocation
print	SymbolTable.h	/^    void print(std::ostream& out) const {$/;"	f	class:souffle::SymbolTable
print	TypeSystem.cpp	/^void PrimitiveType::print(std::ostream& out) const {$/;"	f	class:souffle::PrimitiveType
print	TypeSystem.cpp	/^void RecordType::print(std::ostream& out) const {$/;"	f	class:souffle::RecordType
print	TypeSystem.cpp	/^void TypeEnvironment::print(std::ostream& out) const {$/;"	f	class:souffle::TypeEnvironment
print	TypeSystem.cpp	/^void UnionType::print(std::ostream& out) const {$/;"	f	class:souffle::UnionType
print	TypeSystem.h	/^    virtual void print(std::ostream& out = std::cout) const {$/;"	f	class:souffle::Type
print	TypeSystem.h	/^    void print(std::ostream& out) const {$/;"	f	struct:souffle::TypeSet
print	Util.h	/^struct print {$/;"	s	namespace:souffle::detail
printContent	DebugReport.cpp	/^void DebugReportSection::printContent(std::ostream& out) const {$/;"	f	class:souffle::DebugReportSection
printDescription	CompiledIndexUtils.h	/^    static void printDescription(std::ostream& out) {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
printDescription	CompiledIndexUtils.h	/^    static void printDescription(std::ostream& out) {$/;"	f	class:souffle::ram::index_utils::TrieIndex
printDescription	CompiledIndexUtils.h	/^    static void printDescription(std::ostream& out) {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
printDescription	CompiledIndexUtils.h	/^    static void printDescription(std::ostream& out) {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
printDescription	CompiledIndexUtils.h	/^    std::ostream& printDescription(std::ostream& out = std::cout) const {$/;"	f	class:souffle::ram::index_utils::Indices
printDescription	CompiledRelation.h	/^    std::ostream& printDescription(std::ostream& out = std::cout) const {$/;"	f	class:souffle::ram::detail::AutoRelation
printDescription	CompiledRelation.h	/^    std::ostream& printDescription(std::ostream& out = std::cout) const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
printDescription	CompiledRelation.h	/^    std::ostream& printDescription(std::ostream& out = std::cout) const {$/;"	f	class:souffle::ram::detail::GenericRelation
printDescription	CompiledRelation.h	/^    std::ostream& printDescription(std::ostream& out = std::cout) const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
printHelpPage	CompiledOptions.h	/^    void printHelpPage(const std::string& exec_name) const {$/;"	f	class:souffle::CmdOptions
printHintStatistics	CompiledIndexUtils.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix) const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
printHintStatistics	CompiledIndexUtils.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix) const {$/;"	f	class:souffle::ram::index_utils::Indices
printHintStatistics	CompiledIndexUtils.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix) const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
printHintStatistics	CompiledIndexUtils.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix) const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
printHintStatistics	CompiledIndexUtils.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix) const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
printHintStatistics	CompiledRelation.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix = "") const {$/;"	f	class:souffle::ram::detail::AutoRelation
printHintStatistics	CompiledRelation.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix = "") const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
printHintStatistics	CompiledRelation.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix = "") const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
printHintStatistics	CompiledRelation.h	/^    void printHintStatistics(std::ostream& out, const std::string& prefix = "") const {$/;"	f	struct:souffle::ram::detail::RelationBase
printHintStatistics	CompiledSouffle.h	/^    void printHintStatistics(std::ostream& o, std::string prefix) const {}$/;"	f	class:souffle::t_nullaries
printHintStatisticsInternal	CompiledIndexUtils.h	/^    void printHintStatisticsInternal(std::ostream& out, const std::string& prefix) const {$/;"	f	class:souffle::ram::index_utils::Indices
printHintStatisticsInternal	CompiledIndexUtils.h	/^    void printHintStatisticsInternal(std::ostream&, const std::string&) const {$/;"	f	class:souffle::ram::index_utils::Indices
printIndex	DebugReport.cpp	/^void DebugReportSection::printIndex(std::ostream& out) const {$/;"	f	class:souffle::DebugReportSection
printSizeRelations	AstIOTypeAnalysis.h	/^    std::set<const AstRelation*> printSizeRelations;$/;"	m	class:souffle::IOType
printSizes	AstComponent.h	/^    std::vector<std::unique_ptr<AstPrintSize>> printSizes;$/;"	m	class:souffle::AstComponent
printSizes	AstProgram.h	/^    std::vector<std::unique_ptr<AstPrintSize>> printSizes;$/;"	m	class:souffle::AstProgram
printSizes	ComponentModel.cpp	/^    std::vector<std::unique_ptr<AstPrintSize>> printSizes;$/;"	m	struct:souffle::__anon73::ComponentContent	file:
printStats	BTree.h	/^    void printStats(std::ostream& out = std::cout) const {$/;"	f	class:souffle::detail::btree
printStr	Explain.h	/^    void printStr(const std::string& s) {$/;"	f
printTitle	DebugReport.cpp	/^void DebugReportSection::printTitle(std::ostream& out) const {$/;"	f	class:souffle::DebugReportSection
printTree	BTree.h	/^        void printTree(std::ostream& out, const std::string& prefix) const {$/;"	f	struct:souffle::detail::btree::node
printTree	BTree.h	/^    void printTree(std::ostream& out = std::cout) const {$/;"	f	class:souffle::detail::btree
print_deref	Util.h	/^struct print_deref : public detail::print<deref<T>> {};$/;"	s	namespace:souffle
probe	Mpi.h	/^inline Status probe() {$/;"	f	namespace:souffle::mpi::__anon61
probe	Mpi.h	/^inline Status probe(const Status& status) {$/;"	f	namespace:souffle::mpi::__anon61
probe	Mpi.h	/^inline Status probe(const int source, const int tag) {$/;"	f	namespace:souffle::mpi::__anon61
process	EventProcessor.h	/^    virtual void process($/;"	f	class:souffle::profile::EventProcessor
process	EventProcessor.h	/^    void process(ProfileDatabase& db, const char* txt, ...) {$/;"	f	class:souffle::profile::EventProcessorSingleton
processArgs	Global.cpp	/^void MainConfig::processArgs(int argc, char** argv, const std::string& header, const std::string& footer,$/;"	f	class:souffle::MainConfig
processFile	profile/Reader.h	/^    void processFile() {$/;"	f	class:souffle::profile::Reader
profile	EventProcessor.h	/^namespace profile {$/;"	n	namespace:souffle
profile	ProfileDatabase.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Cell.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/CellInterface.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Cli.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/DataComparator.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/HtmlGenerator.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Iteration.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/OutputProcessor.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/ProgramRun.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Reader.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Relation.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Row.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Rule.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/StringUtils.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Table.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/Tui.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/UserInputReader.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlCssChartist.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlCssStyle.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlJsChartistMin.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlJsChartistPlugin.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlJsMain.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlJsTableSort.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlJsUtil.h	/^namespace profile {$/;"	n	namespace:souffle
profile	profile/htmlMain.h	/^namespace profile {$/;"	n	namespace:souffle
profileText	RamOperation.h	/^    const std::string profileText;$/;"	m	class:souffle::RamNestedOperation
profile_name	CompiledOptions.h	/^    std::string profile_name;$/;"	m	class:souffle::CmdOptions
profiling	CompiledOptions.h	/^    bool profiling;$/;"	m	class:souffle::CmdOptions
prog	ExplainProvenance.h	/^    SouffleProgram& prog;$/;"	m	class:souffle::ExplainProvenance
prog	InterpreterInterface.h	/^    const RamProgram& prog;$/;"	m	class:souffle::InterpreterProgInterface
program	AstTranslationUnit.h	/^    std::unique_ptr<AstProgram> program;$/;"	m	class:souffle::AstTranslationUnit
program	AstTranslator.h	/^    const AstProgram* program = nullptr;$/;"	m	class:souffle::AstTranslator
program	RamTranslationUnit.h	/^    std::unique_ptr<RamProgram> program;$/;"	m	class:souffle::RamTranslationUnit
programResourceUtilisationProcessor	EventProcessor.h	/^} programResourceUtilisationProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::ProgramResourceUtilisationProcessor
programRun	AstProfileUse.h	/^    std::shared_ptr<profile::ProgramRun> programRun;$/;"	m	class:souffle::AstProfileUse
programRun	profile/OutputProcessor.h	/^    std::shared_ptr<ProgramRun> programRun;$/;"	m	class:souffle::profile::OutputProcessor
programRuntimeProcessor	EventProcessor.h	/^} programRuntimeProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::ProgramRuntimeProcessor
programTimepointProcessor	EventProcessor.h	/^} programTimepointProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::ProgramTimepointProcessor
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
prompt	profile/UserInputReader.h	/^    std::string prompt = "Input: ";$/;"	m	class:souffle::profile::InputReader
property_space	Constraints.h	/^struct property_space {$/;"	s	namespace:souffle
prov	Explain.h	/^    ExplainProvenance& prov;$/;"	m	class:souffle::Explain
provNegations	AstClause.h	/^    std::vector<std::unique_ptr<AstProvenanceNegation>> provNegations;$/;"	m	class:souffle::AstClause
psdir	Makefile	/^psdir = ${docdir}$/;"	m
pthread_yield	ParallelUtils.h	/^#define pthread_yield /;"	d
ptr	Brie.h	/^        Node* ptr;$/;"	m	union:souffle::SparseArray::Cell
purge	CompiledRelation.h	/^    void purge() {$/;"	f	class:souffle::ram::detail::AutoRelation
purge	CompiledRelation.h	/^    void purge() {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
purge	CompiledRelation.h	/^    void purge() {$/;"	f	class:souffle::ram::detail::GenericRelation
purge	CompiledRelation.h	/^    void purge() {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
purge	CompiledSouffle.h	/^    void purge() {$/;"	f	class:souffle::t_nullaries
purge	InterpreterIndex.h	/^    void purge() {$/;"	f	class:souffle::InterpreterIndex
purge	InterpreterRelation.h	/^    void purge() {$/;"	f	class:souffle::InterpreterRelation
purgeInputRelations	SouffleInterface.h	/^    void purgeInputRelations() {$/;"	f	class:souffle::SouffleProgram
purgeInternalRelations	SouffleInterface.h	/^    void purgeInternalRelations() {$/;"	f	class:souffle::SouffleProgram
purgeOutputRelations	SouffleInterface.h	/^    void purgeOutputRelations() {$/;"	f	class:souffle::SouffleProgram
px	profile/htmlMain.h	/^    <div id="Help" class="tabcontent" style="max-width:800px;margin-left: auto;margin-right: auto;">$/;"	m	namespace:souffle::profile::html
q	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile::html
qualifier	AstRelation.h	/^    int qualifier = 0;$/;"	m	class:souffle::AstRelation
queryPattern	RamOperation.h	/^    std::vector<std::unique_ptr<RamExpression>> queryPattern;$/;"	m	class:souffle::RamIndexScan
queryWindow	Explain.h	/^    WINDOW* queryWindow = nullptr;$/;"	m	class:souffle::Explain
quit	profile/Tui.h	/^    void quit() {$/;"	f	namespace:souffle::profile
r2i	InterpreterRecords.cpp	/^    map<vector<RamDomain>, RamDomain> r2i;$/;"	m	class:souffle::__anon67::RecordMap	file:
raise	CompiledIndexUtils.h	/^T raise(T tuple) {$/;"	f	namespace:souffle::ram::index_utils
raiseLevel	Brie.h	/^    void raiseLevel() {$/;"	f	class:souffle::SparseArray
raiseLevel	Brie.h	/^    void raiseLevel(RootInfoSnapshot& info) {$/;"	f	class:souffle::SparseArray
ram	CompiledIndexUtils.h	/^namespace ram {$/;"	n	namespace:souffle
ram	CompiledRelation.h	/^namespace ram {$/;"	n	namespace:souffle
ram	CompiledTuple.h	/^namespace ram {$/;"	n	namespace:souffle
ram	test/compiled_index_utils_test.cpp	/^namespace ram {$/;"	n	namespace:souffle	file:
ram	test/compiled_relation_test.cpp	/^namespace ram {$/;"	n	namespace:souffle	file:
ram	test/compiled_tuple_test.cpp	/^namespace ram {$/;"	n	namespace:souffle	file:
ramProg	AstTranslator.h	/^    std::unique_ptr<RamProgram> ramProg;$/;"	m	class:souffle::AstTranslator
ramRelationInterface	InterpreterInterface.h	/^        const InterpreterRelInterface* ramRelationInterface;$/;"	m	class:souffle::InterpreterRelInterface::iterator_base
ram_visitor_tag	RamVisitor.h	/^struct ram_visitor_tag {};$/;"	s	namespace:souffle
rand	test/brie_test.cpp	/^RamDomain rand(RamDomain max) {$/;"	f	namespace:__anon6
range	Util.h	/^    range(Iter a, Iter b) : a(std::move(a)), b(std::move(b)) {}$/;"	f	struct:souffle::range
range	Util.h	/^struct range {$/;"	s	namespace:souffle
range_	parser.hh	/^        int range_;$/;"	m	class:yy::parser::stack::slice
rdbuf	gzfstream.h	/^    gzfstreambuf* rdbuf() const {$/;"	f	class:souffle::gzfstream::internal::gzfstream
rdbuf	gzfstream.h	/^    internal::gzfstreambuf* rdbuf() const {$/;"	f	class:souffle::gzfstream::igzfstream
rdbuf	gzfstream.h	/^    internal::gzfstreambuf* rdbuf() const {$/;"	f	class:souffle::gzfstream::ogzfstream
reaches	GraphUtils.h	/^    bool reaches(const Vertex& from, const Vertex& to) const {$/;"	f	class:souffle::Graph
readAll	ReadStream.h	/^    void readAll(T& relation) {$/;"	f	class:souffle::ReadStream
readDirectoryEntry	ProfileDatabase.h	/^    DirectoryEntry* readDirectoryEntry(const std::string& key) const {$/;"	f	class:souffle::profile::DirectoryEntry
readEntry	ProfileDatabase.h	/^    Entry* readEntry(const std::string& key) const {$/;"	f	class:souffle::profile::DirectoryEntry
reader	profile/Tui.h	/^    std::shared_ptr<Reader> reader;$/;"	m	class:souffle::profile::Tui
reads	Interpreter.h	/^    std::map<std::string, std::atomic<size_t>> reads;$/;"	m	class:souffle::Interpreter
ready	profile/Relation.h	/^    bool ready = true;$/;"	m	class:souffle::profile::Relation
rebalance_or_split	BTree.h	/^        int rebalance_or_split(node** root, lock_type& root_lock, int idx, std::vector<node*>& locked_nodes) {$/;"	f	struct:souffle::detail::btree::node
record_definitions	AstTranslator.h	/^        record_definition_map record_definitions;$/;"	m	class:souffle::AstTranslator::ValueIndex
recursive	PrecedenceGraph.h	/^    bool recursive() const {$/;"	f	class:souffle::RelationScheduleStep
recursive	PrecedenceGraph.h	/^    bool recursive(const AstClause* clause) const {$/;"	f	class:souffle::RecursiveClauses
recursive	profile/Rule.h	/^    bool recursive = false;$/;"	m	class:souffle::profile::Rule
recursiveClauses	PrecedenceGraph.h	/^    std::set<const AstClause*> recursiveClauses;$/;"	m	class:souffle::RecursiveClauses
recursiveId	profile/Relation.h	/^    int recursiveId = 0;$/;"	m	class:souffle::profile::Relation
recursiveRelationCopyTimingProcessor	EventProcessor.h	/^} recursiveRelationCopyTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RecursiveRelationCopyTimingProcessor
recursiveRelationNumberProcessor	EventProcessor.h	/^} recursiveRelationNumberProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RecursiveRelationNumberProcessor
recursiveRelationTimingProcessor	EventProcessor.h	/^} recursiveRelationTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RecursiveRelationTimingProcessor
recursiveRuleNumberProcessor	EventProcessor.h	/^} recursiveRuleNumberProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RecursiveRuleNumberProcessor
recursiveRuleTimingProcessor	EventProcessor.h	/^} recursiveRuleTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RecursiveRuleTimingProcessor
recv	Mpi.h	/^inline void recv(R& data, Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(R& data, const int source, const int tag) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(T& data, const size_t length, Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(T& data, const size_t length, const int source, const int tag) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(const int source, const int tag) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(std::vector<R>& data, Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv(void* data, const int count, const MPI_Datatype type, const int source, const int tag,$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv<bool>(std::vector<bool>& data, Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
recv	Mpi.h	/^inline void recv<std::string>(std::vector<std::string>& data, Status& status) {$/;"	f	namespace:souffle::mpi::__anon64
reduceSubstitution	InlineRelationsTransformer.cpp	/^bool reduceSubstitution(std::vector<std::pair<AstArgument*, AstArgument*>>& sub) {$/;"	f	namespace:souffle
redundantRelations	PrecedenceGraph.h	/^    std::set<const AstRelation*> redundantRelations;$/;"	m	class:souffle::RedundantRelations
refLevel	RamOperation.h	/^    const size_t refLevel;$/;"	m	class:souffle::RamUnpackRecord
refPos	RamOperation.h	/^    const size_t refPos;$/;"	m	class:souffle::RamUnpackRecord
register	scanner.cc	/^    #define register$/;"	d	file:
registerEventProcessor	EventProcessor.h	/^    void registerEventProcessor(const std::string& keyword, EventProcessor* processor) {$/;"	f	class:souffle::profile::EventProcessorSingleton
registerFactory	SouffleInterface.h	/^    static inline void registerFactory(ProgramFactory* factory) {$/;"	f	class:souffle::ProgramFactory
registerReadStreamFactory	IOSystem.h	/^    void registerReadStreamFactory(const std::shared_ptr<ReadStreamFactory>& factory) {$/;"	f	class:souffle::IOSystem
registerWriteStreamFactory	IOSystem.h	/^    void registerWriteStreamFactory(const std::shared_ptr<WriteStreamFactory>& factory) {$/;"	f	class:souffle::IOSystem
registry	EventProcessor.h	/^    std::map<std::string, EventProcessor*> registry;$/;"	m	class:souffle::profile::EventProcessorSingleton
rel	profile/Tui.h	/^    void rel(size_t limit, bool showLimit = true) {$/;"	f	namespace:souffle::profile
relRul	profile/Tui.h	/^    void relRul(std::string str) {$/;"	f	namespace:souffle::profile
relation	CompiledSouffle.h	/^        const Relation* relation;$/;"	m	class:souffle::RelationWrapper::iterator_wrapper
relation	CompiledSouffle.h	/^    RelType& relation;$/;"	m	class:souffle::RelationWrapper
relation	IndexSetAnalysis.h	/^    const RamRelation& relation;  \/\/ relation$/;"	m	class:souffle::IndexSet
relation	InterpreterInterface.h	/^    InterpreterRelation& relation;$/;"	m	class:souffle::InterpreterRelInterface
relation	InterpreterRelation.h	/^        const InterpreterRelation* relation = nullptr;$/;"	m	class:souffle::InterpreterRelation::iterator
relation	RamRelation.h	/^    const RamRelation* relation;$/;"	m	class:souffle::RamRelationReference
relation	SouffleInterface.h	/^    const Relation& relation;$/;"	m	class:souffle::tuple
relation	SynthesiserRelation.h	/^    const RamRelation& relation;$/;"	m	class:souffle::SynthesiserRelation
relation	profile/Reader.h	/^    Relation& relation;$/;"	m	class:souffle::profile::__anon72::IterationVisitor
relation	profile/Reader.h	/^    Relation& relation;$/;"	m	class:souffle::profile::__anon72::IterationsVisitor
relation	profile/Reader.h	/^    Relation& relation;$/;"	m	class:souffle::profile::__anon72::NonRecursiveRulesVisitor
relation	profile/Reader.h	/^    Relation& relation;$/;"	m	class:souffle::profile::__anon72::RecursiveRulesVisitor
relationCounter	Interpreter.h	/^       size_t relationCounter = 0;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
relationIOTimingProcessor	EventProcessor.h	/^} relationIOTimingProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RelationIOTimingProcessor
relationMap	SouffleInterface.h	/^    std::map<std::string, Relation*> relationMap;$/;"	m	class:souffle::SouffleProgram
relationMap	profile/ProgramRun.h	/^    std::unordered_map<std::string, std::shared_ptr<Relation>> relationMap;$/;"	m	class:souffle::profile::ProgramRun
relationName	ReadStreamSQLite.h	/^    const std::string& relationName;$/;"	m	class:souffle::ReadStreamSQLite
relationName	WriteStreamSQLite.h	/^    const std::string& relationName;$/;"	m	class:souffle::WriteStreamSQLite
relationPool	Interpreter.h	/^       std::vector<RamRelation> relationPool;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
relationReadsProcessor	EventProcessor.h	/^} relationReadsProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::RelationReadsProcessor
relationRef	RamCondition.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamAbstractExistenceCheck
relationRef	RamCondition.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamEmptinessCheck
relationRef	RamExpression.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamElementAccess
relationRef	RamOperation.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamAggregate
relationRef	RamOperation.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamProject
relationRef	RamOperation.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamRelationSearch
relationRef	RamStatement.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamLogTimer
relationRef	RamStatement.h	/^    std::unique_ptr<RamRelationReference> relationRef;$/;"	m	class:souffle::RamRelationStatement
relationSchedule	PrecedenceGraph.h	/^    std::vector<RelationScheduleStep> relationSchedule;$/;"	m	class:souffle::RelationSchedule
relationSize	AstProgram.h	/^    size_t relationSize() const {$/;"	f	class:souffle::AstProgram
relationTable	profile/Tui.h	/^    Table relationTable;$/;"	m	class:souffle::profile::Tui
relationToScc	PrecedenceGraph.h	/^    std::map<const AstRelation*, size_t> relationToScc;$/;"	m	class:souffle::SCCGraph
relations	AstComponent.h	/^    std::vector<std::unique_ptr<AstRelation>> relations;$/;"	m	class:souffle::AstComponent
relations	AstProgram.h	/^    std::map<AstRelationIdentifier, std::unique_ptr<AstRelation>> relations;$/;"	m	class:souffle::AstProgram
relations	ComponentModel.cpp	/^    std::vector<std::unique_ptr<AstRelation>> relations;$/;"	m	struct:souffle::__anon73::ComponentContent	file:
relations	RamProgram.h	/^    std::map<std::string, std::unique_ptr<RamRelation>> relations;$/;"	m	class:souffle::RamProgram
removeClause	AstProgram.cpp	/^void AstProgram::removeClause(const AstClause* clause) {$/;"	f	class:souffle::AstProgram
removeClause	AstRelation.h	/^    bool removeClause(const AstClause* clause) {$/;"	f	class:souffle::AstRelation
removeComplexTermsInAtoms	ResolveAliasesTransformer.cpp	/^std::unique_ptr<AstClause> ResolveAliasesTransformer::removeComplexTermsInAtoms(const AstClause& clause) {$/;"	f	class:souffle::ResolveAliasesTransformer
removeEmptyRelationUses	AstTransforms.cpp	/^bool RemoveEmptyRelationsTransformer::removeEmptyRelationUses($/;"	f	class:souffle::RemoveEmptyRelationsTransformer
removeEmptyRelations	AstTransforms.cpp	/^bool RemoveEmptyRelationsTransformer::removeEmptyRelations(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RemoveEmptyRelationsTransformer
removeRelation	AstProgram.cpp	/^void AstProgram::removeRelation(const AstRelationIdentifier& name) {$/;"	f	class:souffle::AstProgram
removeRelationCopies	AstTransforms.cpp	/^bool RemoveRelationCopiesTransformer::removeRelationCopies(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RemoveRelationCopiesTransformer
removeTrivialEquality	ResolveAliasesTransformer.cpp	/^std::unique_ptr<AstClause> ResolveAliasesTransformer::removeTrivialEquality(const AstClause& clause) {$/;"	f	class:souffle::ResolveAliasesTransformer
renameVariables	InlineRelationsTransformer.cpp	/^void renameVariables(AstArgument* arg) {$/;"	f	namespace:souffle
reorderAdornment	MagicSet.cpp	/^std::vector<std::string> reorderAdornment($/;"	f	namespace:souffle
reorderAtoms	AstClause.cpp	/^void AstClause::reorderAtoms(const std::vector<unsigned int>& newOrder) {$/;"	f	class:souffle::AstClause
reorderClauseWithSips	ReorderLiteralsTransformer.cpp	/^bool reorderClauseWithSips(sips_t sipsFunction, AstClause* clause) {$/;"	f	namespace:souffle
reorderOrdering	MagicSet.cpp	/^std::vector<unsigned int> reorderOrdering(std::vector<unsigned int> order) {$/;"	f	namespace:souffle
replaceUnderscores	MagicSet.cpp	/^void replaceUnderscores(AstProgram* program) {$/;"	f	namespace:souffle
representation	RamRelation.h	/^    const RelationRepresentation representation;$/;"	m	class:souffle::RamRelation
reserveSize	gzfstream.h	/^    static constexpr unsigned int reserveSize = 16;$/;"	m	class:souffle::gzfstream::internal::gzfstreambuf
reserver	test/btree_multiset_test.cpp	/^struct reserver {$/;"	s	namespace:souffle::test	file:
reserver	test/btree_multiset_test.cpp	/^struct reserver<std::unordered_set<A, B, C, D>> {$/;"	s	namespace:souffle::test	file:
reserver	test/btree_set_test.cpp	/^struct reserver {$/;"	s	namespace:souffle::test	file:
reserver	test/btree_set_test.cpp	/^struct reserver<std::unordered_set<A, B, C, D>> {$/;"	s	namespace:souffle::test	file:
reset	SignalHandler.h	/^    void reset() {$/;"	f	class:souffle::SignalHandler
resetIterationNumber	Interpreter.h	/^    void resetIterationNumber() {$/;"	f	class:souffle::Interpreter
resetTimerInterval	ProfileEvent.h	/^        void resetTimerInterval(uint32_t interval = 10) {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
resetTimerInterval	ProfileEvent.h	/^    void resetTimerInterval(uint32_t interval = 1) {$/;"	f	class:souffle::ProfileEventSingleton
resolve	SymbolTable.h	/^    const std::string& resolve(const RamDomain index) const {$/;"	f	class:souffle::SymbolTable
resolveAliases	ResolveAliasesTransformer.cpp	/^std::unique_ptr<AstClause> ResolveAliasesTransformer::resolveAliases(const AstClause& clause) {$/;"	f	class:souffle::ResolveAliasesTransformer
resultLimit	profile/Tui.h	/^    size_t resultLimit = 20000;$/;"	m	class:souffle::profile::Tui
returnErrors	InterpreterContext.h	/^    std::vector<bool>* returnErrors = nullptr;$/;"	m	class:souffle::InterpreterContext
returnValues	InterpreterContext.h	/^    std::vector<RamDomain>* returnValues = nullptr;$/;"	m	class:souffle::InterpreterContext
rewind	SouffleInterface.h	/^    void rewind() {$/;"	f	class:souffle::tuple
rewriteScan	RamTransforms.cpp	/^std::unique_ptr<RamOperation> CreateIndicesTransformer::rewriteScan(const RamScan* scan) {$/;"	f	class:souffle::CreateIndicesTransformer
rhs	AstLiteral.h	/^    std::unique_ptr<AstArgument> rhs;$/;"	m	class:souffle::AstBinaryConstraint
rhs	RamCondition.h	/^    std::unique_ptr<RamCondition> rhs;$/;"	m	class:souffle::RamConjunction
rhs	RamCondition.h	/^    std::unique_ptr<RamExpression> rhs;$/;"	m	class:souffle::RamConstraint
rhs	ResolveAliasesTransformer.cpp	/^    std::unique_ptr<AstArgument> rhs;$/;"	m	class:souffle::__anon71::Equation	file:
root	BTree.h	/^    node* volatile root;$/;"	m	class:souffle::detail::btree
root	Brie.h	/^        Node* root;$/;"	m	struct:souffle::SparseArray::RootInfo
root	Brie.h	/^        Node* root;$/;"	m	struct:souffle::SparseArray::RootInfoSnapshot
root_lock	BTree.h	/^    lock_type root_lock;$/;"	m	class:souffle::detail::btree
rows	profile/Table.h	/^    std::vector<std::shared_ptr<Row>> rows;$/;"	m	class:souffle::profile::Table
rul	profile/Tui.h	/^    void rul(size_t limit, bool showLimit = true) {$/;"	f	namespace:souffle::profile
rule	profile/Reader.h	/^    Rule& rule;$/;"	m	class:souffle::profile::__anon72::AtomFrequenciesVisitor
rule	profile/Rule.h	/^    const std::string rule;$/;"	m	class:souffle::profile::Atom
ruleId	profile/Relation.h	/^    int ruleId = 0;$/;"	m	class:souffle::profile::Relation
ruleMap	profile/Relation.h	/^    std::unordered_map<std::string, std::shared_ptr<Rule>> ruleMap;$/;"	m	class:souffle::profile::Relation
ruleTable	profile/Tui.h	/^    Table ruleTable;$/;"	m	class:souffle::profile::Tui
rules	ExplainProvenanceSLD.h	/^    std::map<std::pair<std::string, size_t>, std::string> rules;$/;"	m	class:souffle::ExplainProvenanceSLD
rules	profile/Iteration.h	/^    std::unordered_map<std::string, std::shared_ptr<Rule>> rules;$/;"	m	class:souffle::profile::Iteration
run	AstIOTypeAnalysis.cpp	/^void IOType::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::IOType
run	AstProfileUse.cpp	/^void AstProfileUse::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstProfileUse
run	AstTypeAnalysis.cpp	/^void TypeAnalysis::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::TypeAnalysis
run	AstTypeEnvironmentAnalysis.cpp	/^void TypeEnvironmentAnalysis::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::TypeEnvironmentAnalysis
run	ComponentModel.cpp	/^void ComponentLookup::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ComponentLookup
run	IndexSetAnalysis.cpp	/^void IndexSetAnalysis::run(const RamTranslationUnit& translationUnit) {$/;"	f	class:souffle::IndexSetAnalysis
run	MagicSet.cpp	/^void Adornment::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::Adornment
run	PrecedenceGraph.cpp	/^void PrecedenceGraph::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::PrecedenceGraph
run	PrecedenceGraph.cpp	/^void RecursiveClauses::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RecursiveClauses
run	PrecedenceGraph.cpp	/^void RedundantRelations::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RedundantRelations
run	PrecedenceGraph.cpp	/^void RelationSchedule::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RelationSchedule
run	PrecedenceGraph.cpp	/^void SCCGraph::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::SCCGraph
run	PrecedenceGraph.cpp	/^void TopologicallySortedSCCGraph::run(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::TopologicallySortedSCCGraph
run	ProfileEvent.h	/^        void run() {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
run	RamConditionLevel.cpp	/^void RamConditionLevelAnalysis::run(const RamTranslationUnit& translationUnit) {$/;"	f	class:souffle::RamConditionLevelAnalysis
run	SouffleInterface.h	/^    virtual void run(size_t stratumIndex = -1) {}$/;"	f	class:souffle::SouffleProgram
run	profile/Reader.h	/^    std::shared_ptr<ProgramRun> run;$/;"	m	class:souffle::profile::Reader
runCommand	profile/Tui.h	/^    void runCommand(std::vector<std::string> c) {$/;"	f	class:souffle::profile::Tui
runProf	profile/Tui.h	/^    void runProf() {$/;"	f	class:souffle::profile::Tui
runtime	LogStatement.h	/^    static const std::string runtime() {$/;"	f	class:souffle::LogStatement
rvla	RamConditionLevel.h	/^    RamExpressionLevelAnalysis* rvla;$/;"	m	class:souffle::RamConditionLevelAnalysis
sameSet	UnionFind.h	/^    bool sameSet(parent_t x, parent_t y) {$/;"	f	class:souffle::DisjointSet
sameSet	UnionFind.h	/^    inline bool sameSet(SparseDomain x, SparseDomain y) {$/;"	f	class:souffle::SparseDisjointSet
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
scR	PrecedenceGraph.cpp	/^void SCCGraph::scR(const AstRelation* w, std::map<const AstRelation*, size_t>& preOrder, size_t& counter,$/;"	f	class:souffle::SCCGraph
scan	CompiledIndexUtils.h	/^    range<iterator> scan(const First&) const {$/;"	f	class:souffle::ram::index_utils::Indices
scan	CompiledIndexUtils.h	/^    range<iterator> scan(const Index&) const {$/;"	f	class:souffle::ram::index_utils::Indices
scan	CompiledRelation.h	/^    range<iterator> scan() const {$/;"	f	class:souffle::ram::detail::AutoRelation
scan	CompiledRelation.h	/^    range<iterator> scan() const {$/;"	f	class:souffle::ram::detail::GenericRelation
scan	CompiledRelation.h	/^    range<iterator> scan() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
scanIteratorIndex	Interpreter.h	/^       size_t scanIteratorIndex = 0;$/;"	m	class:souffle::LowLevelMachine::LVMGenerator
scanIteratorPool	Interpreter.h	/^    std::vector<std::pair<InterpreterRelation::iterator, InterpreterRelation::iterator>> scanIteratorPool;$/;"	m	class:souffle::LowLevelMachine
scanner_data	ParserDriver.h	/^struct scanner_data {$/;"	s	namespace:souffle
sccGraph	PrecedenceGraph.h	/^    SCCGraph* sccGraph = nullptr;$/;"	m	class:souffle::TopologicallySortedSCCGraph
sccOfIndex	PrecedenceGraph.h	/^    const size_t sccOfIndex(const size_t index) const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
sccOrder	PrecedenceGraph.h	/^    std::vector<size_t> sccOrder;$/;"	m	class:souffle::TopologicallySortedSCCGraph
sccToRelation	PrecedenceGraph.h	/^    std::vector<std::set<const AstRelation*>> sccToRelation;$/;"	m	class:souffle::SCCGraph
schedule	PrecedenceGraph.h	/^    const std::vector<RelationScheduleStep>& schedule() const {$/;"	f	class:souffle::RelationSchedule
scrollTree	Explain.h	/^    void scrollTree(int maxx, int maxy) {$/;"	f
sds	EquivalenceRelation.h	/^    mutable souffle::SparseDisjointSet<value_type> sds;$/;"	m	class:souffle::EquivalenceRelation
search	BTree.h	/^        btree<Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater>::search;$/;"	m	class:souffle::detail::btree
search	BTree.h	/^    const static SearchStrategy search;$/;"	m	class:souffle::detail::btree
search_strategy	BTree.h	/^struct search_strategy {};$/;"	s	namespace:souffle::detail
searches	IndexSetAnalysis.h	/^    SearchSet searches;           \/\/ set of search patterns on table$/;"	m	class:souffle::IndexSet
second	RamStatement.h	/^    std::unique_ptr<RamRelationReference> second;$/;"	m	class:souffle::RamSwap
sections	DebugReport.h	/^    std::vector<DebugReportSection> sections;$/;"	m	class:souffle::DebugReport
seen	TypeSystem.cpp	/^    mutable std::map<const Type*, R> seen;$/;"	m	class:souffle::__anon75::VisitOnceTypeVisitor	file:
selectStatement	ReadStreamSQLite.h	/^    sqlite3_stmt* selectStatement = nullptr;$/;"	m	class:souffle::ReadStreamSQLite
self_type	parser.hh	/^    typedef semantic_type self_type;$/;"	t	class:yy::parser::semantic_type
semantic_type	parser.hh	/^  class semantic_type$/;"	c	class:yy::parser
send	Mpi.h	/^inline void send(const S& data, const Status& status) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const S& data, const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const S& data, const std::set<int>& destinations, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const Status& status) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const T& data, const size_t length, const Status& status) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const T& data, const size_t length, const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const T& data, const size_t length, const std::set<int>& destinations, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const std::set<int>& destinations, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const std::vector<S>& data, const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send(const void* data, const int count, const MPI_Datatype type, const int destination,$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send<bool>(const std::vector<bool>& data, const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
send	Mpi.h	/^inline void send<std::string>(const std::vector<std::string>& data, const int destination, const int tag) {$/;"	f	namespace:souffle::mpi::__anon63
sep	Util.h	/^    std::string sep;$/;"	m	class:souffle::detail::joined_sequence
separateDBs	MagicSet.cpp	/^void separateDBs(AstProgram* program) {$/;"	f	namespace:souffle
seq_	parser.hh	/^      S seq_;$/;"	m	class:yy::parser::stack
set	Brie.h	/^    bool set(index_type i) {$/;"	f	class:souffle::SparseBitMap
set	Brie.h	/^    bool set(index_type i, op_context& ctxt) {$/;"	f	class:souffle::SparseBitMap
set	Global.h	/^    void set(const K& key) {$/;"	f	class:souffle::BaseTable
set	Global.h	/^    void set(const K& key, const V& value) {$/;"	f	class:souffle::BaseTable
set	IODirectives.h	/^    void set(const std::string& key, const std::string& value) {$/;"	f	class:souffle::IODirectives
set	InterpreterIndex.h	/^    index_set set;$/;"	m	class:souffle::InterpreterIndex
set	SignalHandler.h	/^    void set() {$/;"	f	class:souffle::SignalHandler
setAddress	Interpreter.h	/^       void setAddress(size_t addressLabel, size_t value) {$/;"	f	class:souffle::LowLevelMachine::LVMGenerator
setAggregatorLocation	AstTranslator.h	/^        void setAggregatorLocation(const AstAggregator& agg, const Location& loc) {$/;"	f	class:souffle::AstTranslator::ValueIndex
setAnterior	EquivalenceRelation.h	/^        inline void setAnterior(const value_type a) {$/;"	f	class:souffle::EquivalenceRelation::iterator
setArg	AstArgument.h	/^    void setArg(size_t idx, std::unique_ptr<AstArgument> arg) {$/;"	f	class:souffle::AstIntrinsicFunctor
setArgument	AstLiteral.h	/^    void setArgument(size_t idx, std::unique_ptr<AstArgument> newArg) {$/;"	f	class:souffle::AstAtom
setArguments	InterpreterContext.h	/^    void setArguments(const std::vector<RamDomain>& a) {$/;"	f	class:souffle::InterpreterContext
setClauseNum	AstClause.h	/^    void setClauseNum(size_t num) {$/;"	f	class:souffle::AstClause
setComponentType	AstComponent.h	/^    void setComponentType(std::unique_ptr<AstComponentType> other) {$/;"	f	class:souffle::AstComponent
setComponentType	AstComponent.h	/^    void setComponentType(std::unique_ptr<AstComponentType> type) {$/;"	f	class:souffle::AstComponentInit
setCopytime	profile/Iteration.h	/^    void setCopytime(std::chrono::microseconds copy_time) {$/;"	f	class:souffle::profile::Iteration
setDBFromFile	ProfileEvent.h	/^    void setDBFromFile(const std::string& filename) {$/;"	f	class:souffle::ProfileEventSingleton
setEndtime	profile/Iteration.h	/^    void setEndtime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Iteration
setEndtime	profile/ProgramRun.h	/^    inline void setEndtime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::ProgramRun
setEndtime	profile/Relation.h	/^    void setEndtime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Relation
setEndtime	profile/Rule.h	/^    void setEndtime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Rule
setExecutionPlan	AstClause.h	/^    void setExecutionPlan(std::unique_ptr<AstExecutionPlan> plan) {$/;"	f	class:souffle::AstClause
setFieldType	AstType.h	/^    void setFieldType(size_t idx, const AstTypeIdentifier& type) {$/;"	f	class:souffle::AstRecordType
setFileName	IODirectives.h	/^    void setFileName(const std::string& filename) {$/;"	f	class:souffle::IODirectives
setFixedExecutionPlan	AstClause.h	/^    void setFixedExecutionPlan(bool value = true) {$/;"	f	class:souffle::AstClause
setGenerated	AstClause.h	/^    void setGenerated(bool value = true) {$/;"	f	class:souffle::AstClause
setHead	AstClause.cpp	/^void AstClause::setHead(std::unique_ptr<AstAtom> h) {$/;"	f	class:souffle::AstClause
setIOType	IODirectives.h	/^    void setIOType(const std::string& type) {$/;"	f	class:souffle::IODirectives
setId	profile/Rule.h	/^    void setId(std::string id) {$/;"	f	class:souffle::profile::Rule
setInstanceName	AstComponent.h	/^    void setInstanceName(const std::string& name) {$/;"	f	class:souffle::AstComponentInit
setIterator	Brie.h	/^        void setIterator(const iter_type& iter) {$/;"	f	class:souffle::Trie::iterator_core
setIterator	Brie.h	/^        void setIterator(const store_iter_t& iter) {$/;"	f	class:souffle::Trie::iterator_core
setLoadtime	profile/Relation.h	/^    void setLoadtime(std::chrono::microseconds loadtime) {$/;"	f	class:souffle::profile::Relation
setLocator	profile/Iteration.h	/^    void setLocator(std::string locator) {$/;"	f	class:souffle::profile::Iteration
setLocator	profile/Relation.h	/^    void setLocator(std::string locator) {$/;"	f	class:souffle::profile::Relation
setLocator	profile/Rule.h	/^    void setLocator(std::string locator) {$/;"	f	class:souffle::profile::Rule
setMain	RamProgram.h	/^    void setMain(std::unique_ptr<RamStatement> stmt) {$/;"	f	class:souffle::RamProgram
setMsg	SignalHandler.h	/^    void setMsg(const char* m) {$/;"	f	class:souffle::SignalHandler
setName	AstArgument.h	/^    void setName(const std::string& n) {$/;"	f	class:souffle::AstUserDefinedFunctor
setName	AstArgument.h	/^    void setName(const std::string& name) {$/;"	f	class:souffle::AstVariable
setName	AstComponent.h	/^    void setName(const std::string& n) {$/;"	f	class:souffle::AstComponentType
setName	AstIO.h	/^    void setName(const AstRelationIdentifier& name) {$/;"	f	class:souffle::AstIO
setName	AstLiteral.h	/^    void setName(const AstRelationIdentifier& n) {$/;"	f	class:souffle::AstAtom
setName	AstRelation.h	/^    void setName(const AstRelationIdentifier& n) {$/;"	f	class:souffle::AstRelation
setName	AstType.h	/^    void setName(const AstTypeIdentifier& name) {$/;"	f	class:souffle::AstType
setNumTuples	profile/Iteration.h	/^    void setNumTuples(long numTuples) {$/;"	f	class:souffle::profile::Iteration
setNumTuples	profile/Relation.h	/^    void setNumTuples(long numTuples) {$/;"	f	class:souffle::profile::Relation
setNumTuples	profile/Rule.h	/^    void setNumTuples(long numTuples) {$/;"	f	class:souffle::profile::Rule
setOperation	RamStatement.h	/^    void setOperation(std::unique_ptr<RamOperation> nested) {$/;"	f	class:souffle::RamQuery
setOperator	AstLiteral.h	/^    void setOperator(BinaryConstraintOp op) {$/;"	f	class:souffle::AstBinaryConstraint
setOrderFor	AstClause.h	/^    void setOrderFor(int version, std::unique_ptr<AstExecutionOrder> plan) {$/;"	f	class:souffle::AstExecutionPlan
setOutputFile	ProfileEvent.h	/^    void setOutputFile(std::string filename) {$/;"	f	class:souffle::ProfileEventSingleton
setPostMaxRSS	profile/Relation.h	/^    void setPostMaxRSS(size_t maxRSS) {$/;"	f	class:souffle::profile::Relation
setPosterior	EquivalenceRelation.h	/^        inline void setPosterior(const value_type b) {$/;"	f	class:souffle::EquivalenceRelation::iterator
setPreMaxRSS	profile/Relation.h	/^    void setPreMaxRSS(size_t maxRSS) {$/;"	f	class:souffle::profile::Relation
setPrompt	profile/UserInputReader.h	/^    void setPrompt(std::string prompt) {$/;"	f	class:souffle::profile::InputReader
setQualifier	AstRelation.h	/^    void setQualifier(int q) {$/;"	f	class:souffle::AstRelation
setReady	profile/Relation.h	/^    void setReady(bool ready) {$/;"	f	class:souffle::profile::Relation
setRecordDefinition	AstTranslator.h	/^        void setRecordDefinition(const AstRecordInit& init, const Location& l) {$/;"	f	class:souffle::AstTranslator::ValueIndex
setRecordDefinition	AstTranslator.h	/^        void setRecordDefinition(const AstRecordInit& init, int ident, int pos,$/;"	f	class:souffle::AstTranslator::ValueIndex
setRecursive	profile/Rule.h	/^    void setRecursive(bool recursive) {$/;"	f	class:souffle::profile::Rule
setRelationMap	profile/ProgramRun.h	/^    inline void setRelationMap(std::unordered_map<std::string, std::shared_ptr<Relation>>& relationMap) {$/;"	f	class:souffle::profile::ProgramRun
setRelationName	IODirectives.h	/^    void setRelationName(const std::string& name) {$/;"	f	class:souffle::IODirectives
setRepresentation	AstRelation.h	/^    void setRepresentation(RelationRepresentation representation) {$/;"	f	class:souffle::AstRelation
setResultLimit	profile/Tui.h	/^    void setResultLimit(size_t limit) {$/;"	f	namespace:souffle::profile
setReturnErrors	InterpreterContext.h	/^    void setReturnErrors(std::vector<bool>& retErrs) {$/;"	f	class:souffle::InterpreterContext
setReturnValues	InterpreterContext.h	/^    void setReturnValues(std::vector<RamDomain>& retVals) {$/;"	f	class:souffle::InterpreterContext
setSavetime	profile/Relation.h	/^    void setSavetime(std::chrono::microseconds savetime) {$/;"	f	class:souffle::profile::Relation
setSize	ExplainTree.h	/^    void setSize(size_t s) {$/;"	f	class:souffle::TreeNode
setSrcLoc	AstNode.h	/^    void setSrcLoc(const SrcLocation& l) {$/;"	f	class:souffle::AstNode
setStarttime	profile/Iteration.h	/^    void setStarttime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Iteration
setStarttime	profile/ProgramRun.h	/^    inline void setStarttime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::ProgramRun
setStarttime	profile/Relation.h	/^    void setStarttime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Relation
setStarttime	profile/Rule.h	/^    void setStarttime(std::chrono::microseconds time) {$/;"	f	class:souffle::profile::Rule
setTargetExpression	AstArgument.h	/^    void setTargetExpression(std::unique_ptr<AstArgument> arg) {$/;"	f	class:souffle::AstAggregator
setTypeName	AstAttribute.h	/^    void setTypeName(const AstTypeIdentifier& name) {$/;"	f	class:souffle::AstAttribute
setTypeParameters	AstComponent.h	/^    void setTypeParameters(const std::vector<AstTypeIdentifier>& params) {$/;"	f	class:souffle::AstComponentType
setVariantType	AstType.h	/^    void setVariantType(size_t idx, const AstTypeIdentifier& type) {$/;"	f	class:souffle::AstUnionType
setVersion	profile/Rule.h	/^    void setVersion(int version) {$/;"	f	class:souffle::profile::Rule
set_debug_level	parser.cc	/^  parser::set_debug_level (debug_level_type l)$/;"	f	class:yy::parser
set_debug_stream	parser.cc	/^  parser::set_debug_stream (std::ostream& o)$/;"	f	class:yy::parser
set_meet_assign_op	Constraints.h	/^struct set_meet_assign_op {$/;"	s	namespace:souffle::detail
set_property_space	Constraints.h	/^struct set_property_space : public property_space<std::set<T>, detail::set_meet_assign_op<T>> {};$/;"	s	namespace:souffle
setupTabCompletion	profile/Tui.h	/^    void setupTabCompletion() {$/;"	f	namespace:souffle::profile
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
shortName	Global.h	/^    char shortName;        \/* The short name for this option where a non-character option means none will be$/;"	m	struct:souffle::MainOption
showFullText	profile/UserInputReader.h	/^    void showFullText(const std::string& text) {$/;"	f	class:souffle::profile::InputReader
size	AstClause.h	/^    std::size_t size() const {$/;"	f	class:souffle::AstExecutionOrder
size	BTree.h	/^    size_type size() const {$/;"	f	class:souffle::detail::btree
size	Brie.h	/^    std::size_t size() const {$/;"	f	class:souffle::SparseArray
size	Brie.h	/^    std::size_t size() const {$/;"	f	class:souffle::SparseBitMap
size	Brie.h	/^    std::size_t size() const {$/;"	f	class:souffle::Trie
size	CompiledIndexUtils.h	/^    enum { size = sizeof...(Columns) };$/;"	e	enum:souffle::ram::index::__anon17
size	CompiledIndexUtils.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::index_utils::DisjointSetIndex
size	CompiledIndexUtils.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::index_utils::TrieIndex
size	CompiledIndexUtils.h	/^    std::size_t size() const {$/;"	f	struct:souffle::ram::index_utils::DirectIndex
size	CompiledIndexUtils.h	/^    std::size_t size() const {$/;"	f	struct:souffle::ram::index_utils::IndirectIndex
size	CompiledRelation.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::detail::AutoRelation
size	CompiledRelation.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::detail::DirectIndexedRelation
size	CompiledRelation.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::detail::GenericRelation
size	CompiledRelation.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::detail::GenericRelationGroup
size	CompiledRelation.h	/^    std::size_t size() const {$/;"	f	class:souffle::ram::detail::SingleIndexRelation
size	CompiledSouffle.h	/^    std::size_t size() const {$/;"	f	class:souffle::t_nullaries
size	EquivalenceRelation.h	/^    size_t size() const {$/;"	f	class:souffle::EquivalenceRelation
size	ExplainTree.h	/^    uint32_t size = 0;$/;"	m	class:souffle::TreeNode
size	InterpreterIndex.h	/^    std::size_t size() const {$/;"	f	class:souffle::InterpreterIndexOrder
size	InterpreterRelation.h	/^    size_t size() const {$/;"	f	class:souffle::InterpreterRelation
size	Logger.h	/^    std::function<size_t()> size;$/;"	m	class:souffle::Logger
size	PiggyList.h	/^    inline size_t size() const {$/;"	f	class:souffle::PiggyList
size	PiggyList.h	/^    inline size_t size() const {$/;"	f	class:souffle::RandomInsertPiggyList
size	ProfileDatabase.h	/^    size_t size;  \/\/ size$/;"	m	class:souffle::profile::SizeEntry
size	SouffleInterface.h	/^    size_t size() const {$/;"	f	class:souffle::tuple
size	SymbolTable.h	/^    size_t size() const {$/;"	f	class:souffle::SymbolTable
size	Table.h	/^    std::size_t size() const {$/;"	f	class:souffle::Table
size	TypeSystem.h	/^    std::size_t size() const {$/;"	f	struct:souffle::TypeSet
size	UnionFind.h	/^    inline size_t size() {$/;"	f	class:souffle::DisjointSet
size	UnionFind.h	/^    inline std::size_t size() {$/;"	f	class:souffle::SparseDisjointSet
size	parser.hh	/^    enum { size = sizeof (union_type) };$/;"	e	enum:yy::parser::semantic_type::__anon7
size	profile/Iteration.h	/^    size_t size() const {$/;"	f	class:souffle::profile::Iteration
size	profile/Relation.h	/^    size_t size() const {$/;"	f	class:souffle::profile::Relation
size	profile/Rule.h	/^    long size() {$/;"	f	class:souffle::profile::Rule
size_type	parser.hh	/^      typedef typename S::size_type size_type;$/;"	t	class:yy::parser::stack
sl	PiggyList.h	/^    mutable SpinLock sl;$/;"	m	class:souffle::PiggyList
slice	parser.hh	/^        slice (const stack& stack, int range)$/;"	f	class:yy::parser::stack::slice
slice	parser.hh	/^      class slice$/;"	c	class:yy::parser::stack
slock	PiggyList.h	/^    mutable SpinLock slock;$/;"	m	class:souffle::RandomInsertPiggyList
snprintf	json11.h	/^#define snprintf /;"	d
solve	Constraints.h	/^    Assignment<Var> solve() const {$/;"	f	class:souffle::Problem
solve	Constraints.h	/^    Assignment<Var>& solve(Assignment<Var>& ass) const {$/;"	f	class:souffle::Problem
solve	IndexSetAnalysis.cpp	/^const MaxMatching::Matchings& MaxMatching::solve() {$/;"	f	class:souffle::MaxMatching
solve	IndexSetAnalysis.cpp	/^void IndexSet::solve() {$/;"	f	class:souffle::IndexSet
sort	profile/Table.h	/^    void sort(int col_num) {$/;"	f	class:souffle::profile::Table
sortColumn	profile/Tui.h	/^    int sortColumn = 0;$/;"	m	class:souffle::profile::Tui
souffle	AstAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstArgument.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstArgument.h	/^namespace souffle {$/;"	n
souffle	AstAttribute.h	/^namespace souffle {$/;"	n
souffle	AstClause.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstClause.h	/^namespace souffle {$/;"	n
souffle	AstComponent.h	/^namespace souffle {$/;"	n
souffle	AstComponentChecker.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstComponentChecker.h	/^namespace souffle {$/;"	n
souffle	AstConstraintAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstFunctorDeclaration.h	/^namespace souffle {$/;"	n
souffle	AstGroundAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstGroundAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstIO.h	/^namespace souffle {$/;"	n
souffle	AstIOTypeAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstIOTypeAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstLiteral.h	/^namespace souffle {$/;"	n
souffle	AstNode.h	/^namespace souffle {$/;"	n
souffle	AstParserUtils.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstParserUtils.h	/^namespace souffle {$/;"	n
souffle	AstPragma.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstPragma.h	/^namespace souffle {$/;"	n
souffle	AstProfileUse.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstProfileUse.h	/^namespace souffle {$/;"	n
souffle	AstProgram.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstProgram.h	/^namespace souffle {$/;"	n
souffle	AstRelation.h	/^namespace souffle {$/;"	n
souffle	AstRelationIdentifier.h	/^namespace souffle {$/;"	n
souffle	AstSemanticChecker.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstSemanticChecker.h	/^namespace souffle {$/;"	n
souffle	AstTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstTransformer.h	/^namespace souffle {$/;"	n
souffle	AstTransforms.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstTransforms.h	/^namespace souffle {$/;"	n
souffle	AstTranslationUnit.h	/^namespace souffle {$/;"	n
souffle	AstTranslator.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstTranslator.h	/^namespace souffle {$/;"	n
souffle	AstType.h	/^namespace souffle {$/;"	n
souffle	AstTypeAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstTypeAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstTypeEnvironmentAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstTypeEnvironmentAnalysis.h	/^namespace souffle {$/;"	n
souffle	AstTypes.h	/^namespace souffle {$/;"	n
souffle	AstUtils.cpp	/^namespace souffle {$/;"	n	file:
souffle	AstUtils.h	/^namespace souffle {$/;"	n
souffle	AstVisitor.h	/^namespace souffle {$/;"	n
souffle	BTree.h	/^namespace souffle {$/;"	n
souffle	BinaryConstraintOps.h	/^namespace souffle {$/;"	n
souffle	Brie.h	/^namespace souffle {$/;"	n
souffle	CompiledIndexUtils.h	/^namespace souffle {$/;"	n
souffle	CompiledOptions.h	/^namespace souffle {$/;"	n
souffle	CompiledRecord.h	/^namespace souffle {$/;"	n
souffle	CompiledRelation.h	/^namespace souffle {$/;"	n
souffle	CompiledSouffle.h	/^namespace souffle {$/;"	n
souffle	CompiledTuple.h	/^namespace souffle {$/;"	n
souffle	ComponentModel.cpp	/^namespace souffle {$/;"	n	file:
souffle	ComponentModel.h	/^namespace souffle {$/;"	n
souffle	Constraints.h	/^namespace souffle {$/;"	n
souffle	DebugReport.cpp	/^namespace souffle {$/;"	n	file:
souffle	DebugReport.h	/^namespace souffle {$/;"	n
souffle	EquivalenceRelation.h	/^namespace souffle {$/;"	n
souffle	ErrorReport.h	/^namespace souffle {$/;"	n
souffle	EventProcessor.h	/^namespace souffle {$/;"	n
souffle	Explain.h	/^namespace souffle {$/;"	n
souffle	ExplainProvenance.h	/^namespace souffle {$/;"	n
souffle	ExplainProvenanceSLD.h	/^namespace souffle {$/;"	n
souffle	ExplainTree.h	/^namespace souffle {$/;"	n
souffle	FunctorOps.h	/^namespace souffle {$/;"	n
souffle	Global.cpp	/^namespace souffle {$/;"	n	file:
souffle	Global.h	/^namespace souffle {$/;"	n
souffle	GraphUtils.h	/^namespace souffle {$/;"	n
souffle	IODirectives.h	/^namespace souffle {$/;"	n
souffle	IOSystem.h	/^namespace souffle {$/;"	n
souffle	IndexSetAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	IndexSetAnalysis.h	/^namespace souffle {$/;"	n
souffle	InlineRelationsTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	Interpreter.cpp	/^namespace souffle {$/;"	n	file:
souffle	Interpreter.h	/^namespace souffle {$/;"	n
souffle	InterpreterContext.h	/^namespace souffle {$/;"	n
souffle	InterpreterIndex.h	/^namespace souffle {$/;"	n
souffle	InterpreterInterface.h	/^namespace souffle {$/;"	n
souffle	InterpreterRecords.cpp	/^namespace souffle {$/;"	n	file:
souffle	InterpreterRecords.h	/^namespace souffle {$/;"	n
souffle	InterpreterRelation.h	/^namespace souffle {$/;"	n
souffle	IterUtils.h	/^namespace souffle {$/;"	n
souffle	LambdaBTree.h	/^namespace souffle {$/;"	n
souffle	LogStatement.h	/^namespace souffle {$/;"	n
souffle	Logger.h	/^namespace souffle {$/;"	n
souffle	MagicSet.cpp	/^namespace souffle {$/;"	n	file:
souffle	MagicSet.h	/^namespace souffle {$/;"	n
souffle	MinimiseProgramTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	Mpi.h	/^namespace souffle {$/;"	n
souffle	ParallelUtils.h	/^namespace souffle {$/;"	n
souffle	ParallelUtils.h	/^namespace souffle {$/;"	n	namespace:souffle
souffle	ParserDriver.cpp	/^namespace souffle {$/;"	n	file:
souffle	ParserDriver.h	/^namespace souffle {$/;"	n
souffle	PiggyList.h	/^namespace souffle {$/;"	n
souffle	PrecedenceGraph.cpp	/^namespace souffle {$/;"	n	file:
souffle	PrecedenceGraph.h	/^namespace souffle {$/;"	n
souffle	ProfileDatabase.h	/^namespace souffle {$/;"	n
souffle	ProfileEvent.h	/^namespace souffle {$/;"	n
souffle	ProvenanceTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamAnalysis.h	/^namespace souffle {$/;"	n
souffle	RamCondition.h	/^namespace souffle {$/;"	n
souffle	RamConditionLevel.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamConditionLevel.h	/^namespace souffle {$/;"	n
souffle	RamConstValue.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamConstValue.h	/^namespace souffle {$/;"	n
souffle	RamExistenceCheckAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamExistenceCheckAnalysis.h	/^namespace souffle {$/;"	n
souffle	RamExpression.h	/^namespace souffle {$/;"	n
souffle	RamExpressionLevel.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamExpressionLevel.h	/^namespace souffle {$/;"	n
souffle	RamIndexScanKeys.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamIndexScanKeys.h	/^namespace souffle {$/;"	n
souffle	RamNode.h	/^namespace souffle {$/;"	n
souffle	RamOperation.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamOperation.h	/^namespace souffle {$/;"	n
souffle	RamOperationDepth.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamOperationDepth.h	/^namespace souffle {$/;"	n
souffle	RamProgram.h	/^namespace souffle {$/;"	n
souffle	RamProvenanceExistenceCheckAnalysis.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamProvenanceExistenceCheckAnalysis.h	/^namespace souffle {$/;"	n
souffle	RamRelation.h	/^namespace souffle {$/;"	n
souffle	RamStatement.h	/^namespace souffle {$/;"	n
souffle	RamTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamTransformer.h	/^namespace souffle {$/;"	n
souffle	RamTransforms.cpp	/^namespace souffle {$/;"	n	file:
souffle	RamTransforms.h	/^namespace souffle {$/;"	n
souffle	RamTranslationUnit.h	/^namespace souffle {$/;"	n
souffle	RamTypes.h	/^namespace souffle {$/;"	n
souffle	RamVisitor.h	/^namespace souffle {$/;"	n
souffle	ReadStream.h	/^namespace souffle {$/;"	n
souffle	ReadStreamCSV.h	/^namespace souffle {$/;"	n
souffle	ReadStreamSQLite.h	/^namespace souffle {$/;"	n
souffle	RelationRepresentation.h	/^namespace souffle {$/;"	n
souffle	ReorderLiteralsTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	ResolveAliasesTransformer.cpp	/^namespace souffle {$/;"	n	file:
souffle	SignalHandler.h	/^namespace souffle {$/;"	n
souffle	SouffleInterface.h	/^namespace souffle {$/;"	n
souffle	SrcLocation.cpp	/^namespace souffle {$/;"	n	file:
souffle	SrcLocation.h	/^namespace souffle {$/;"	n
souffle	StringPool.h	/^namespace souffle {$/;"	n
souffle	SymbolTable.h	/^namespace souffle {$/;"	n
souffle	Synthesiser.cpp	/^namespace souffle {$/;"	n	file:
souffle	Synthesiser.h	/^namespace souffle {$/;"	n
souffle	SynthesiserRelation.cpp	/^namespace souffle {$/;"	n	file:
souffle	SynthesiserRelation.h	/^namespace souffle {$/;"	n
souffle	Table.h	/^namespace souffle {$/;"	n
souffle	TypeSystem.cpp	/^namespace souffle {$/;"	n	file:
souffle	TypeSystem.h	/^namespace souffle {$/;"	n
souffle	UnionFind.h	/^namespace souffle {$/;"	n
souffle	Util.h	/^namespace souffle {$/;"	n
souffle	WriteStream.h	/^namespace souffle {$/;"	n
souffle	WriteStreamCSV.h	/^namespace souffle {$/;"	n
souffle	WriteStreamSQLite.h	/^namespace souffle {$/;"	n
souffle	gzfstream.h	/^namespace souffle {$/;"	n
souffle	main.cpp	/^namespace souffle {$/;"	n	file:
souffle	parser.hh	/^    namespace souffle {$/;"	n
souffle	profile/Cell.h	/^namespace souffle {$/;"	n
souffle	profile/CellInterface.h	/^namespace souffle {$/;"	n
souffle	profile/Cli.h	/^namespace souffle {$/;"	n
souffle	profile/DataComparator.h	/^namespace souffle {$/;"	n
souffle	profile/HtmlGenerator.h	/^namespace souffle {$/;"	n
souffle	profile/Iteration.h	/^namespace souffle {$/;"	n
souffle	profile/OutputProcessor.h	/^namespace souffle {$/;"	n
souffle	profile/ProgramRun.h	/^namespace souffle {$/;"	n
souffle	profile/Reader.h	/^namespace souffle {$/;"	n
souffle	profile/Relation.h	/^namespace souffle {$/;"	n
souffle	profile/Row.h	/^namespace souffle {$/;"	n
souffle	profile/Rule.h	/^namespace souffle {$/;"	n
souffle	profile/StringUtils.h	/^namespace souffle {$/;"	n
souffle	profile/Table.h	/^namespace souffle {$/;"	n
souffle	profile/Tui.h	/^namespace souffle {$/;"	n
souffle	profile/UserInputReader.h	/^namespace souffle {$/;"	n
souffle	profile/htmlCssChartist.h	/^namespace souffle {$/;"	n
souffle	profile/htmlCssStyle.h	/^namespace souffle {$/;"	n
souffle	profile/htmlJsChartistMin.h	/^namespace souffle {$/;"	n
souffle	profile/htmlJsChartistPlugin.h	/^namespace souffle {$/;"	n
souffle	profile/htmlJsMain.h	/^namespace souffle {$/;"	n
souffle	profile/htmlJsTableSort.h	/^namespace souffle {$/;"	n
souffle	profile/htmlJsUtil.h	/^namespace souffle {$/;"	n
souffle	profile/htmlMain.h	/^namespace souffle {$/;"	n
souffle	souffle2bdd.cpp	/^namespace souffle {$/;"	n	file:
souffle	souffle2lb.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/ast_parser_utils_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/ast_program_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/ast_utils_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/binary_relation_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/btree_multiset_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/btree_set_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/compiled_index_utils_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/compiled_relation_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/compiled_tuple_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/constraints_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/eqrel_datastructure_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/graph_utils_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/mpi_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/parallel_utils_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/ram_executor_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/table_test.cpp	/^namespace souffle {$/;"	n	file:
souffle	test/type_system_test.cpp	/^namespace souffle {$/;"	n	file:
souffle2bdd_DEPENDENCIES	Makefile	/^souffle2bdd_DEPENDENCIES = libsouffle.la$/;"	m
souffle2bdd_LDADD	Makefile	/^souffle2bdd_LDADD = libsouffle.la$/;"	m
souffle2bdd_OBJECTS	Makefile	/^souffle2bdd_OBJECTS = $(am_souffle2bdd_OBJECTS)$/;"	m
souffle2bdd_SOURCES	Makefile	/^souffle2bdd_SOURCES = souffle2bdd.cpp$/;"	m
souffle2lb_DEPENDENCIES	Makefile	/^souffle2lb_DEPENDENCIES = libsouffle.la$/;"	m
souffle2lb_LDADD	Makefile	/^souffle2lb_LDADD = libsouffle.la$/;"	m
souffle2lb_OBJECTS	Makefile	/^souffle2lb_OBJECTS = $(am_souffle2lb_OBJECTS)$/;"	m
souffle2lb_SOURCES	Makefile	/^souffle2lb_SOURCES = souffle2lb.cpp$/;"	m
souffle_DEPENDENCIES	Makefile	/^souffle_DEPENDENCIES = libsouffle.la$/;"	m
souffle_LDADD	Makefile	/^souffle_LDADD = libsouffle.la$/;"	m
souffle_OBJECTS	Makefile	/^souffle_OBJECTS = $(am_souffle_OBJECTS) $(nodist_souffle_OBJECTS)$/;"	m
souffle_SOURCES	Makefile	/^souffle_SOURCES = main.cpp$/;"	m
souffle_profile_CXXFLAGS	Makefile	/^souffle_profile_CXXFLAGS = $(souffle_CPPFLAGS) -DMAKEDIR='"$(DIR)"'$/;"	m
souffle_profile_LDADD	Makefile	/^souffle_profile_LDADD = $(LDADD)$/;"	m
souffle_profile_LINK	Makefile	/^souffle_profile_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
souffle_profile_OBJECTS	Makefile	/^souffle_profile_OBJECTS = $(am_souffle_profile_OBJECTS) \\$/;"	m
souffle_profile_SOURCES	Makefile	/^souffle_profile_SOURCES = souffle_prof.cpp$/;"	m
souffle_profile_sources	Makefile	/^souffle_profile_sources = \\$/;"	m
souffle_sources	Makefile	/^souffle_sources = \\$/;"	m
souffleprofile_HEADERS	Makefile	/^souffleprofile_HEADERS = $(souffle_profile_sources)$/;"	m
souffleprofiledir	Makefile	/^souffleprofiledir = $(soufflepublicdir)\/profile$/;"	m
soufflepublic_HEADERS	Makefile	/^soufflepublic_HEADERS = \\$/;"	m
soufflepublicdir	Makefile	/^soufflepublicdir = $(includedir)\/souffle$/;"	m
sourceRef	RamStatement.h	/^    std::unique_ptr<RamRelationReference> sourceRef;$/;"	m	class:souffle::RamMerge
sourceStratum	RamStatement.h	/^    const int sourceStratum;$/;"	m	class:souffle::RamRecv
sparseToDenseMap	UnionFind.h	/^    SparseMap sparseToDenseMap;$/;"	m	class:souffle::SparseDisjointSet
split	BTree.h	/^        void split(node** root, lock_type& root_lock, int idx, std::vector<node*>& locked_nodes) {$/;"	f	struct:souffle::detail::btree::node
split	EventProcessor.h	/^    static std::vector<std::string> split(std::string str, std::string split_str) {$/;"	f	class:souffle::profile::EventProcessorSingleton
split	ExplainProvenance.h	/^inline std::vector<std::string> split(const std::string& s, char delim, int times = -1) {$/;"	f	namespace:souffle
split	profile/StringUtils.h	/^inline std::vector<std::string> split(std::string str, std::string split_str) {$/;"	f	namespace:souffle::profile::Tools
splitAtSemiColon	profile/StringUtils.h	/^inline std::vector<std::string> splitAtSemiColon(std::string str) {$/;"	f	namespace:souffle::profile::Tools
splitSignature	EventProcessor.h	/^    static std::vector<std::string> splitSignature(std::string str) {$/;"	f	class:souffle::profile::EventProcessorSingleton
sqlite_sources	Makefile	/^sqlite_sources = ReadStreamSQLite.h WriteStreamSQLite.h$/;"	m
src	CompiledOptions.h	/^    std::string src;$/;"	m	class:souffle::CmdOptions
srcdir	Makefile	/^srcdir = .$/;"	m
ss	profile/Tui.h	/^        ss << '}';$/;"	m	class:souffle::profile::Tui
stack	Interpreter.h	/^   std::stack<RamDomain> stack;$/;"	m	class:souffle::LowLevelMachine
stack	parser.hh	/^      stack (size_type n = 200)$/;"	f	class:yy::parser::stack
stack	parser.hh	/^    class stack$/;"	c	class:yy::parser
stack_	parser.hh	/^        const stack& stack_;$/;"	m	class:yy::parser::stack::slice
stack_symbol_type	parser.cc	/^  parser::stack_symbol_type::stack_symbol_type ()$/;"	f	class:yy::parser::stack_symbol_type
stack_symbol_type	parser.cc	/^  parser::stack_symbol_type::stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) that)$/;"	f	class:yy::parser::stack_symbol_type
stack_symbol_type	parser.hh	/^    struct stack_symbol_type : basic_symbol<by_state>$/;"	s	class:yy::parser
stack_type	parser.hh	/^    typedef stack<stack_symbol_type> stack_type;$/;"	t	class:yy::parser
start	Logger.h	/^    time_point start;$/;"	m	class:souffle::Logger
start	ProfileDatabase.h	/^    microseconds start;$/;"	m	class:souffle::profile::DurationEntry
start	ProfileEvent.h	/^        void start() {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
start	SrcLocation.h	/^    Point start = {};$/;"	m	class:souffle::SrcLocation
startDebug	LogStatement.h	/^    static const std::string startDebug() {$/;"	f	class:souffle::LogStatement
startMaxRSS	Logger.h	/^    size_t startMaxRSS;$/;"	m	class:souffle::Logger
startTimer	ProfileEvent.h	/^    void startTimer() {$/;"	f	class:souffle::ProfileEventSingleton
start_read	ParallelUtils.h	/^    Lease start_read() {$/;"	f	class:souffle::OptimisticReadWriteLock
start_read	ParallelUtils.h	/^    Lease start_read() {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
start_read	ParallelUtils.h	/^    void start_read() {$/;"	f	class:souffle::ReadWriteLock
start_read	ParallelUtils.h	/^    void start_read() {}$/;"	f	class:souffle::souffle::ReadWriteLock
start_write	ParallelUtils.h	/^    void start_write() {$/;"	f	class:souffle::OptimisticReadWriteLock
start_write	ParallelUtils.h	/^    void start_write() {$/;"	f	class:souffle::ReadWriteLock
start_write	ParallelUtils.h	/^    void start_write() {}$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
start_write	ParallelUtils.h	/^    void start_write() {}$/;"	f	class:souffle::souffle::ReadWriteLock
state	parser.cc	/^    : state (empty_state)$/;"	f	namespace:yy
state	parser.cc	/^    : state (s)$/;"	f	namespace:yy
state	parser.cc	/^    : state (that.state)$/;"	f	namespace:yy
state	parser.hh	/^      state_type state;$/;"	m	struct:yy::parser::by_state
state_type	parser.hh	/^    typedef int state_type;$/;"	t	class:yy::parser
statement	RamStatement.h	/^    std::unique_ptr<RamStatement> statement;$/;"	m	class:souffle::RamDebugInfo
statement	RamStatement.h	/^    std::unique_ptr<RamStatement> statement;$/;"	m	class:souffle::RamLogTimer
statements	RamStatement.h	/^    std::vector<std::unique_ptr<RamStatement>> statements;$/;"	m	class:souffle::RamParallel
statements	RamStatement.h	/^    std::vector<std::unique_ptr<RamStatement>> statements;$/;"	m	class:souffle::RamSequence
statesLock	EquivalenceRelation.h	/^    mutable souffle::shared_mutex statesLock;$/;"	m	class:souffle::EquivalenceRelation
statesMapStale	EquivalenceRelation.h	/^    mutable std::atomic<bool> statesMapStale;$/;"	m	class:souffle::EquivalenceRelation
static_null	json11.h	/^static const Json& static_null() {$/;"	f	namespace:json11
statics	json11.h	/^static const Statics& statics() {$/;"	f	namespace:json11
std	CompiledTuple.h	/^namespace std {$/;"	n
std	Util.h	/^namespace std {$/;"	n
std	test/btree_multiset_test.cpp	/^namespace std {$/;"	n	file:
std	test/btree_set_test.cpp	/^namespace std {$/;"	n	file:
std_set_config	CompiledRelation.h	/^struct std_set_config {$/;"	s	namespace:souffle::ram::detail
std_unordered_config	CompiledRelation.h	/^struct std_unordered_config {$/;"	s	namespace:souffle::ram::detail
stop	ProfileEvent.h	/^        void stop() {$/;"	f	class:souffle::ProfileEventSingleton::ProfileTimer
stopTimer	ProfileEvent.h	/^    void stopTimer() {$/;"	f	class:souffle::ProfileEventSingleton
stord	Util.h	/^#define stord(/;"	d
store	Brie.h	/^    data_store_t store;$/;"	m	class:souffle::SparseBitMap
stores	AstComponent.h	/^    std::vector<std::unique_ptr<AstStore>> stores;$/;"	m	class:souffle::AstComponent
stores	AstProgram.h	/^    std::vector<std::unique_ptr<AstStore>> stores;$/;"	m	class:souffle::AstProgram
stores	AstRelation.h	/^    std::vector<std::unique_ptr<AstStore>> stores;$/;"	m	class:souffle::AstRelation
stores	ComponentModel.cpp	/^    std::vector<std::unique_ptr<AstStore>> stores;$/;"	m	struct:souffle::__anon73::ComponentContent	file:
str	StringPool.h	/^        char* str;$/;"	m	struct:souffle::StringPool::hashentry
str	json11.h	/^    const string& str;$/;"	m	struct:json11::__anon66::final
strToNum	SymbolTable.h	/^    std::unordered_map<std::string, size_t> strToNum;$/;"	m	class:souffle::SymbolTable
strToNumCache	SymbolTable.h	/^    mutable std::unordered_map<std::string, size_t> strToNumCache;$/;"	m	class:souffle::SymbolTable
strategy	json11.h	/^    const JsonParse strategy;$/;"	m	struct:json11::__anon66::final
strategy_selection	BTree.h	/^struct strategy_selection {$/;"	s	namespace:souffle::detail
stratumIndex	CompiledOptions.h	/^    size_t stratumIndex;$/;"	m	class:souffle::CmdOptions
streams	Util.h	/^    std::vector<std::ostream*> streams;$/;"	m	class:souffle::SplitStream
string_value	json11.h	/^inline const string& Json::string_value() const {$/;"	f	class:json11::Json
string_value	json11.h	/^inline const string& JsonValue::string_value() const {$/;"	f	class:json11::JsonValue
stripWhitespace	profile/StringUtils.h	/^inline std::string stripWhitespace(std::string val) {$/;"	f	namespace:souffle::profile::Tools
sub	Constraints.h	/^std::shared_ptr<Constraint<Var>> sub(const Val& a, const Var& b, const std::string& symbol = "") {$/;"	f	namespace:souffle
sub	Constraints.h	/^std::shared_ptr<Constraint<Var>> sub(const Var& a, const Var& b, const std::string& symbol = "") {$/;"	f	namespace:souffle
sub_type	AstTypeAnalysis.cpp	/^struct sub_type {$/;"	s	namespace:souffle::__anon77	file:
subdir	Makefile	/^subdir = src$/;"	m
subproofs	ExplainProvenanceSLD.h	/^    std::vector<std::vector<RamDomain>> subproofs;$/;"	m	class:souffle::ExplainProvenanceSLD
subroutines	RamProgram.h	/^    std::map<std::string, std::unique_ptr<RamStatement>> subroutines;$/;"	m	class:souffle::RamProgram
subsections	DebugReport.h	/^    std::vector<DebugReportSection> subsections;$/;"	m	class:souffle::DebugReportSection
success	test/test.h	/^        bool success;$/;"	m	struct:TestCase::test_result
successors	GraphUtils.h	/^    const std::set<Vertex, Compare>& successors(const Vertex& from) const {$/;"	f	class:souffle::Graph
successors	PrecedenceGraph.h	/^    std::vector<std::set<size_t>> successors;$/;"	m	class:souffle::SCCGraph
sum	AstArgument.h	/^    enum Op { min, max, count, sum };$/;"	e	enum:souffle::AstAggregator::Op
summary	WriteStream.h	/^    const bool summary;$/;"	m	class:souffle::WriteStream
super_type	parser.hh	/^      typedef Base super_type;$/;"	t	struct:yy::parser::basic_symbol
super_type	parser.hh	/^      typedef basic_symbol<by_state> super_type;$/;"	t	struct:yy::parser::stack_symbol_type
super_type	parser.hh	/^      typedef basic_symbol<by_type> super_type;$/;"	t	struct:yy::parser::symbol_type
swap	BTree.h	/^    void swap(btree& other) {$/;"	f	class:souffle::detail::btree
swap	LambdaBTree.h	/^    void swap(LambdaBTree& other) {$/;"	f	class:souffle::detail::LambdaBTree
swap	TypeSystem.h	/^    void swap(TypeEnvironment& env) {$/;"	f	class:souffle::TypeEnvironment
swapRelation	Interpreter.h	/^    void swapRelation(const RamRelation& ramRel1, const RamRelation& ramRel2) {$/;"	f	class:souffle::Interpreter
swapRelation	Interpreter.h	/^    void swapRelation(const std::string& ramRel1, const std::string& ramRel2) {$/;"	f	class:souffle::LowLevelMachine
symTable	AstArgument.h	/^    SymbolTable& symTable;$/;"	m	class:souffle::AstStringConstant
symTable	CompiledSouffle.h	/^    SymbolTable& symTable;$/;"	m	class:souffle::RelationWrapper
symTable	InterpreterInterface.h	/^    SymbolTable& symTable;$/;"	m	class:souffle::InterpreterProgInterface
symTable	InterpreterInterface.h	/^    SymbolTable& symTable;$/;"	m	class:souffle::InterpreterRelInterface
symbolInsertStatement	WriteStreamSQLite.h	/^    sqlite3_stmt* symbolInsertStatement = nullptr;$/;"	m	class:souffle::WriteStreamSQLite
symbolMask	ReadStream.h	/^    const std::vector<bool>& symbolMask;$/;"	m	class:souffle::ReadStream
symbolMask	WriteStream.h	/^    const std::vector<bool>& symbolMask;$/;"	m	class:souffle::WriteStream
symbolSelectStatement	WriteStreamSQLite.h	/^    sqlite3_stmt* symbolSelectStatement = nullptr;$/;"	m	class:souffle::WriteStreamSQLite
symbolTable	AstTranslationUnit.h	/^    SymbolTable& symbolTable;$/;"	m	class:souffle::AstTranslationUnit
symbolTable	Interpreter.h	/^       SymbolTable& symbolTable;                \/** Class for converting string to number and vice versa *\/ $/;"	m	class:souffle::LowLevelMachine::LVMGenerator
symbolTable	RamTranslationUnit.h	/^    souffle::SymbolTable& symbolTable;$/;"	m	class:souffle::RamTranslationUnit
symbolTable	ReadStream.h	/^    SymbolTable& symbolTable;$/;"	m	class:souffle::ReadStream
symbolTable	WriteStream.h	/^    const SymbolTable& symbolTable;$/;"	m	class:souffle::WriteStream
symbolTableName	WriteStreamSQLite.h	/^    const std::string symbolTableName = "__SymbolTable";$/;"	m	class:souffle::WriteStreamSQLite
symbol_number_type	parser.hh	/^    typedef int symbol_number_type;$/;"	t	class:yy::parser
symbol_type	parser.hh	/^      symbol_type () {}$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, AstDomain v, location_type l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, const AstDomain& v, const location_type& l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, const location_type& l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, const std::string& v, const location_type& l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, location_type l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^      symbol_type (int tok, std::string v, location_type l)$/;"	f	struct:yy::parser::symbol_type
symbol_type	parser.hh	/^    struct symbol_type : basic_symbol<by_type>$/;"	s	class:yy::parser
synced	Brie.h	/^        volatile RootInfo synced;  \/\/ for synchronized operations$/;"	m	union:souffle::SparseArray::__anon3
syntax_error	parser.hh	/^      syntax_error (const location_type& l, const std::string& m)$/;"	f	struct:yy::parser::syntax_error
syntax_error	parser.hh	/^      syntax_error (const syntax_error& s)$/;"	f	struct:yy::parser::syntax_error
syntax_error	parser.hh	/^    struct syntax_error : std::runtime_error$/;"	s	class:yy::parser
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
systemtime	profile/Tui.h	/^        std::chrono::microseconds systemtime;$/;"	m	struct:souffle::profile::Tui::Usage
t	CompiledSouffle.h	/^        tuple t;$/;"	m	class:souffle::RelationWrapper::iterator_wrapper
t	ProfileEvent.h	/^        uint32_t t;$/;"	m	class:souffle::ProfileEventSingleton::ProfileTimer
t	json11.h	/^    const std::shared_ptr<JsonValue> t = make_shared<JsonBoolean>(true);$/;"	m	struct:json11::Statics
tNonrecursiveRelation	LogStatement.h	/^    static const std::string tNonrecursiveRelation($/;"	f	class:souffle::LogStatement
tNonrecursiveRule	LogStatement.h	/^    static const std::string tNonrecursiveRule($/;"	f	class:souffle::LogStatement
tRecursiveRelation	LogStatement.h	/^    static const std::string tRecursiveRelation($/;"	f	class:souffle::LogStatement
tRecursiveRule	LogStatement.h	/^    static const std::string tRecursiveRule(const std::string& relationName, const int version,$/;"	f	class:souffle::LogStatement
tRelationLoadTime	LogStatement.h	/^    static const std::string tRelationLoadTime($/;"	f	class:souffle::LogStatement
tRelationSaveTime	LogStatement.h	/^    static const std::string tRelationSaveTime($/;"	f	class:souffle::LogStatement
t_nullaries	CompiledSouffle.h	/^class t_nullaries {$/;"	c	namespace:souffle
tabComplete	profile/UserInputReader.h	/^    void tabComplete() {$/;"	f	class:souffle::profile::InputReader
tab_completion	profile/UserInputReader.h	/^    std::vector<std::string> tab_completion;$/;"	m	class:souffle::profile::InputReader
tab_pos	profile/UserInputReader.h	/^    size_t tab_pos = 0;$/;"	m	class:souffle::profile::InputReader
tail	Table.h	/^    Block* tail;$/;"	m	class:souffle::Table
takesMany	Global.h	/^    bool takesMany; \/* Whether this option takes many arguments, false for 'it takes only one' true for 'it$/;"	m	struct:souffle::MainOption
target	Makefile	/^target = x86_64-apple-darwin18.5.0$/;"	m
targetRef	RamStatement.h	/^    std::unique_ptr<RamRelationReference> targetRef;$/;"	m	class:souffle::RamMerge
target_alias	Makefile	/^target_alias = $/;"	m
target_cpu	Makefile	/^target_cpu = x86_64$/;"	m
target_os	Makefile	/^target_os = darwin18.5.0$/;"	m
target_triplet	Makefile	/^target_triplet = x86_64-apple-darwin18.5.0$/;"	m
target_vendor	Makefile	/^target_vendor = apple$/;"	m
task_spawn	ParallelUtils.h	/^#define task_spawn /;"	d
task_spawn	ParallelUtils.h	/^#define task_spawn$/;"	d
task_sync	ParallelUtils.h	/^#define task_sync /;"	d
task_sync	ParallelUtils.h	/^#define task_sync$/;"	d
test	Brie.h	/^    bool test(index_type i) const {$/;"	f	class:souffle::SparseBitMap
test	Brie.h	/^    bool test(index_type i, op_context& ctxt) const {$/;"	f	class:souffle::SparseBitMap
test	test/ast_parser_utils_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/ast_program_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/ast_utils_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/binary_relation_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/btree_multiset_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/btree_set_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/constraints_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/eqrel_datastructure_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/graph_utils_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/mpi_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/parallel_utils_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/ram_executor_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/ram_relation_stats_test.cpp	/^namespace test {$/;"	n	file:
test	test/symbol_table_test.cpp	/^namespace test {$/;"	n	file:
test	test/table_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test	test/test.h	/^    std::string test;   \/\/ test name of test$/;"	m	class:TestCase
test	test/type_system_test.cpp	/^namespace test {$/;"	n	namespace:souffle	file:
test_ast_parser_utils_test_CXXFLAGS	Makefile	/^test_ast_parser_utils_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_ast_parser_utils_test_DEPENDENCIES	Makefile	/^test_ast_parser_utils_test_DEPENDENCIES = libsouffle.la$/;"	m
test_ast_parser_utils_test_LDADD	Makefile	/^test_ast_parser_utils_test_LDADD = libsouffle.la$/;"	m
test_ast_parser_utils_test_LINK	Makefile	/^test_ast_parser_utils_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_ast_parser_utils_test_OBJECTS	Makefile	/^test_ast_parser_utils_test_OBJECTS =  \\$/;"	m
test_ast_parser_utils_test_SOURCES	Makefile	/^test_ast_parser_utils_test_SOURCES = test\/ast_parser_utils_test.cpp$/;"	m
test_ast_program_test_CXXFLAGS	Makefile	/^test_ast_program_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_ast_program_test_DEPENDENCIES	Makefile	/^test_ast_program_test_DEPENDENCIES = libsouffle.la$/;"	m
test_ast_program_test_LDADD	Makefile	/^test_ast_program_test_LDADD = libsouffle.la$/;"	m
test_ast_program_test_LINK	Makefile	/^test_ast_program_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_ast_program_test_OBJECTS	Makefile	/^test_ast_program_test_OBJECTS = $(am_test_ast_program_test_OBJECTS)$/;"	m
test_ast_program_test_SOURCES	Makefile	/^test_ast_program_test_SOURCES = test\/ast_program_test.cpp$/;"	m
test_ast_utils_test_CXXFLAGS	Makefile	/^test_ast_utils_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_ast_utils_test_DEPENDENCIES	Makefile	/^test_ast_utils_test_DEPENDENCIES = libsouffle.la$/;"	m
test_ast_utils_test_LDADD	Makefile	/^test_ast_utils_test_LDADD = libsouffle.la$/;"	m
test_ast_utils_test_LINK	Makefile	/^test_ast_utils_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_ast_utils_test_OBJECTS	Makefile	/^test_ast_utils_test_OBJECTS = $(am_test_ast_utils_test_OBJECTS)$/;"	m
test_ast_utils_test_SOURCES	Makefile	/^test_ast_utils_test_SOURCES = test\/ast_utils_test.cpp$/;"	m
test_binary_relation_test_CXXFLAGS	Makefile	/^test_binary_relation_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_binary_relation_test_DEPENDENCIES	Makefile	/^test_binary_relation_test_DEPENDENCIES = libsouffle.la$/;"	m
test_binary_relation_test_LDADD	Makefile	/^test_binary_relation_test_LDADD = libsouffle.la$/;"	m
test_binary_relation_test_LINK	Makefile	/^test_binary_relation_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_binary_relation_test_OBJECTS	Makefile	/^test_binary_relation_test_OBJECTS =  \\$/;"	m
test_binary_relation_test_SOURCES	Makefile	/^test_binary_relation_test_SOURCES = test\/binary_relation_test.cpp$/;"	m
test_brie_test_CXXFLAGS	Makefile	/^test_brie_test_CXXFLAGS = $(souffle_bin_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test -DBUILDDIR='"\/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/"'$/;"	m
test_brie_test_DEPENDENCIES	Makefile	/^test_brie_test_DEPENDENCIES = libsouffle.la$/;"	m
test_brie_test_LDADD	Makefile	/^test_brie_test_LDADD = libsouffle.la$/;"	m
test_brie_test_LINK	Makefile	/^test_brie_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_brie_test_OBJECTS	Makefile	/^test_brie_test_OBJECTS = $(am_test_brie_test_OBJECTS)$/;"	m
test_brie_test_SOURCES	Makefile	/^test_brie_test_SOURCES = test\/brie_test.cpp$/;"	m
test_btree_multiset_test_CXXFLAGS	Makefile	/^test_btree_multiset_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_btree_multiset_test_DEPENDENCIES	Makefile	/^test_btree_multiset_test_DEPENDENCIES = libsouffle.la$/;"	m
test_btree_multiset_test_LDADD	Makefile	/^test_btree_multiset_test_LDADD = libsouffle.la$/;"	m
test_btree_multiset_test_LINK	Makefile	/^test_btree_multiset_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_btree_multiset_test_OBJECTS	Makefile	/^test_btree_multiset_test_OBJECTS =  \\$/;"	m
test_btree_multiset_test_SOURCES	Makefile	/^test_btree_multiset_test_SOURCES = test\/btree_multiset_test.cpp$/;"	m
test_btree_set_test_CXXFLAGS	Makefile	/^test_btree_set_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_btree_set_test_DEPENDENCIES	Makefile	/^test_btree_set_test_DEPENDENCIES = libsouffle.la$/;"	m
test_btree_set_test_LDADD	Makefile	/^test_btree_set_test_LDADD = libsouffle.la$/;"	m
test_btree_set_test_LINK	Makefile	/^test_btree_set_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_btree_set_test_OBJECTS	Makefile	/^test_btree_set_test_OBJECTS = $(am_test_btree_set_test_OBJECTS)$/;"	m
test_btree_set_test_SOURCES	Makefile	/^test_btree_set_test_SOURCES = test\/btree_set_test.cpp$/;"	m
test_compiled_index_utils_test_CXXFLAGS	Makefile	/^test_compiled_index_utils_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_compiled_index_utils_test_DEPENDENCIES	Makefile	/^test_compiled_index_utils_test_DEPENDENCIES = libsouffle.la$/;"	m
test_compiled_index_utils_test_LDADD	Makefile	/^test_compiled_index_utils_test_LDADD = libsouffle.la$/;"	m
test_compiled_index_utils_test_LINK	Makefile	/^test_compiled_index_utils_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_compiled_index_utils_test_OBJECTS	Makefile	/^test_compiled_index_utils_test_OBJECTS =  \\$/;"	m
test_compiled_index_utils_test_SOURCES	Makefile	/^test_compiled_index_utils_test_SOURCES = test\/compiled_index_utils_test.cpp$/;"	m
test_compiled_relation_test_CXXFLAGS	Makefile	/^test_compiled_relation_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_compiled_relation_test_DEPENDENCIES	Makefile	/^test_compiled_relation_test_DEPENDENCIES = libsouffle.la$/;"	m
test_compiled_relation_test_LDADD	Makefile	/^test_compiled_relation_test_LDADD = libsouffle.la$/;"	m
test_compiled_relation_test_LINK	Makefile	/^test_compiled_relation_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_compiled_relation_test_OBJECTS	Makefile	/^test_compiled_relation_test_OBJECTS =  \\$/;"	m
test_compiled_relation_test_SOURCES	Makefile	/^test_compiled_relation_test_SOURCES = test\/compiled_relation_test.cpp$/;"	m
test_compiled_tuple_test_CXXFLAGS	Makefile	/^test_compiled_tuple_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_compiled_tuple_test_DEPENDENCIES	Makefile	/^test_compiled_tuple_test_DEPENDENCIES = libsouffle.la$/;"	m
test_compiled_tuple_test_LDADD	Makefile	/^test_compiled_tuple_test_LDADD = libsouffle.la$/;"	m
test_compiled_tuple_test_LINK	Makefile	/^test_compiled_tuple_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_compiled_tuple_test_OBJECTS	Makefile	/^test_compiled_tuple_test_OBJECTS =  \\$/;"	m
test_compiled_tuple_test_SOURCES	Makefile	/^test_compiled_tuple_test_SOURCES = test\/compiled_tuple_test.cpp$/;"	m
test_constraints_test_CXXFLAGS	Makefile	/^test_constraints_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_constraints_test_DEPENDENCIES	Makefile	/^test_constraints_test_DEPENDENCIES = libsouffle.la$/;"	m
test_constraints_test_LDADD	Makefile	/^test_constraints_test_LDADD = libsouffle.la$/;"	m
test_constraints_test_LINK	Makefile	/^test_constraints_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_constraints_test_OBJECTS	Makefile	/^test_constraints_test_OBJECTS = $(am_test_constraints_test_OBJECTS)$/;"	m
test_constraints_test_SOURCES	Makefile	/^test_constraints_test_SOURCES = test\/constraints_test.cpp$/;"	m
test_eqrel_datastructure_test_CXXFLAGS	Makefile	/^test_eqrel_datastructure_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_eqrel_datastructure_test_DEPENDENCIES	Makefile	/^test_eqrel_datastructure_test_DEPENDENCIES = libsouffle.la$/;"	m
test_eqrel_datastructure_test_LDADD	Makefile	/^test_eqrel_datastructure_test_LDADD = libsouffle.la$/;"	m
test_eqrel_datastructure_test_LINK	Makefile	/^test_eqrel_datastructure_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_eqrel_datastructure_test_OBJECTS	Makefile	/^test_eqrel_datastructure_test_OBJECTS =  \\$/;"	m
test_eqrel_datastructure_test_SOURCES	Makefile	/^test_eqrel_datastructure_test_SOURCES = test\/eqrel_datastructure_test.cpp$/;"	m
test_graph_utils_test_CXXFLAGS	Makefile	/^test_graph_utils_test_CXXFLAGS = $(souffle_bin_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test -DBUILDDIR='"\/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/"'$/;"	m
test_graph_utils_test_DEPENDENCIES	Makefile	/^test_graph_utils_test_DEPENDENCIES = libsouffle.la$/;"	m
test_graph_utils_test_LDADD	Makefile	/^test_graph_utils_test_LDADD = libsouffle.la$/;"	m
test_graph_utils_test_LINK	Makefile	/^test_graph_utils_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_graph_utils_test_OBJECTS	Makefile	/^test_graph_utils_test_OBJECTS = $(am_test_graph_utils_test_OBJECTS)$/;"	m
test_graph_utils_test_SOURCES	Makefile	/^test_graph_utils_test_SOURCES = test\/graph_utils_test.cpp$/;"	m
test_matching_test_CXXFLAGS	Makefile	/^test_matching_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_matching_test_DEPENDENCIES	Makefile	/^test_matching_test_DEPENDENCIES = libsouffle.la$/;"	m
test_matching_test_LDADD	Makefile	/^test_matching_test_LDADD = libsouffle.la$/;"	m
test_matching_test_LINK	Makefile	/^test_matching_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_matching_test_OBJECTS	Makefile	/^test_matching_test_OBJECTS = $(am_test_matching_test_OBJECTS)$/;"	m
test_matching_test_SOURCES	Makefile	/^test_matching_test_SOURCES = test\/matching_test.cpp$/;"	m
test_mpi_test_LINK	Makefile	/^test_mpi_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_mpi_test_OBJECTS	Makefile	/^test_mpi_test_OBJECTS = $(am_test_mpi_test_OBJECTS)$/;"	m
test_parallel_utils_test_CXXFLAGS	Makefile	/^test_parallel_utils_test_CXXFLAGS = $(souffle_bin_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test -DBUILDDIR='"\/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/"'$/;"	m
test_parallel_utils_test_DEPENDENCIES	Makefile	/^test_parallel_utils_test_DEPENDENCIES = libsouffle.la$/;"	m
test_parallel_utils_test_LDADD	Makefile	/^test_parallel_utils_test_LDADD = libsouffle.la$/;"	m
test_parallel_utils_test_LINK	Makefile	/^test_parallel_utils_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_parallel_utils_test_OBJECTS	Makefile	/^test_parallel_utils_test_OBJECTS =  \\$/;"	m
test_parallel_utils_test_SOURCES	Makefile	/^test_parallel_utils_test_SOURCES = test\/parallel_utils_test.cpp$/;"	m
test_result	test/test.h	/^        test_result(bool success, std::ostream& out) : success(success), out(out) {}$/;"	f	struct:TestCase::test_result
test_result	test/test.h	/^    struct test_result {$/;"	s	class:TestCase
test_symbol_table_test_CXXFLAGS	Makefile	/^test_symbol_table_test_CXXFLAGS = $(souffle_bin_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test -DBUILDDIR='"\/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/"'$/;"	m
test_symbol_table_test_DEPENDENCIES	Makefile	/^test_symbol_table_test_DEPENDENCIES = libsouffle.la$/;"	m
test_symbol_table_test_LDADD	Makefile	/^test_symbol_table_test_LDADD = libsouffle.la$/;"	m
test_symbol_table_test_LINK	Makefile	/^test_symbol_table_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_symbol_table_test_OBJECTS	Makefile	/^test_symbol_table_test_OBJECTS = $(am_test_symbol_table_test_OBJECTS)$/;"	m
test_symbol_table_test_SOURCES	Makefile	/^test_symbol_table_test_SOURCES = test\/symbol_table_test.cpp$/;"	m
test_table_test_CXXFLAGS	Makefile	/^test_table_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_table_test_DEPENDENCIES	Makefile	/^test_table_test_DEPENDENCIES = libsouffle.la$/;"	m
test_table_test_LDADD	Makefile	/^test_table_test_LDADD = libsouffle.la$/;"	m
test_table_test_LINK	Makefile	/^test_table_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_table_test_OBJECTS	Makefile	/^test_table_test_OBJECTS = $(am_test_table_test_OBJECTS)$/;"	m
test_table_test_SOURCES	Makefile	/^test_table_test_SOURCES = test\/table_test.cpp$/;"	m
test_type_system_test_CXXFLAGS	Makefile	/^test_type_system_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_type_system_test_DEPENDENCIES	Makefile	/^test_type_system_test_DEPENDENCIES = libsouffle.la$/;"	m
test_type_system_test_LDADD	Makefile	/^test_type_system_test_LDADD = libsouffle.la$/;"	m
test_type_system_test_LINK	Makefile	/^test_type_system_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_type_system_test_OBJECTS	Makefile	/^test_type_system_test_OBJECTS = $(am_test_type_system_test_OBJECTS)$/;"	m
test_type_system_test_SOURCES	Makefile	/^test_type_system_test_SOURCES = test\/type_system_test.cpp$/;"	m
test_util_test_CXXFLAGS	Makefile	/^test_util_test_CXXFLAGS = $(souffle_CPPFLAGS) -I \/Users\/xiaowenhu\/Desktop\/lvm_souffle\/src\/test$/;"	m
test_util_test_DEPENDENCIES	Makefile	/^test_util_test_DEPENDENCIES = libsouffle.la$/;"	m
test_util_test_LDADD	Makefile	/^test_util_test_LDADD = libsouffle.la$/;"	m
test_util_test_LINK	Makefile	/^test_util_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\$/;"	m
test_util_test_OBJECTS	Makefile	/^test_util_test_OBJECTS = $(am_test_util_test_OBJECTS)$/;"	m
test_util_test_SOURCES	Makefile	/^test_util_test_SOURCES = test\/util_test.cpp$/;"	m
testutil	test/test.h	/^namespace testutil {$/;"	n
text	ProfileDatabase.h	/^    std::string text;$/;"	m	class:souffle::profile::TextEntry
textProcessor	EventProcessor.h	/^} textProcessor;$/;"	m	namespace:souffle::profile	typeref:class:souffle::profile::TextProcessor
th	ProfileEvent.h	/^        std::thread th;$/;"	m	class:souffle::ProfileEventSingleton::ProfileTimer
that	parser.hh	/^      stack_symbol_type (YY_RVREF (stack_symbol_type) that);$/;"	m	struct:yy::parser::stack_symbol_type
theOrder	InterpreterIndex.h	/^    const InterpreterIndexOrder theOrder;$/;"	m	class:souffle::InterpreterIndex
throwError	ReadStreamSQLite.h	/^    void throwError(const std::string& message) {$/;"	f	class:souffle::ReadStreamSQLite
throwError	WriteStreamSQLite.h	/^    void throwError(const std::string& message) {$/;"	f	class:souffle::WriteStreamSQLite
time	ProfileDatabase.h	/^    microseconds time;$/;"	m	class:souffle::profile::DurationEntry::TimeEntry
time	profile/Tui.h	/^        std::chrono::microseconds time;$/;"	m	struct:souffle::profile::Tui::Usage
time	test/btree_multiset_test.cpp	/^long time(const std::string& name, const Op& operation) {$/;"	f	namespace:souffle::test
time	test/btree_set_test.cpp	/^long time(const std::string& name, const Op& operation) {$/;"	f	namespace:souffle::test
timer	ProfileEvent.h	/^    ProfileTimer timer;$/;"	m	class:souffle::ProfileEventSingleton
timerMutex	ProfileEvent.h	/^        std::mutex timerMutex;$/;"	m	class:souffle::ProfileEventSingleton::ProfileTimer
title	DebugReport.h	/^    std::string title;$/;"	m	class:souffle::DebugReportSection
toA	IndexSetAnalysis.h	/^    static SearchColumns toA(SearchColumns b) {$/;"	f	class:souffle::IndexSet
toB	IndexSetAnalysis.h	/^    static SearchColumns toB(SearchColumns a) {$/;"	f	class:souffle::IndexSet
toBase64	DebugReport.cpp	/^static std::string toBase64(const std::string& data) {$/;"	f	namespace:souffle
toBddbddb	souffle2bdd.cpp	/^void toBddbddb(std::ostream& out, const AstTranslationUnit& translationUnit) {$/;"	f	namespace:souffle
toBinaryConstraintOp	BinaryConstraintOps.h	/^inline BinaryConstraintOp toBinaryConstraintOp(const std::string& symbol) {$/;"	f	namespace:souffle
toBinaryConstraintSymbol	BinaryConstraintOps.h	/^inline std::string toBinaryConstraintSymbol(BinaryConstraintOp op) {$/;"	f	namespace:souffle
toClauseBodies	AstParserUtils.cpp	/^std::vector<AstClause*> RuleBody::toClauseBodies() const {$/;"	f	class:souffle::RuleBody
toDense	UnionFind.h	/^    parent_t toDense(const SparseDomain in) {$/;"	f	class:souffle::SparseDisjointSet
toIndex	Synthesiser.cpp	/^std::string Synthesiser::toIndex(SearchColumns key) {$/;"	f	class:souffle::Synthesiser
toLogicblox	souffle2lb.cpp	/^void toLogicblox(std::ostream& out, std::ostream& impOut, std::ostream& expOut, std::ostream& decOut,$/;"	f	namespace:souffle
toMask	Brie.h	/^        static uint64_t toMask(const value_t& value) {$/;"	f	class:souffle::SparseBitMap::iterator
toPtrSet	Util.h	/^std::set<T*> toPtrSet(const std::set<std::shared_ptr<T>>& v) {$/;"	f	namespace:souffle
toPtrSet	Util.h	/^std::set<T*> toPtrSet(const std::set<std::unique_ptr<T>>& v) {$/;"	f	namespace:souffle
toPtrVector	Util.h	/^std::vector<T*> toPtrVector(const std::vector<std::shared_ptr<T>>& v) {$/;"	f	namespace:souffle
toPtrVector	Util.h	/^std::vector<T*> toPtrVector(const std::vector<std::unique_ptr<T>>& v) {$/;"	f	namespace:souffle
toSet	Util.h	/^std::set<T> toSet() {$/;"	f	namespace:souffle
toSet	Util.h	/^std::set<T> toSet(const T& first, const R&... rest) {$/;"	f	namespace:souffle
toSparse	UnionFind.h	/^    inline const SparseDomain toSparse(const parent_t in) const {$/;"	f	class:souffle::SparseDisjointSet
toString	Util.h	/^inline const std::string& toString(const std::string& str) {$/;"	f	namespace:souffle
toString	profile/Iteration.h	/^    std::string toString() const {$/;"	f	class:souffle::profile::Iteration
toString	profile/ProgramRun.h	/^    std::string toString() {$/;"	f	class:souffle::profile::ProgramRun
toString	profile/Relation.h	/^    std::string toString() const {$/;"	f	class:souffle::profile::Relation
toString	profile/Rule.h	/^    std::string toString() const {$/;"	f	class:souffle::profile::Rule
toVector	Util.h	/^std::vector<T> toVector() {$/;"	f	namespace:souffle
toVector	Util.h	/^std::vector<T> toVector(const T& first, const R&... rest) {$/;"	f	namespace:souffle
token	parser.hh	/^    struct token$/;"	s	class:yy::parser
token_number_type	parser.hh	/^    typedef unsigned char token_number_type;$/;"	t	class:yy::parser
token_type	parser.hh	/^    typedef token::yytokentype token_type;$/;"	t	class:yy::parser
top	profile/Tui.h	/^    void top() {$/;"	f	namespace:souffle::profile
top_build_prefix	Makefile	/^top_build_prefix = ..\/$/;"	m
top_builddir	Makefile	/^top_builddir = ..$/;"	m
top_srcdir	Makefile	/^top_srcdir = ..$/;"	m
topologicalOrderingCost	PrecedenceGraph.cpp	/^int TopologicallySortedSCCGraph::topologicalOrderingCost(const std::vector<size_t>& permutationOfSCCs) const {$/;"	f	class:souffle::TopologicallySortedSCCGraph
topsortSCCGraph	PrecedenceGraph.h	/^    TopologicallySortedSCCGraph* topsortSCCGraph = nullptr;$/;"	m	class:souffle::RelationSchedule
totalIndex	InterpreterRelation.h	/^    mutable InterpreterIndex* totalIndex;$/;"	m	class:souffle::InterpreterRelation
trace_parsing	ParserDriver.h	/^    bool trace_parsing = false;$/;"	m	class:souffle::ParserDriver
trace_scanning	ParserDriver.h	/^    bool trace_scanning = false;$/;"	m	class:souffle::ParserDriver
transform	AstComponentChecker.cpp	/^bool AstComponentChecker::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstComponentChecker
transform	AstPragma.cpp	/^bool AstPragmaChecker::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstPragmaChecker
transform	AstSemanticChecker.cpp	/^bool AstExecutionPlanChecker::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstExecutionPlanChecker
transform	AstSemanticChecker.cpp	/^bool AstSemanticChecker::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstSemanticChecker
transform	AstTransforms.cpp	/^bool ConditionalTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ConditionalTransformer
transform	AstTransforms.cpp	/^bool FixpointTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::FixpointTransformer
transform	AstTransforms.cpp	/^bool NormaliseConstraintsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::NormaliseConstraintsTransformer
transform	AstTransforms.cpp	/^bool NullTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::NullTransformer
transform	AstTransforms.cpp	/^bool PartitionBodyLiteralsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::PartitionBodyLiteralsTransformer
transform	AstTransforms.cpp	/^bool PipelineTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::PipelineTransformer
transform	AstTransforms.cpp	/^bool ReduceExistentialsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ReduceExistentialsTransformer
transform	AstTransforms.cpp	/^bool RemoveBooleanConstraintsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RemoveBooleanConstraintsTransformer
transform	AstTransforms.cpp	/^bool RemoveRedundantRelationsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::RemoveRedundantRelationsTransformer
transform	AstTransforms.cpp	/^bool ReplaceSingletonVariablesTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ReplaceSingletonVariablesTransformer
transform	AstTransforms.cpp	/^bool UniqueAggregationVariablesTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::UniqueAggregationVariablesTransformer
transform	AstTransforms.cpp	/^bool WhileTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::WhileTransformer
transform	ComponentModel.cpp	/^bool ComponentInstantiationTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ComponentInstantiationTransformer
transform	DebugReport.cpp	/^bool DebugReporter::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::DebugReporter
transform	InlineRelationsTransformer.cpp	/^bool InlineRelationsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::InlineRelationsTransformer
transform	MagicSet.cpp	/^bool MagicSetTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::MagicSetTransformer
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
transform	MinimiseProgramTransformer.cpp	/^bool MinimiseProgramTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::MinimiseProgramTransformer
transform	ProvenanceTransformer.cpp	/^bool ProvenanceTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ProvenanceTransformer
transform	ReorderLiteralsTransformer.cpp	/^bool ReorderLiteralsTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ReorderLiteralsTransformer
transform	ResolveAliasesTransformer.cpp	/^bool ResolveAliasesTransformer::transform(AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::ResolveAliasesTransformer
transformEqrelRelation	ProvenanceTransformer.cpp	/^void transformEqrelRelation(AstRelation& rel) {$/;"	f	namespace:souffle
transformer	AstTransforms.h	/^    std::unique_ptr<AstTransformer> transformer;$/;"	m	class:souffle::ConditionalTransformer
transformer	AstTransforms.h	/^    std::unique_ptr<AstTransformer> transformer;$/;"	m	class:souffle::FixpointTransformer
transformer	AstTransforms.h	/^    std::unique_ptr<AstTransformer> transformer;$/;"	m	class:souffle::WhileTransformer
translateClause	AstTranslator.cpp	/^std::unique_ptr<RamStatement> AstTranslator::ClauseTranslator::translateClause($/;"	f	class:souffle::AstTranslator::ClauseTranslator
translateConstraint	AstTranslator.cpp	/^std::unique_ptr<RamCondition> AstTranslator::translateConstraint($/;"	f	class:souffle::AstTranslator
translateDeltaRelation	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::translateDeltaRelation(const AstRelation* rel) {$/;"	f	class:souffle::AstTranslator
translateNewRelation	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::translateNewRelation(const AstRelation* rel) {$/;"	f	class:souffle::AstTranslator
translateNonRecursiveRelation	AstTranslator.cpp	/^std::unique_ptr<RamStatement> AstTranslator::translateNonRecursiveRelation($/;"	f	class:souffle::AstTranslator
translateProgram	AstTranslator.cpp	/^void AstTranslator::translateProgram(const AstTranslationUnit& translationUnit) {$/;"	f	class:souffle::AstTranslator
translateRecursiveRelation	AstTranslator.cpp	/^std::unique_ptr<RamStatement> AstTranslator::translateRecursiveRelation($/;"	f	class:souffle::AstTranslator
translateRelation	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::translateRelation($/;"	f	class:souffle::AstTranslator
translateRelation	AstTranslator.cpp	/^std::unique_ptr<RamRelationReference> AstTranslator::translateRelation(const AstAtom* atom) {$/;"	f	class:souffle::AstTranslator
translateUnit	AstTranslator.cpp	/^std::unique_ptr<RamTranslationUnit> AstTranslator::translateUnit(AstTranslationUnit& tu) {$/;"	f	class:souffle::AstTranslator
translateValue	AstTranslator.cpp	/^std::unique_ptr<RamExpression> AstTranslator::translateValue($/;"	f	class:souffle::AstTranslator
translationUnit	Interpreter.h	/^    RamTranslationUnit& translationUnit;$/;"	m	class:souffle::Interpreter
translationUnit	ParserDriver.h	/^    std::unique_ptr<AstTranslationUnit> translationUnit;$/;"	m	class:souffle::ParserDriver
translationUnit	Synthesiser.h	/^    RamTranslationUnit& translationUnit;$/;"	m	class:souffle::Synthesiser
translator	AstTranslator.h	/^        AstTranslator& translator;$/;"	m	class:souffle::AstTranslator::ClauseTranslator
treePad	Explain.h	/^    WINDOW* treePad = nullptr;$/;"	m	class:souffle::Explain
trimWhitespace	profile/StringUtils.h	/^inline std::string trimWhitespace(std::string str) {$/;"	f	namespace:souffle::profile::Tools
truthValue	AstLiteral.h	/^    bool truthValue;$/;"	m	class:souffle::AstBooleanConstraint
tryUpdateFirstInfo	Brie.h	/^    bool tryUpdateFirstInfo(const FirstInfoSnapshot& info) {$/;"	f	class:souffle::SparseArray
tryUpdateRootInfo	Brie.h	/^    bool tryUpdateRootInfo(const RootInfoSnapshot& info) {$/;"	f	class:souffle::SparseArray
try_lock	ParallelUtils.h	/^    bool try_lock() {$/;"	f	class:souffle::Lock
try_lock	ParallelUtils.h	/^    bool try_lock() {$/;"	f	class:souffle::SpinLock
try_lock	ParallelUtils.h	/^    bool try_lock() {$/;"	f	class:souffle::souffle::SpinLock
try_lock	ParallelUtils.h	/^    bool try_lock() {$/;"	f	struct:souffle::souffle::Lock
try_start_write	ParallelUtils.h	/^    bool try_start_write() {$/;"	f	class:souffle::OptimisticReadWriteLock
try_start_write	ParallelUtils.h	/^    bool try_start_write() {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
try_upgrade_to_write	ParallelUtils.h	/^    bool try_upgrade_to_write() {$/;"	f	class:souffle::ReadWriteLock
try_upgrade_to_write	ParallelUtils.h	/^    bool try_upgrade_to_write() {$/;"	f	class:souffle::souffle::ReadWriteLock
try_upgrade_to_write	ParallelUtils.h	/^    bool try_upgrade_to_write(const Lease& \/*lease*\/) {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
try_upgrade_to_write	ParallelUtils.h	/^    bool try_upgrade_to_write(const Lease& lease) {$/;"	f	class:souffle::OptimisticReadWriteLock
try_write	ParallelUtils.h	/^    bool try_write() {$/;"	f	class:souffle::ReadWriteLock
try_write	ParallelUtils.h	/^    bool try_write() {$/;"	f	class:souffle::souffle::ReadWriteLock
tup	InterpreterInterface.h	/^        tuple tup;$/;"	m	class:souffle::InterpreterRelInterface::iterator_base
tuple	InterpreterRelation.h	/^        RamDomain* tuple = nullptr;$/;"	m	class:souffle::InterpreterRelation::iterator
tuple	SouffleInterface.h	/^    tuple(Relation* r, std::initializer_list<RamDomain> il) : relation(*r), array(il), pos(il.size()) {$/;"	f	class:souffle::tuple
tuple	SouffleInterface.h	/^    tuple(const Relation* r) : relation(*r), array(r->getArity()), pos(0), data(array.data()) {}$/;"	f	class:souffle::tuple
tuple	SouffleInterface.h	/^    tuple(const tuple& t) : relation(t.relation), array(t.array), pos(t.pos), data(array.data()) {}$/;"	f	class:souffle::tuple
tuple	SouffleInterface.h	/^class tuple {$/;"	c	namespace:souffle
tupleName	CompiledSouffle.h	/^    std::array<const char*, Arity> tupleName;$/;"	m	class:souffle::RelationWrapper
tupleType	CompiledSouffle.h	/^    std::array<const char*, Arity> tupleType;$/;"	m	class:souffle::RelationWrapper
tuple_equal	CompiledRelation.h	/^struct tuple_equal<index<>> {$/;"	s	namespace:souffle::ram::detail
tuple_equal	CompiledRelation.h	/^struct tuple_equal<index<First, Rest...>> {$/;"	s	namespace:souffle::ram::detail
tuple_hasher	CompiledRelation.h	/^struct tuple_hasher<index<First, Rest...>> {$/;"	s	namespace:souffle::ram::detail
tuple_hasher	CompiledRelation.h	/^struct tuple_hasher<index<Pos>> {$/;"	s	namespace:souffle::ram::detail
tuple_less	CompiledRelation.h	/^struct tuple_less<index<>> {$/;"	s	namespace:souffle::ram::detail
tuple_less	CompiledRelation.h	/^struct tuple_less<index<First, Rest...>> {$/;"	s	namespace:souffle::ram::detail
tuplesRead	profile/Relation.h	/^    size_t tuplesRead = 0;$/;"	m	class:souffle::profile::Relation
txt	ExplainTree.h	/^    std::string txt;      \/\/ text of tree node$/;"	m	class:souffle::TreeNode
type	AstArgument.h	/^    std::string type;$/;"	m	class:souffle::AstTypeCast
type	AstComponent.h	/^    std::unique_ptr<AstComponentType> type;$/;"	m	class:souffle::AstComponent
type	AstFunctorDeclaration.h	/^    const std::string type;$/;"	m	class:souffle::AstFunctorDeclaration
type	AstType.h	/^        AstTypeIdentifier type;  \/\/ < the field type$/;"	m	struct:souffle::AstRecordType::Field
type	ErrorReport.h	/^    Type type;$/;"	m	class:souffle::Diagnostic
type	RamExpression.h	/^    const std::string type;$/;"	m	class:souffle::RamUserDefinedOperator
type	RamNode.h	/^    const RamNodeType type;$/;"	m	class:souffle::RamNode
type	TypeSystem.h	/^        const Type& type;  \/\/ < the type of the field$/;"	m	struct:souffle::RecordType::Field
type	json11.h	/^                    int>::type = 0>$/;"	m	class:json11::final
type	json11.h	/^inline Json::Type Json::type() const {$/;"	f	class:json11::Json
type	parser.hh	/^      int type;$/;"	m	struct:yy::parser::by_type
typeCache	Synthesiser.h	/^    std::set<std::string> typeCache;$/;"	m	class:souffle::Synthesiser
typeEnv	AstTranslator.h	/^    const TypeEnvironment* typeEnv = nullptr;$/;"	m	class:souffle::AstTranslator
typeName	AstAttribute.h	/^    AstTypeIdentifier typeName;$/;"	m	class:souffle::AstAttribute
typeParams	AstComponent.h	/^    std::vector<AstTypeIdentifier> typeParams;$/;"	m	class:souffle::AstComponentType
type_lattice	AstTypeAnalysis.cpp	/^struct type_lattice : public property_space<TypeSet, sub_type, all_type_factory> {};$/;"	s	namespace:souffle::__anon77	file:
typeid	parser.hh	/^      : yytypeid_ (&typeid (T))$/;"	f	class:yy::parser::semantic_type
types	AstComponent.h	/^    std::vector<std::unique_ptr<AstType>> types;$/;"	m	class:souffle::AstComponent
types	AstProgram.h	/^    std::map<AstTypeIdentifier, std::unique_ptr<AstType>> types;$/;"	m	class:souffle::AstProgram
types	AstType.h	/^    std::vector<AstTypeIdentifier> types;$/;"	m	class:souffle::AstUnionType
types	ComponentModel.cpp	/^    std::vector<std::unique_ptr<AstType>> types;$/;"	m	struct:souffle::__anon73::ComponentContent	file:
types	InterpreterInterface.h	/^    std::vector<std::string> types;$/;"	m	class:souffle::InterpreterRelInterface
types	TypeSystem.h	/^    TypeSet(TypeSet&& other) noexcept : all(other.all), types() {$/;"	f	struct:souffle::TypeSet
types	TypeSystem.h	/^    std::map<identifier, Type*> types;$/;"	m	class:souffle::TypeEnvironment
types	TypeSystem.h	/^    std::set<const Type*, deref_less<Type>> types;$/;"	m	struct:souffle::TypeSet
unescape	AstIO.h	/^    std::string unescape($/;"	f	class:souffle::AstIO
unescape	AstIO.h	/^    std::string unescape(const std::string& inputString) const {$/;"	f	class:souffle::AstIO
unifyAtoms	InlineRelationsTransformer.cpp	/^NullableVector<std::pair<AstArgument*, AstArgument*>> unifyAtoms(AstAtom* first, AstAtom* second) {$/;"	f	namespace:souffle
unionContainsNumber	AstSemanticChecker.cpp	/^static bool unionContainsNumber(const AstProgram& program, const AstUnionType& type) {$/;"	f	namespace:souffle
unionContainsSymbol	AstSemanticChecker.cpp	/^static bool unionContainsSymbol(const AstProgram& program, const AstUnionType& type) {$/;"	f	namespace:souffle
unionNodes	UnionFind.h	/^    inline void unionNodes(SparseDomain x, SparseDomain y) {$/;"	f	class:souffle::SparseDisjointSet
unionNodes	UnionFind.h	/^    void unionNodes(parent_t x, parent_t y) {$/;"	f	class:souffle::DisjointSet
union_type	parser.hh	/^    union union_type$/;"	u	class:yy::parser::semantic_type
unique	CompiledIndexUtils.h	/^struct unique<> {$/;"	s	namespace:souffle::ram::column_utils
unique	CompiledIndexUtils.h	/^struct unique<> {$/;"	s	namespace:souffle::ram::index_utils
unique	CompiledIndexUtils.h	/^struct unique<E, Rest...> {$/;"	s	namespace:souffle::ram::column_utils
unique	CompiledIndexUtils.h	/^struct unique<First, Rest...> {$/;"	s	namespace:souffle::ram::index_utils
unlikely	UnionFind.h	/^#define unlikely(/;"	d
unlock	ParallelUtils.h	/^    void unlock() {$/;"	f	class:souffle::Lock
unlock	ParallelUtils.h	/^    void unlock() {$/;"	f	class:souffle::SpinLock
unlock	ParallelUtils.h	/^    void unlock() {}$/;"	f	class:souffle::souffle::SpinLock
unlock	ParallelUtils.h	/^    void unlock() {}$/;"	f	struct:souffle::souffle::Lock
unpack	CompiledRecord.h	/^    const tuple_type& unpack(RamDomain index) {$/;"	f	class:souffle::detail::RecordMap
unpack	CompiledRecord.h	/^const Tuple& unpack(RamDomain ref) {$/;"	f	namespace:souffle
unpack	InterpreterRecords.cpp	/^    RamDomain* unpack(RamDomain index) {$/;"	f	class:souffle::__anon67::RecordMap
unpack	InterpreterRecords.cpp	/^RamDomain* unpack(RamDomain ref, int arity) {$/;"	f	namespace:souffle
unpack	Mpi.h	/^inline void unpack<std::vector<std::string>>($/;"	f	namespace:souffle::mpi::__anon56
unput	scanner.cc	/^#define unput(/;"	d	file:
unsafeLookup	SymbolTable.h	/^    RamDomain unsafeLookup(const std::string& symbol) {$/;"	f	class:souffle::SymbolTable
unsafeResolve	SymbolTable.h	/^    const std::string& unsafeResolve(const RamDomain index) const {$/;"	f	class:souffle::SymbolTable
unset	Global.h	/^    void unset(const K& key) {$/;"	f	class:souffle::BaseTable
unsynced	Brie.h	/^        RootInfo unsynced;         \/\/ for sequential operations$/;"	m	union:souffle::SparseArray::__anon3
upd	BTree.h	/^    mutable Updater upd;$/;"	m	class:souffle::detail::btree
update	BTree.h	/^    void update(Key& old_k, const Key& new_k) {$/;"	f	class:souffle::detail::btree
update	BTree.h	/^    void update(T& \/* old_t *\/, const T& \/* new_t *\/) {}$/;"	f	struct:souffle::detail::updater
update	Brie.h	/^    void update(index_type i, const value_type& val) {$/;"	f	class:souffle::SparseArray
update	Brie.h	/^    void update(index_type i, const value_type& val, op_context& ctxt) {$/;"	f	class:souffle::SparseArray
updateAnterior	EquivalenceRelation.h	/^        inline void updateAnterior() {$/;"	f	class:souffle::EquivalenceRelation::iterator
updateDB	profile/Tui.h	/^    void updateDB() {$/;"	f	namespace:souffle::profile
updatePosterior	EquivalenceRelation.h	/^        inline void updatePosterior() {$/;"	f	class:souffle::EquivalenceRelation::iterator
updateQualifier	MagicSet.cpp	/^void updateQualifier(AstRelation* originalRelation, AstRelation* newRelation) {$/;"	f	namespace:souffle
updateRoot	UnionFind.h	/^    bool updateRoot(const parent_t x, const rank_t oldrank, const parent_t y, const rank_t newrank) {$/;"	f	class:souffle::DisjointSet
updateTypeEnvironment	AstTypeEnvironmentAnalysis.cpp	/^void TypeEnvironmentAnalysis::updateTypeEnvironment(const AstProgram& program) {$/;"	f	class:souffle::TypeEnvironmentAnalysis
updater	BTree.h	/^struct updater {$/;"	s	namespace:souffle::detail
updater	profile/Tui.h	/^    std::thread updater;$/;"	m	class:souffle::profile::Tui
upper_bound	BTree.h	/^        CacheAccessCounter upper_bound;$/;"	m	struct:souffle::detail::btree::hint_statistics
upper_bound	BTree.h	/^    Iter upper_bound(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::binary_search
upper_bound	BTree.h	/^    inline Iter upper_bound(const Key& k, Iter a, Iter b, Comp& comp) const {$/;"	f	struct:souffle::detail::linear_search
upper_bound	BTree.h	/^    iterator upper_bound(const Key& k) const {$/;"	f	class:souffle::detail::btree
upper_bound	BTree.h	/^    iterator upper_bound(const Key& k, operation_hints& hints) const {$/;"	f	class:souffle::detail::btree
usage	profile/Tui.h	/^    void usage(std::chrono::microseconds endTime, std::chrono::microseconds startTime, uint32_t height = 20) {$/;"	f	namespace:souffle::profile
usage	profile/Tui.h	/^    void usage(uint32_t height = 20) {$/;"	f	namespace:souffle::profile
usage	souffle-compile	/^usage() {$/;"	f
usage	souffle-config	/^function usage() {$/;"	f
usageRelation	profile/Tui.h	/^    void usageRelation(std::string id) {$/;"	f	namespace:souffle::profile
usageRule	profile/Tui.h	/^    void usageRule(std::string id) {$/;"	f	namespace:souffle::profile
used	Table.h	/^        std::size_t used = 0;$/;"	m	struct:souffle::Table::Block
usertime	profile/Tui.h	/^        std::chrono::microseconds usertime;$/;"	m	struct:souffle::profile::Tui::Usage
usesInvalidWitness	AstSemanticChecker.cpp	/^static const std::vector<SrcLocation> usesInvalidWitness(const std::vector<AstLiteral*>& literals,$/;"	f	namespace:souffle
valid	InlineRelationsTransformer.cpp	/^    bool valid = false;$/;"	m	class:souffle::NullableVector	file:
validate	ParallelUtils.h	/^    bool validate(const Lease& \/*lease*\/) {$/;"	f	class:souffle::souffle::OptimisticReadWriteLock
validate	ParallelUtils.h	/^    bool validate(const Lease& lease) {$/;"	f	class:souffle::OptimisticReadWriteLock
value	AstArgument.h	/^    std::unique_ptr<AstArgument> value;$/;"	m	class:souffle::AstTypeCast
value	AstPragma.h	/^    std::string value;$/;"	m	class:souffle::AstPragma
value	AstVisitor.h	/^    enum { value = std::is_base_of<ast_visitor_tag, T>::value };$/;"	e	enum:souffle::detail::is_ast_visitor::__anon4
value	Brie.h	/^        entry_type value;$/;"	m	class:souffle::detail::TrieBase::iterator
value	Brie.h	/^        index_type value;$/;"	m	class:souffle::SparseBitMap::iterator
value	Brie.h	/^        pair_type value;$/;"	m	class:souffle::SparseArray::iterator
value	Brie.h	/^        value_type value;$/;"	m	union:souffle::SparseArray::Cell
value	CompiledIndexUtils.h	/^        enum { value = column_utils::contains<Col, Columns...>::value };$/;"	e	enum:souffle::ram::index::covers::__anon16
value	CompiledIndexUtils.h	/^        enum { value = false };$/;"	e	enum:souffle::ram::index_utils::Indices::is_covered::__anon50
value	CompiledIndexUtils.h	/^        enum { value = is_compatible_with<I, First>::value || nested_indices::template is_covered<I>::value };$/;"	e	enum:souffle::ram::index_utils::Indices::is_covered::__anon49
value	CompiledIndexUtils.h	/^        tuple_type value;$/;"	m	class:souffle::ram::index_utils::DisjointSetIndex::iterator
value	CompiledIndexUtils.h	/^        tuple_type value;$/;"	m	class:souffle::ram::index_utils::TrieIndex::iterator
value	CompiledIndexUtils.h	/^        value = column_utils::contains<First, Full...>::value &&$/;"	e	enum:souffle::ram::index_utils::is_subset_of::__anon36
value	CompiledIndexUtils.h	/^        value = is_compatible_with_aux<index<A1..., A>, index<A2...>, index<B1..., B>, index<B2...>>::value$/;"	e	enum:souffle::ram::index_utils::detail::is_compatible_with_aux::__anon41
value	CompiledIndexUtils.h	/^        value = unique<Indices...>::value &&           \/\/ indices need to be unique$/;"	e	enum:souffle::ram::index_utils::check::__anon31
value	CompiledIndexUtils.h	/^    enum { value = !contains<E, Rest...>::value && unique<Rest...>::value };$/;"	e	enum:souffle::ram::column_utils::unique::__anon15
value	CompiledIndexUtils.h	/^    enum { value = (E == F) || contains<E, Rest...>::value };$/;"	e	enum:souffle::ram::column_utils::contains::__anon13
value	CompiledIndexUtils.h	/^    enum { value = (F < arity) && check_index_arity<arity, index<Rest...>>::value };$/;"	e	enum:souffle::ram::index_utils::check_index_arity::__anon28
value	CompiledIndexUtils.h	/^    enum { value = Index::size == arity };$/;"	e	enum:souffle::ram::index_utils::is_full_index::__anon45
value	CompiledIndexUtils.h	/^    enum { value = all_indices<First, Rest...>::value && !contains<First, Rest...>::value };$/;"	e	enum:souffle::ram::index_utils::unique::__anon25
value	CompiledIndexUtils.h	/^    enum { value = all_indices<Rest...>::value };$/;"	e	enum:souffle::ram::index_utils::all_indices::__anon20
value	CompiledIndexUtils.h	/^    enum { value = check_index_arity<arity, F>::value && check_arity<arity, Rest...>::value };$/;"	e	enum:souffle::ram::index_utils::check_arity::__anon30
value	CompiledIndexUtils.h	/^    enum { value = contains<E, Rest...>::value };$/;"	e	enum:souffle::ram::index_utils::contains::__anon22
value	CompiledIndexUtils.h	/^    enum { value = detail::is_compatible_with_aux<index<>, index<C1...>, index<>, index<C2...>>::value };$/;"	e	enum:souffle::ram::index_utils::is_compatible_with::__anon44
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::column_utils::contains::__anon12
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::all_indices::__anon18
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::check_index_arity::__anon26
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::contains::__anon21
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::contains_full_index::__anon47
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::detail::is_compatible_with_aux::__anon40
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::is_compatible_with::__anon43
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::is_permutation::__anon38
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::is_prefix::__anon32
value	CompiledIndexUtils.h	/^    enum { value = false };$/;"	e	enum:souffle::ram::index_utils::is_subset_of::__anon35
value	CompiledIndexUtils.h	/^    enum { value = is_full_index<arity, First>::value || contains_full_index<arity, Rest...>::value };$/;"	e	enum:souffle::ram::index_utils::contains_full_index::__anon46
value	CompiledIndexUtils.h	/^    enum { value = is_permutation<index<A...>, index<B...>>::value };$/;"	e	enum:souffle::ram::index_utils::detail::is_compatible_with_aux::__anon42
value	CompiledIndexUtils.h	/^    enum { value = is_prefix<index<Ra...>, index<Rb...>>::value };$/;"	e	enum:souffle::ram::index_utils::is_prefix::__anon34
value	CompiledIndexUtils.h	/^    enum { value = sizeof...(C1) == sizeof...(C2) && is_subset_of<index<C1...>, index<C2...>>::value };$/;"	e	enum:souffle::ram::index_utils::is_permutation::__anon39
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::column_utils::unique::__anon14
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::all_indices::__anon19
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::check_arity::__anon29
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::check_index_arity::__anon27
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::contains::__anon23
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::is_prefix::__anon33
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::is_subset_of::__anon37
value	CompiledIndexUtils.h	/^    enum { value = true };$/;"	e	enum:souffle::ram::index_utils::unique::__anon24
value	CompiledIndexUtils.h	/^    tuple_type value;$/;"	m	class:souffle::ram::iterator_utils::filter_iterator
value	CompiledRelation.h	/^        enum { value = indices_t::template is_covered<Index>::value };$/;"	e	enum:souffle::ram::detail::AutoRelation::covered::__anon51
value	CompiledSouffle.h	/^        bool value;$/;"	m	class:souffle::t_nullaries::iterator
value	IterUtils.h	/^    T value;$/;"	m	class:souffle::SingleValueIterator
value	RamVisitor.h	/^    enum { value = std::is_base_of<ram_visitor_tag, T>::value };$/;"	e	enum:souffle::detail::is_ram_visitor::__anon1
value	json11.h	/^                            std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,$/;"	m	class:json11::final
value	parser.hh	/^      semantic_type value;$/;"	m	struct:yy::parser::basic_symbol
value	profile/Cell.h	/^    const T value;$/;"	m	class:souffle::profile::Cell
value	profile/Cell.h	/^    const double value;$/;"	m	class:souffle::profile::Cell
value	profile/Cell.h	/^    const long value;$/;"	m	class:souffle::profile::Cell
value	profile/Cell.h	/^    const std::chrono::microseconds value;$/;"	m	class:souffle::profile::Cell
value	profile/Cell.h	/^    const std::string value;$/;"	m	class:souffle::profile::Cell
valueIndex	AstTranslator.h	/^        ValueIndex valueIndex;$/;"	m	class:souffle::AstTranslator::ClauseTranslator
values	RamCondition.h	/^    std::vector<std::unique_ptr<RamExpression>> values;$/;"	m	class:souffle::RamAbstractExistenceCheck
values	RamStatement.h	/^    std::vector<std::unique_ptr<RamExpression>> values;$/;"	m	class:souffle::RamFact
varCounter	souffle2bdd.cpp	/^    int varCounter = 0;$/;"	m	class:souffle::BddBddBTranslator	file:
varDependencies	MagicSet.h	/^    std::map<std::string, std::set<std::string>> varDependencies;$/;"	m	class:souffle::BindingStore
variableBoundComposites	MagicSet.h	/^    std::set<std::string> variableBoundComposites;$/;"	m	class:souffle::BindingStore
variables	AstConstraintAnalysis.h	/^    std::map<std::string, AnalysisVar> variables;$/;"	m	class:souffle::__anon68::AstConstraintAnalysis
vector	InlineRelationsTransformer.cpp	/^    std::vector<T> vector;$/;"	m	class:souffle::NullableVector	file:
verAtoms	profile/Tui.h	/^    void verAtoms(Table& atomTable, const std::string& ruleName = "") {$/;"	f	namespace:souffle::profile
verGraph	profile/Tui.h	/^    void verGraph(std::string c, std::string col) {$/;"	f	namespace:souffle::profile
verRul	profile/Tui.h	/^    void verRul(std::string str) {$/;"	f	namespace:souffle::profile
verbose	AstTransformer.h	/^    bool verbose = false;$/;"	m	class:souffle::MetaTransformer
version	Brie.h	/^        uintptr_t version;$/;"	m	struct:souffle::SparseArray::FirstInfoSnapshot
version	Brie.h	/^        uintptr_t version;$/;"	m	struct:souffle::SparseArray::RootInfoSnapshot
version	ParallelUtils.h	/^        int version;$/;"	m	class:souffle::OptimisticReadWriteLock::Lease
version	ParallelUtils.h	/^    std::atomic<int> version;$/;"	m	class:souffle::OptimisticReadWriteLock
version	profile/Rule.h	/^    int version = 0;$/;"	m	class:souffle::profile::Rule
vertices	GraphUtils.h	/^    const std::set<Vertex, Compare>& vertices() const {$/;"	f	class:souffle::Graph
visit	AstVisitor.h	/^    virtual R visit(const AstNode& node, Params... args) {$/;"	f	struct:souffle::AstVisitor
visit	ProfileDatabase.h	/^    virtual void visit(DurationEntry& e) {}$/;"	f	class:souffle::profile::Visitor
visit	ProfileDatabase.h	/^    virtual void visit(SizeEntry& e) {}$/;"	f	class:souffle::profile::Visitor
visit	ProfileDatabase.h	/^    virtual void visit(TextEntry& e) {}$/;"	f	class:souffle::profile::Visitor
visit	ProfileDatabase.h	/^    virtual void visit(TimeEntry& e) {}$/;"	f	class:souffle::profile::Visitor
visit	RamVisitor.h	/^    virtual R visit(const RamNode& node, Params... args) {$/;"	f	struct:souffle::RamVisitor
visit	RamVisitor.h	/^    virtual R visit(const RamNode* node, Params... args) {$/;"	f	struct:souffle::RamVisitor
visit	TypeSystem.cpp	/^    virtual R visit(const Type& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
visitDepthFirst	AstVisitor.h	/^typename std::enable_if<!detail::is_ast_visitor<Lambda>::value, void>::type visitDepthFirst($/;"	f	namespace:souffle
visitDepthFirst	AstVisitor.h	/^void visitDepthFirst(const AstNode& root, AstVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitDepthFirst	AstVisitor.h	/^void visitDepthFirst(const AstNode& root, const std::function<R(const N&)>& fun) {$/;"	f	namespace:souffle
visitDepthFirst	AstVisitor.h	/^void visitDepthFirst(const std::vector<T*>& list, const Lambda& fun) {$/;"	f	namespace:souffle
visitDepthFirst	AstVisitor.h	/^void visitDepthFirst(const std::vector<std::unique_ptr<T>>& list, const Lambda& fun) {$/;"	f	namespace:souffle
visitDepthFirst	GraphUtils.h	/^    void visitDepthFirst($/;"	f	class:souffle::Graph
visitDepthFirst	GraphUtils.h	/^    void visitDepthFirst(const Vertex& vertex, const Lambda& lambda) const {$/;"	f	class:souffle::Graph
visitDepthFirst	RamVisitor.h	/^typename std::enable_if<!detail::is_ram_visitor<Lambda>::value, void>::type visitDepthFirst($/;"	f	namespace:souffle
visitDepthFirst	RamVisitor.h	/^void visitDepthFirst(const RamNode& root, RamVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitDepthFirst	RamVisitor.h	/^void visitDepthFirst(const RamNode& root, const std::function<R(const N&)>& fun) {$/;"	f	namespace:souffle
visitDepthFirstPostOrder	AstVisitor.h	/^typename std::enable_if<!detail::is_ast_visitor<Lambda>::value, void>::type visitDepthFirstPostOrder($/;"	f	namespace:souffle
visitDepthFirstPostOrder	AstVisitor.h	/^void visitDepthFirstPostOrder(const AstNode& root, AstVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitDepthFirstPostOrder	AstVisitor.h	/^void visitDepthFirstPostOrder(const AstNode& root, const std::function<R(const N&)>& fun) {$/;"	f	namespace:souffle
visitDepthFirstPostOrder	RamVisitor.h	/^void visitDepthFirstPostOrder(const RamNode& root, RamVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitDepthFirstPreOrder	AstVisitor.h	/^void visitDepthFirstPreOrder(const AstNode& root, AstVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitDepthFirstPreOrder	RamVisitor.h	/^void visitDepthFirstPreOrder(const RamNode& root, RamVisitor<R, Ps...>& visitor, Args&... args) {$/;"	f	namespace:souffle
visitNode	AstVisitor.h	/^    virtual R visitNode(const AstNode& \/*node*\/, Params... \/*args*\/) {$/;"	f	struct:souffle::AstVisitor
visitNode	RamVisitor.h	/^    virtual R visitNode(const RamNode& \/*node*\/, Params... \/*args*\/) {$/;"	f	struct:souffle::RamVisitor
visitPredefinedType	TypeSystem.cpp	/^    virtual R visitPredefinedType(const PredefinedType& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
visitPrimitiveType	TypeSystem.cpp	/^    virtual R visitPrimitiveType(const PrimitiveType& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
visitRecordType	TypeSystem.cpp	/^    virtual R visitRecordType(const RecordType& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
visitRelationIdentifier	souffle2bdd.cpp	/^    void visitRelationIdentifier(const AstRelationIdentifier& id, std::ostream& out) {$/;"	f	class:souffle::BddBddBTranslator	file:
visitRelationIdentifier	souffle2lb.cpp	/^    void visitRelationIdentifier(const AstRelationIdentifier& id, std::ostream& out) {$/;"	f	class:souffle::LogicbloxConverter	file:
visitType	TypeSystem.cpp	/^    virtual R visitType(const Type& \/*type*\/) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
visitUnionType	TypeSystem.cpp	/^    virtual R visitUnionType(const UnionType& type) const {$/;"	f	struct:souffle::__anon75::TypeVisitor
weak_comp	BTree.h	/^    mutable WeakComparator weak_comp;$/;"	m	class:souffle::detail::btree
weak_covers	BTree.h	/^    bool weak_covers(const node* node, const Key& k) const {$/;"	f	class:souffle::detail::btree
weak_equal	BTree.h	/^    bool weak_equal(const Key& a, const Key& b) const {$/;"	f	class:souffle::detail::btree
weak_less	BTree.h	/^    bool weak_less(const Key& a, const Key& b) const {$/;"	f	class:souffle::detail::btree
width	ExplainTree.h	/^    uint32_t width = 0;   \/\/ width of node (including sub-trees)$/;"	m	class:souffle::TreeNode
width	ExplainTree.h	/^    uint32_t width;   \/\/ width of the screen buffer$/;"	m	class:souffle::ScreenBuffer
window	profile/htmlJsChartistMin.h	/^    return a}).reduce(function(a,b){return{x:a.x+(b&&b.x)||0,y:a.y+(b&&b.y)||0}},{x:0,y:0})});d=c.getHighLow([i],a,a.horizontalBars?"x":"y")}else d=c.getHighLow(b.normalized.series,a,a.horizontalBars?"x":"y");d.high=+a.high||(0===a.high?0:d.high),d.low=+a.low||(0===a.low?0:d.low);var j,k,l,m,n,o=c.createChartRect(this.svg,a,f.padding);k=a.distributeSeries&&a.stackBars?b.normalized.labels.slice(0,1):b.normalized.labels,a.horizontalBars?(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,c.extend({},a.axisX,{highLow:d,referenceValue:0})),l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y,b.normalized.series,o,{ticks:k}):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,a.axisY)):(l=m=void 0===a.axisX.type?new c.StepAxis(c.Axis.units.x,b.normalized.series,o,{ticks:k}):a.axisX.type.call(c,c.Axis.units.x,b.normalized.series,o,a.axisX),j=n=void 0===a.axisY.type?new c.AutoScaleAxis(c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})):a.axisY.type.call(c,c.Axis.units.y,b.normalized.series,o,c.extend({},a.axisY,{highLow:d,referenceValue:0})));var p=a.horizontalBars?o.x1+j.projectValue(0):o.y1-j.projectValue(0),q=[];l.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),j.createGridAndLabels(e,h,this.supportsForeignObject,a,this.eventEmitter),a.showGridBackground&&c.createGridBackground(e,o,a.classNames.gridBackground,this.eventEmitter),b.raw.series.forEach(function(d,e){var f,h,i=e-(b.raw.series.length-1)\/2;f=a.distributeSeries&&!a.stackBars?l.axisLength\/b.normalized.series.length\/2:a.distributeSeries&&a.stackBars?l.axisLength\/2:l.axisLength\/b.normalized.series[e].length\/2,h=g.elem("g"),h.attr({"ct:series-name":d.name,"ct:meta":c.serialize(d.meta)}),h.addClass([a.classNames.series,d.className||a.classNames.series+"-"+c.alphaNumerate(e)].join(" ")),b.normalized.series[e].forEach(function(g,k){var r,s,t,u;if(u=a.distributeSeries&&!a.stackBars?e:a.distributeSeries&&a.stackBars?0:k,r=a.horizontalBars?{x:o.x1+j.projectValue(g&&g.x?g.x:0,k,b.normalized.series[e]),y:o.y1-l.projectValue(g&&g.y?g.y:0,u,b.normalized.series[e])}:{x:o.x1+l.projectValue(g&&g.x?g.x:0,u,b.normalized.series[e]),y:o.y1-j.projectValue(g&&g.y?g.y:0,k,b.normalized.series[e])},l instanceof c.StepAxis&&(l.options.stretch||(r[l.units.pos]+=f*(a.horizontalBars?-1:1)),r[l.units.pos]+=a.stackBars||a.distributeSeries?0:i*a.seriesBarDistance*(a.horizontalBars?-1:1)),t=q[k]||p,q[k]=t-(p-r[l.counterUnits.pos]),void 0!==g){var v={};v[l.units.pos+"1"]=r[l.units.pos],v[l.units.pos+"2"]=r[l.units.pos],!a.stackBars||"accumulate"!==a.stackMode&&a.stackMode?(v[l.counterUnits.pos+"1"]=p,v[l.counterUnits.pos+"2"]=r[l.counterUnits.pos]):(v[l.counterUnits.pos+"1"]=t,v[l.counterUnits.pos+"2"]=q[k]),v.x1=Math.min(Math.max(v.x1,o.x1),o.x2),v.x2=Math.min(Math.max(v.x2,o.x1),o.x2),v.y1=Math.min(Math.max(v.y1,o.y2),o.y1),v.y2=Math.min(Math.max(v.y2,o.y2),o.y1);var w=c.getMetaData(d,k);s=h.elem("line",v,a.classNames.bar).attr({"ct:value":[g.x,g.y].filter(c.isNumeric).join(","),"ct:meta":c.serialize(w)}),this.eventEmitter.emit("draw",c.extend({type:"bar",value:g,index:k,meta:w,series:d,seriesIndex:e,axisX:m,axisY:n,chartRect:o,group:h,element:s},v))}}.bind(this))}.bind(this)),this.eventEmitter.emit("created",{bounds:j.bounds,chartRect:o,axisX:m,axisY:n,svg:this.svg,options:a})}function e(a,b,d,e){c.Bar["super"].constructor.call(this,a,b,f,c.extend({},f,d),e)}var f={axisX:{offset:30,position:"end",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:30,onlyInteger:!1},axisY:{offset:40,position:"start",labelOffset:{x:0,y:0},showLabel:!0,showGrid:!0,labelInterpolationFnc:c.noop,scaleMinSpace:20,onlyInteger:!1},width:void 0,height:void 0,high:void 0,low:void 0,referenceValue:0,chartPadding:{top:15,right:15,bottom:5,left:10},seriesBarDistance:15,stackBars:!1,stackMode:"accumulate",horizontalBars:!1,distributeSeries:!1,reverseData:!1,showGridBackground:!1,classNames:{chart:"ct-chart-bar",horizontalBars:"ct-horizontal-bars",label:"ct-label",labelGroup:"ct-labels",series:"ct-series",bar:"ct-bar",grid:"ct-grid",gridGroup:"ct-grids",gridBackground:"ct-grid-background",vertical:"ct-vertical",horizontal:"ct-horizontal",start:"ct-start",end:"ct-end"}};c.Bar=c.Base.extend({constructor:e,createChart:d})}(window,document,a),function(a,b,c){"use strict";function d(a,b,c){var d=b.x>a.x;return d&&"explode"===c||!d&&"implode"===c?"start":d&&"implode"===c||!d&&"explode"===c?"end":"middle"}function e(a){var b,e,f,h,i,j=c.normalizeData(this.data),k=[],l=a.startAngle;this.svg=c.createSvg(this.container,a.width,a.height,a.donut?a.classNames.chartDonut:a.classNames.chartPie),e=c.createChartRect(this.svg,a,g.padding),f=Math.min(e.width()\/2,e.height()\/2),i=a.total||j.normalized.series.reduce(function(a,b){return a+b},0);var m=c.quantity(a.donutWidth);"%"===m.unit&&(m.value*=f\/100),f-=a.donut?m.value\/2:0,h="outside"===a.labelPosition||a.donut?f:"center"===a.labelPosition?0:f\/2,h+=a.labelOffset;var n={x:e.x1+e.width()\/2,y:e.y2+e.height()\/2},o=1===j.raw.series.filter(function(a){return a.hasOwnProperty("value")?0!==a.value:0!==a}).length;j.raw.series.forEach(function(a,b){k[b]=this.svg.elem("g",null,null)}.bind(this)),a.showLabel&&(b=this.svg.elem("g",null,null)),j.raw.series.forEach(function(e,g){if(0!==j.normalized.series[g]||!a.ignoreEmptyValues){k[g].attr({"ct:series-name":e.name}),k[g].addClass([a.classNames.series,e.className||a.classNames.series+"-"+c.alphaNumerate(g)].join(" "));var p=i>0?l+j.normalized.series[g]\/i*360:0,q=Math.max(0,l-(0===g||o?0:.2));p-q>=359.99&&(p=q+359.99);var r=c.polarToCartesian(n.x,n.y,f,q),s=c.polarToCartesian(n.x,n.y,f,p),t=new c.Svg.Path((!a.donut)).move(s.x,s.y).arc(f,f,0,p-l>180,0,r.x,r.y);a.donut||t.line(n.x,n.y);var u=k[g].elem("path",{d:t.stringify()},a.donut?a.classNames.sliceDonut:a.classNames.slicePie);if(u.attr({"ct:value":j.normalized.series[g],"ct:meta":c.serialize(e.meta)}),a.donut&&u.attr({style:"stroke-width: "+m.value+"px"}),this.eventEmitter.emit("draw",{type:"slice",value:j.normalized.series[g],totalDataSum:i,index:g,meta:e.meta,series:e,group:k[g],element:u,path:t.clone(),center:n,radius:f,startAngle:l,endAngle:p}),a.showLabel){var v;v=1===j.raw.series.length?{x:n.x,y:n.y}:c.polarToCartesian(n.x,n.y,h,l+(p-l)\/2);var w;w=j.normalized.labels&&!c.isFalseyButZero(j.normalized.labels[g])?j.normalized.labels[g]:j.normalized.series[g];var x=a.labelInterpolationFnc(w,g);if(x||0===x){var y=b.elem("text",{dx:v.x,dy:v.y,"text-anchor":d(n,v,a.labelDirection)},a.classNames.label).text(""+x);this.eventEmitter.emit("draw",{type:"label",index:g,group:b,element:y,text:""+x,x:v.x,y:v.y})}}l=p}}.bind(this)),this.eventEmitter.emit("created",{chartRect:e,svg:this.svg,options:a})}function f(a,b,d,e){c.Pie["super"].constructor.call(this,a,b,g,c.extend({},g,d),e)}var g={width:void 0,height:void 0,chartPadding:5,classNames:{chartPie:"ct-chart-pie",chartDonut:"ct-chart-donut",series:"ct-series",slicePie:"ct-slice-pie",sliceDonut:"ct-slice-donut",label:"ct-label"},startAngle:0,total:void 0,donut:!1,donutWidth:60,showLabel:!0,labelOffset:0,labelPosition:"inside",labelInterpolationFnc:c.noop,labelDirection:"neutral",reverseData:!1,ignoreEmptyValues:!1};c.Pie=c.Base.extend({constructor:f,createChart:e,determineAnchorPosition:d})}(window,document,a),a});$/;"	m	namespace:souffle::profile
wrapCss	profile/HtmlGenerator.h	/^    static std::string wrapCss(const std::string& css) {$/;"	f	class:souffle::profile::HtmlGenerator
wrapJs	profile/HtmlGenerator.h	/^    static std::string wrapJs(const std::string& js) {$/;"	f	class:souffle::profile::HtmlGenerator
wrappedTransformer	DebugReport.h	/^    std::unique_ptr<AstTransformer> wrappedTransformer;$/;"	m	class:souffle::DebugReporter
write	ExplainTree.h	/^    void write(uint32_t x, uint32_t y, const std::string& s) {$/;"	f	class:souffle::ScreenBuffer
writeAll	WriteStream.h	/^    void writeAll(const T& relation) {$/;"	f	class:souffle::WriteStream
writeEntry	ProfileDatabase.h	/^    Entry* writeEntry(std::unique_ptr<Entry> entry) {$/;"	f	class:souffle::profile::DirectoryEntry
writeNext	WriteStream.h	/^    void writeNext(const Tuple tuple) {$/;"	f	class:souffle::WriteStream
writeNext	WriteStream.h	/^inline void WriteStream::writeNext(const RamDomain* tuple) {$/;"	f	class:souffle::WriteStream
writeSize	WriteStream.h	/^    virtual void writeSize(std::size_t size) {$/;"	f	class:souffle::WriteStream
writeSize	WriteStream.h	/^    void writeSize(const T& relation) {$/;"	f	class:souffle::WriteStream
xpos	ExplainTree.h	/^    int xpos = 0;         \/\/ x-position of text$/;"	m	class:souffle::TreeNode
ypos	ExplainTree.h	/^    int ypos = 0;         \/\/ y-position of text$/;"	m	class:souffle::TreeNode
yy	parser.cc	/^namespace yy {$/;"	n	file:
yy	parser.hh	/^namespace yy {$/;"	n
yy_accept	scanner.cc	/^static yyconst flex_int16_t yy_accept[281] =$/;"	v	file:
yy_at_bol	scanner.cc	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	scanner.cc	/^static yyconst flex_int16_t yy_base[288] =$/;"	v	file:
yy_bs_column	scanner.cc	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	scanner.cc	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	scanner.cc	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	scanner.cc	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	scanner.cc	/^    YY_BUFFER_STATE * yy_buffer_stack; \/**< Stack as an array. *\/$/;"	m	struct:yyguts_t	file:
yy_buffer_stack_max	scanner.cc	/^    size_t yy_buffer_stack_max; \/**< capacity of stack. *\/$/;"	m	struct:yyguts_t	file:
yy_buffer_stack_top	scanner.cc	/^    size_t yy_buffer_stack_top; \/**< index of top of stack. *\/$/;"	m	struct:yyguts_t	file:
yy_buffer_state	scanner.cc	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	scanner.cc	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	scanner.cc	/^    char *yy_c_buf_p;$/;"	m	struct:yyguts_t	file:
yy_ch_buf	scanner.cc	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	scanner.cc	/^static yyconst flex_int16_t yy_chk[408] =$/;"	v	file:
yy_create_buffer	scanner.cc	/^    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)$/;"	f
yy_def	scanner.cc	/^static yyconst flex_int16_t yy_def[288] =$/;"	v	file:
yy_delete_buffer	scanner.cc	/^    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)$/;"	f
yy_destroy_	parser.cc	/^  parser::yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const$/;"	f	class:yy::parser
yy_did_buffer_switch_on_eof	scanner.cc	/^    int yy_did_buffer_switch_on_eof;$/;"	m	struct:yyguts_t	file:
yy_ec	scanner.cc	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	scanner.cc	/^static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)$/;"	f	file:
yy_fill_buffer	scanner.cc	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	scanner.cc	/^#define yy_flex_debug /;"	d	file:
yy_flex_debug_r	scanner.cc	/^    int yy_flex_debug_r;$/;"	m	struct:yyguts_t	file:
yy_flex_strlen	scanner.cc	/^static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)$/;"	f	file:
yy_flex_strncpy	scanner.cc	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)$/;"	f	file:
yy_flush_buffer	scanner.cc	/^    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)$/;"	f
yy_get_next_buffer	scanner.cc	/^static int yy_get_next_buffer (yyscan_t yyscanner)$/;"	f	file:
yy_get_previous_state	scanner.cc	/^    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)$/;"	f	file:
yy_hold_char	scanner.cc	/^    char yy_hold_char;$/;"	m	struct:yyguts_t	file:
yy_init	scanner.cc	/^    int yy_init;$/;"	m	struct:yyguts_t	file:
yy_init_buffer	scanner.cc	/^    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)$/;"	f	file:
yy_init_globals	scanner.cc	/^static int yy_init_globals (yyscan_t yyscanner)$/;"	f	file:
yy_input_file	scanner.cc	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	scanner.cc	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	scanner.cc	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	scanner.cc	/^    char* yy_last_accepting_cpos;$/;"	m	struct:yyguts_t	file:
yy_last_accepting_state	scanner.cc	/^    yy_state_type yy_last_accepting_state;$/;"	m	struct:yyguts_t	file:
yy_load_buffer_state	scanner.cc	/^static void yy_load_buffer_state  (yyscan_t yyscanner)$/;"	f	file:
yy_lr_goto_state_	parser.cc	/^  parser::yy_lr_goto_state_ (state_type yystate, int yysym)$/;"	f	class:yy::parser
yy_meta	scanner.cc	/^static yyconst flex_int32_t yy_meta[59] =$/;"	v	file:
yy_more_flag	scanner.cc	/^    int yy_more_flag;$/;"	m	struct:yyguts_t	file:
yy_more_len	scanner.cc	/^    int yy_more_len;$/;"	m	struct:yyguts_t	file:
yy_n_chars	scanner.cc	/^	yy_size_t yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	scanner.cc	/^    yy_size_t yy_n_chars;$/;"	m	struct:yyguts_t	file:
yy_new_buffer	scanner.cc	/^#define yy_new_buffer /;"	d	file:
yy_nxt	scanner.cc	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	scanner.cc	/^static yyconst flex_int16_t yy_nxt[408] =$/;"	v	file:
yy_pact_value_is_default_	parser.cc	/^  parser::yy_pact_value_is_default_ (int yyvalue)$/;"	f	class:yy::parser
yy_print_	parser.cc	/^  parser::yy_print_ (std::ostream& yyo,$/;"	f	class:yy::parser
yy_reduce_print_	parser.cc	/^  parser::yy_reduce_print_ (int yyrule)$/;"	f	class:yy::parser
yy_rule_can_match_eol	scanner.cc	/^static yyconst flex_int32_t yy_rule_can_match_eol[88] =$/;"	v	file:
yy_scan_buffer	scanner.cc	/^YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)$/;"	f
yy_scan_bytes	scanner.cc	/^YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)$/;"	f
yy_scan_string	scanner.cc	/^YY_BUFFER_STATE yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)$/;"	f
yy_set_bol	scanner.cc	/^#define yy_set_bol(/;"	d	file:
yy_set_interactive	scanner.cc	/^#define yy_set_interactive(/;"	d	file:
yy_size_t	scanner.cc	/^typedef size_t yy_size_t;$/;"	t	file:
yy_start	scanner.cc	/^    int yy_start;$/;"	m	struct:yyguts_t	file:
yy_start_stack	scanner.cc	/^    int *yy_start_stack;$/;"	m	struct:yyguts_t	file:
yy_start_stack_depth	scanner.cc	/^    int yy_start_stack_depth;$/;"	m	struct:yyguts_t	file:
yy_start_stack_ptr	scanner.cc	/^    int yy_start_stack_ptr;$/;"	m	struct:yyguts_t	file:
yy_state_type	scanner.cc	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	scanner.cc	/^    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)$/;"	f
yy_table_value_is_error_	parser.cc	/^  parser::yy_table_value_is_error_ (int yyvalue)$/;"	f	class:yy::parser
yy_trans_info	scanner.cc	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	scanner.cc	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)$/;"	f	file:
yy_verify	scanner.cc	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalign_me	parser.hh	/^      long double yyalign_me;$/;"	m	union:yy::parser::semantic_type::__anon8
yyalloc	scanner.cc	/^void *yyalloc (yy_size_t  size , yyscan_t yyscanner)$/;"	f
yybuffer_	parser.hh	/^    } yybuffer_;$/;"	m	class:yy::parser::semantic_type	typeref:union:yy::parser::semantic_type::__anon8
yycdebug_	parser.hh	/^    std::ostream* yycdebug_;$/;"	m	class:yy::parser
yycheck_	parser.cc	/^  parser::yycheck_[] =$/;"	m	class:yy::parser	file:
yycheck_	parser.hh	/^  static const short yycheck_[];$/;"	m	class:yy::parser
yyclearin	parser.cc	/^#define yyclearin /;"	d	file:
yycolumn	scanner.cc	/^#define yycolumn /;"	d	file:
yyconst	scanner.cc	/^#define yyconst /;"	d	file:
yyconst	scanner.cc	/^#define yyconst$/;"	d	file:
yydebug_	parser.hh	/^    int yydebug_;$/;"	m	class:yy::parser
yydefact_	parser.cc	/^  parser::yydefact_[] =$/;"	m	class:yy::parser	file:
yydefact_	parser.hh	/^  static const unsigned char yydefact_[];$/;"	m	class:yy::parser
yydefgoto_	parser.cc	/^  parser::yydefgoto_[] =$/;"	m	class:yy::parser	file:
yydefgoto_	parser.hh	/^  static const short yydefgoto_[];$/;"	m	class:yy::parser
yyensure_buffer_stack	scanner.cc	/^static void yyensure_buffer_stack (yyscan_t yyscanner)$/;"	f	file:
yyeof_	parser.hh	/^      yyeof_ = 0,$/;"	e	enum:yy::parser::__anon11
yyerrcode_	parser.hh	/^      yyerrcode_ = 256,$/;"	e	enum:yy::parser::__anon11
yyerrok	parser.cc	/^#define yyerrok /;"	d	file:
yyextra	scanner.cc	/^#define yyextra /;"	d	file:
yyextra_r	scanner.cc	/^    YY_EXTRA_TYPE yyextra_r;$/;"	m	struct:yyguts_t	file:
yyfilename	ParserDriver.h	/^    const char* yyfilename = nullptr;$/;"	m	struct:souffle::scanner_data
yyfilename	scanner.cc	/^#define yyfilename /;"	d	file:
yyfinal_	parser.hh	/^      yyfinal_ = 3, \/\/\/< Termination state number.$/;"	e	enum:yy::parser::__anon11
yyfree	scanner.cc	/^void yyfree (void * ptr , yyscan_t yyscanner)$/;"	f
yyget_column	scanner.cc	/^int yyget_column  (yyscan_t yyscanner)$/;"	f
yyget_debug	scanner.cc	/^int yyget_debug  (yyscan_t yyscanner)$/;"	f
yyget_extra	scanner.cc	/^YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)$/;"	f
yyget_in	scanner.cc	/^FILE *yyget_in  (yyscan_t yyscanner)$/;"	f
yyget_leng	scanner.cc	/^yy_size_t yyget_leng  (yyscan_t yyscanner)$/;"	f
yyget_lineno	scanner.cc	/^int yyget_lineno  (yyscan_t yyscanner)$/;"	f
yyget_out	scanner.cc	/^FILE *yyget_out  (yyscan_t yyscanner)$/;"	f
yyget_text	scanner.cc	/^char *yyget_text  (yyscan_t yyscanner)$/;"	f
yyguts_t	scanner.cc	/^struct yyguts_t$/;"	s	file:
yyin	scanner.cc	/^#define yyin /;"	d	file:
yyin_r	scanner.cc	/^    FILE *yyin_r, *yyout_r;$/;"	m	struct:yyguts_t	file:
yyinput	scanner.cc	/^    static int yyinput (yyscan_t yyscanner)$/;"	f	file:
yylast_	parser.hh	/^      yylast_ = 1095,     \/\/\/< Last index in yytable_.$/;"	e	enum:yy::parser::__anon11
yyleng	scanner.cc	/^#define yyleng /;"	d	file:
yyleng_r	scanner.cc	/^    yy_size_t yyleng_r;$/;"	m	struct:yyguts_t	file:
yyless	scanner.cc	/^#define yyless(/;"	d	file:
yyless	scanner.cc	/^#undef yyless$/;"	d	file:
yylex_destroy	scanner.cc	/^int yylex_destroy  (yyscan_t yyscanner)$/;"	f
yylex_init	scanner.cc	/^int yylex_init(yyscan_t* ptr_yy_globals)$/;"	f
yylex_init_extra	scanner.cc	/^int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )$/;"	f
yylineno	scanner.cc	/^#define yylineno /;"	d	file:
yylineno_r	scanner.cc	/^    int yylineno_r;$/;"	m	struct:yyguts_t	file:
yylloc	ParserDriver.h	/^    SrcLocation yylloc;$/;"	m	struct:souffle::scanner_data
yylloc	scanner.cc	/^#define yylloc /;"	d	file:
yymore	scanner.cc	/^#define yymore(/;"	d	file:
yynnts_	parser.hh	/^      yynnts_ = 52,  \/\/\/< Number of nonterminal symbols.$/;"	e	enum:yy::parser::__anon11
yyntokens_	parser.hh	/^      yyntokens_ = 79  \/\/\/< Number of tokens.$/;"	e	enum:yy::parser::__anon11
yyout	scanner.cc	/^#define yyout /;"	d	file:
yyout_r	scanner.cc	/^    FILE *yyin_r, *yyout_r;$/;"	m	struct:yyguts_t	file:
yypact_	parser.cc	/^  parser::yypact_[] =$/;"	m	class:yy::parser	file:
yypact_	parser.hh	/^  static const short yypact_[];$/;"	m	class:yy::parser
yypact_ninf_	parser.cc	/^  const short parser::yypact_ninf_ = -203;$/;"	m	class:yy::parser	file:
yypact_ninf_	parser.hh	/^    static const short yypact_ninf_;$/;"	m	class:yy::parser
yypgoto_	parser.cc	/^  parser::yypgoto_[] =$/;"	m	class:yy::parser	file:
yypgoto_	parser.hh	/^  static const short yypgoto_[];$/;"	m	class:yy::parser
yypop_	parser.cc	/^  parser::yypop_ (int n)$/;"	f	class:yy::parser
yypop_buffer_state	scanner.cc	/^void yypop_buffer_state (yyscan_t yyscanner)$/;"	f
yypush_	parser.cc	/^  parser::yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym)$/;"	f	class:yy::parser
yypush_	parser.cc	/^  parser::yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym)$/;"	f	class:yy::parser
yypush_buffer_state	scanner.cc	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)$/;"	f
yyr1_	parser.cc	/^  parser::yyr1_[] =$/;"	m	class:yy::parser	file:
yyr1_	parser.hh	/^  static const unsigned char yyr1_[];$/;"	m	class:yy::parser
yyr2_	parser.cc	/^  parser::yyr2_[] =$/;"	m	class:yy::parser	file:
yyr2_	parser.hh	/^  static const unsigned char yyr2_[];$/;"	m	class:yy::parser
yyraw	parser.hh	/^      char yyraw[size];$/;"	m	union:yy::parser::semantic_type::__anon8
yyrealloc	scanner.cc	/^void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)$/;"	f
yyrestart	scanner.cc	/^    void yyrestart  (FILE * input_file , yyscan_t yyscanner)$/;"	f
yyrline_	parser.cc	/^  parser::yyrline_[] =$/;"	m	class:yy::parser	file:
yyrline_	parser.hh	/^  static const unsigned short yyrline_[];$/;"	m	class:yy::parser
yyscan_t	scanner.cc	/^typedef void* yyscan_t;$/;"	t	file:
yyscanner	parser.hh	/^    yyscan_t yyscanner;$/;"	m	class:yy::parser
yyset_column	scanner.cc	/^void yyset_column (int  column_no , yyscan_t yyscanner)$/;"	f
yyset_debug	scanner.cc	/^void yyset_debug (int  bdebug , yyscan_t yyscanner)$/;"	f
yyset_extra	scanner.cc	/^void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)$/;"	f
yyset_in	scanner.cc	/^void yyset_in (FILE *  in_str , yyscan_t yyscanner)$/;"	f
yyset_lineno	scanner.cc	/^void yyset_lineno (int  line_number , yyscan_t yyscanner)$/;"	f
yyset_out	scanner.cc	/^void yyset_out (FILE *  out_str , yyscan_t yyscanner)$/;"	f
yystack_	parser.hh	/^    stack_type yystack_;$/;"	m	class:yy::parser
yystack_print_	parser.cc	/^  parser::yystack_print_ ()$/;"	f	class:yy::parser
yystos_	parser.cc	/^  parser::yystos_[] =$/;"	m	class:yy::parser	file:
yystos_	parser.hh	/^  static const unsigned char yystos_[];$/;"	m	class:yy::parser
yysyntax_error_	parser.cc	/^  parser::yysyntax_error_ (state_type yystate, const symbol_type& yyla) const$/;"	f	class:yy::parser
yytable_	parser.cc	/^  parser::yytable_[] =$/;"	m	class:yy::parser	file:
yytable_	parser.hh	/^  static const short yytable_[];$/;"	m	class:yy::parser
yytable_ninf_	parser.cc	/^  const signed char parser::yytable_ninf_ = -29;$/;"	m	class:yy::parser	file:
yytable_ninf_	parser.hh	/^    static const signed char yytable_ninf_;$/;"	m	class:yy::parser
yyterminate	scanner.cc	/^#define yyterminate(/;"	d	file:
yyterror_	parser.hh	/^      yyterror_ = 1,$/;"	e	enum:yy::parser::__anon11
yytext	scanner.cc	/^#define yytext /;"	d	file:
yytext_ptr	scanner.cc	/^#define yytext_ptr /;"	d	file:
yytext_r	scanner.cc	/^    char *yytext_r;$/;"	m	struct:yyguts_t	file:
yytname_	parser.cc	/^  const parser::yytname_[] =$/;"	m	class:yy::parser	file:
yytname_	parser.hh	/^    static const char* const yytname_[];$/;"	m	class:yy::parser
yytnamerr_	parser.cc	/^  parser::yytnamerr_ (const char *yystr)$/;"	f	class:yy::parser
yytokentype	parser.hh	/^      enum yytokentype$/;"	g	struct:yy::parser::token
yytranslate_	parser.hh	/^  parser::yytranslate_ (token_type t)$/;"	f	class:yy::parser
yytypeid_	parser.hh	/^      , yytypeid_ (YY_NULLPTR)$/;"	f	class:yy::parser::semantic_type
yytypeid_	parser.hh	/^    const std::type_info *yytypeid_;$/;"	m	class:yy::parser::semantic_type
yywrap	scanner.cc	/^#define yywrap(/;"	d	file:
~EquivalenceRelation	EquivalenceRelation.h	/^    ~EquivalenceRelation() {$/;"	f	class:souffle::EquivalenceRelation
~Explain	Explain.h	/^    ~Explain() {$/;"	f	class:souffle::Explain
~Interpreter	Interpreter.h	/^    virtual ~Interpreter() {$/;"	f	class:souffle::Interpreter
~Lease	ParallelUtils.h	/^        ~Lease() {$/;"	f	struct:souffle::Lock::Lease
~Logger	Logger.h	/^    ~Logger() {$/;"	f	class:souffle::Logger
~LowLevelMachine	Interpreter.h	/^   virtual ~LowLevelMachine() {$/;"	f	class:souffle::LowLevelMachine
~PiggyList	PiggyList.h	/^    ~PiggyList() {$/;"	f	class:souffle::PiggyList
~ProfileEventSingleton	ProfileEvent.h	/^    ~ProfileEventSingleton() {$/;"	f	class:souffle::ProfileEventSingleton
~RandomInsertPiggyList	PiggyList.h	/^    ~RandomInsertPiggyList() {$/;"	f	class:souffle::RandomInsertPiggyList
~ScreenBuffer	ExplainTree.h	/^    ~ScreenBuffer() {$/;"	f	class:souffle::ScreenBuffer
~SparseArray	Brie.h	/^    ~SparseArray() {$/;"	f	class:souffle::SparseArray
~StringPool	StringPool.h	/^    ~StringPool() {$/;"	f	class:souffle::StringPool
~Table	Table.h	/^    ~Table() {$/;"	f	class:souffle::Table
~Trie	Brie.h	/^    ~Trie() {$/;"	f	class:souffle::Trie
~Tui	profile/Tui.h	/^    ~Tui() {$/;"	f	class:souffle::profile::Tui
~TypeEnvironment	TypeSystem.cpp	/^TypeEnvironment::~TypeEnvironment() {$/;"	f	class:souffle::TypeEnvironment
~basic_symbol	parser.hh	/^      ~basic_symbol ()$/;"	f	struct:yy::parser::basic_symbol
~btree	BTree.h	/^    ~btree() {$/;"	f	class:souffle::detail::btree
~iterator	SouffleInterface.h	/^        ~iterator() {$/;"	f	class:souffle::Relation::iterator
~node	BTree.h	/^        ~node() {$/;"	f	struct:souffle::detail::btree::node
~parser	parser.cc	/^  parser::~parser ()$/;"	f	class:yy::parser
~test_result	test/test.h	/^        ~test_result() {$/;"	f	struct:TestCase::test_result
