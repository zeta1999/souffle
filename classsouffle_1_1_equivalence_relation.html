<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle::EquivalenceRelation&lt; TupleType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">2.0.1-62-g772b0cb</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesouffle.html">souffle</a></li><li class="navelem"><a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">souffle::EquivalenceRelation&lt; TupleType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for souffle::EquivalenceRelation&lt; TupleType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1_equivalence_relation__coll__graph.png" border="0" usemap="#souffle_1_1_equivalence_relation_3_01_tuple_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="souffle_1_1_equivalence_relation_3_01_tuple_type_01_4_coll__map" id="souffle_1_1_equivalence_relation_3_01_tuple_type_01_4_coll__map">
<area shape="rect" id="node3" href="classsouffle_1_1_lambda_b_tree_set.html" title="{souffle::LambdaBTreeSet\l\&lt; StorePair, std::function\l\&lt; StatesBucket(StorePair\l &amp;)\&gt;, souffle::EqrelMapComparator\l\&lt; StorePair \&gt; \&gt;\n||+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ operator=()\l+ load()\l&#45; LambdaBTreeSet()\l}" alt="" coords="885,2531,1135,2755"/>
<area shape="rect" id="node4" href="classsouffle_1_1detail_1_1_lambda_b_tree.html" title="{souffle::detail::LambdaBTree\l\&lt; StorePair, souffle::EqrelMapComparator\l\&lt; StorePair \&gt;, std::allocator\&lt; StorePair\l \&gt;, 256, typename detail::default_strategy\l\&lt; StorePair \&gt;::type, true, std::function\l\&lt; StatesBucket(StorePair &amp;)\&gt; \&gt;\n||+ insert()\l+ insert()\l+ insert()\l+ LambdaBTree()\l+ operator!=()\l+ operator=()\l+ operator==()\l+ swap()\l}" alt="" coords="1378,2020,1677,2273"/>
<area shape="rect" id="node5" href="classsouffle_1_1detail_1_1btree.html" title="{souffle::detail::btree\l\&lt; StorePair, souffle::\lEqrelMapComparator\&lt; StorePair\l \&gt;, std::allocator\&lt; StorePair\l \&gt;, blockSize, typename detail\l::default_strategy\&lt; StorePair \&gt;\l::type, isSet, souffle::EqrelMapComparator\l\&lt; StorePair \&gt;, detail::updater\&lt; StorePair \&gt; \&gt;\n||+ begin()\l+ btree()\l+ btree()\l+ btree()\l+ btree()\l+ check()\l+ clear()\l+ contains()\l+ contains()\l+ empty()\land 23 more...\l+ load()\l# btree()\l# covers()\l# equal()\l# less()\l# update()\l# weak_covers()\l# weak_equal()\l# weak_less()\l&#45; coversUpperBound()\l&#45; buildSubTree()\l}" alt="" coords="2449,1192,2765,1680"/>
<area shape="rect" id="node6" href="structsouffle_1_1detail_1_1btree_1_1hint__statistics.html" title="{souffle::detail::btree\l\&lt; Key, Comparator, Allocator,\l blockSize, SearchStrategy,\l isSet, WeakComparator, Updater\l \&gt;::hint_statistics\n||}" alt="" coords="1601,674,1840,810"/>
<area shape="rect" id="node24" href="classsouffle_1_1detail_1_1btree.html" title="{souffle::detail::btree\l\&lt; PairStore, EqrelMapComparator\l\&lt; PairStore \&gt;, std::allocator\l\&lt; PairStore \&gt;, blockSize, typename\l detail::default_strategy\&lt; PairStore\l \&gt;::type, isSet, EqrelMapComparator\l\&lt; PairStore \&gt;, detail::updater\&lt; PairStore \&gt; \&gt;\n||+ begin()\l+ btree()\l+ btree()\l+ btree()\l+ btree()\l+ check()\l+ clear()\l+ contains()\l+ contains()\l+ empty()\land 23 more...\l+ load()\l# btree()\l# covers()\l# equal()\l# less()\l# update()\l# weak_covers()\l# weak_equal()\l# weak_less()\l&#45; coversUpperBound()\l&#45; buildSubTree()\l}" alt="" coords="1377,1199,1693,1673"/>
<area shape="rect" id="node7" href="classsouffle_1_1_cache_access_counter.html" title="cache hits/misses. " alt="" coords="1910,292,2121,472"/>
<area shape="rect" id="node8" href="structsouffle_1_1detail_1_1btree_1_1leaf__node.html" title="The data type representing leaf nodes of the b&#45;tree. " alt="" coords="1864,674,2103,810"/>
<area shape="rect" id="node9" href="structsouffle_1_1detail_1_1btree_1_1node.html" title="The actual, generic node implementation covering the operations for both, inner and leaf nodes..." alt="" coords="1591,233,1885,531"/>
<area shape="rect" id="node10" href="structsouffle_1_1detail_1_1btree_1_1base.html" title="The base type of all node types containing essential book&#45;keeping information. " alt="" coords="1194,645,1487,839"/>
<area shape="rect" id="node29" href="classsouffle_1_1_random_insert_piggy_list.html" title="{souffle::RandomInsertPiggy\lList\&lt; value_type \&gt;\n||+ clear()\l+ freeList()\l+ get()\l+ getBlock()\l+ insertAt()\l+ operator=()\l+ operator=()\l+ RandomInsertPiggyList()\l+ RandomInsertPiggyList()\l+ RandomInsertPiggyList()\l+ RandomInsertPiggyList()\l+ size()\l+ ~RandomInsertPiggyList()\l}" alt="" coords="573,248,781,516"/>
<area shape="rect" id="node34" href="classsouffle_1_1_piggy_list.html" title="{souffle::PiggyList\l\&lt; std::atomic\&lt; block_t \&gt; \&gt;\n||+ append()\l+ begin()\l+ clear()\l+ createNode()\l+ end()\l+ freeList()\l+ get()\l+ getBlock()\l+ operator=()\l+ PiggyList()\l+ PiggyList()\l+ PiggyList()\l+ PiggyList()\l+ size()\l+ ~PiggyList()\l}" alt="" coords="226,233,429,531"/>
<area shape="rect" id="node15" href="structsouffle_1_1detail_1_1updater.html" title="{souffle::detail::updater\l\&lt; StorePair \&gt;\n||+ update()\l}" alt="" coords="2724,696,2893,788"/>
<area shape="rect" id="node16" href="classsouffle_1_1_eqrel_map_comparator_3_01_store_pair_01_4.html" title="{EqrelMapComparator\l\&lt; StorePair \&gt;\n||}" alt="" coords="2917,696,3076,788"/>
<area shape="rect" id="node17" href="classsouffle_1_1_optimistic_read_write_lock.html" title="A &#39;sequential&#39; non&#45;locking implementation for an optimistic r/w lock. " alt="" coords="2322,637,2559,847"/>
<area shape="rect" id="node18" href="structsouffle_1_1detail_1_1default__strategy.html" title="{souffle::detail::default\l_strategy\&lt; StorePair \&gt;\n||}" alt="" coords="3101,696,3271,788"/>
<area shape="rect" id="node19" href="structsouffle_1_1detail_1_1binary.html" title="{souffle::detail::binary\n||}" alt="" coords="2831,343,2991,421"/>
<area shape="rect" id="node25" href="structsouffle_1_1detail_1_1default__strategy.html" title="{souffle::detail::default\l_strategy\&lt; PairStore \&gt;\n||}" alt="" coords="2127,696,2298,788"/>
<area shape="rect" id="node20" href="structsouffle_1_1detail_1_1strategy__selection.html" title="{souffle::detail::strategy\l_selection\&lt; binary_search \&gt;\n||}" alt="" coords="2807,20,3016,112"/>
<area shape="rect" id="node21" href="classsouffle_1_1_sparse_disjoint_set.html" title="{souffle::SparseDisjointSet\l\&lt; value_type \&gt;\n||+ clear()\l+ contains()\l+ findNode()\l+ makeNode()\l+ nodeExists()\l+ operator=()\l+ operator=()\l+ sameSet()\l+ size()\l+ SparseDisjointSet()\l+ SparseDisjointSet()\l+ SparseDisjointSet()\l+ toDense()\l+ toSparse()\l+ unionNodes()\l}" alt="" coords="582,2779,771,3076"/>
<area shape="rect" id="node22" href="classsouffle_1_1_lambda_b_tree_set.html" title="{souffle::LambdaBTreeSet\l\&lt; PairStore, std::function\l\&lt; parent_t(PairStore &amp;)\&gt;,\l EqrelMapComparator\&lt; PairStore \&gt; \&gt;\n||+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ LambdaBTreeSet()\l+ operator=()\l+ load()\l&#45; LambdaBTreeSet()\l}" alt="" coords="727,2297,994,2507"/>
<area shape="rect" id="node23" href="classsouffle_1_1detail_1_1_lambda_b_tree.html" title="{souffle::detail::LambdaBTree\l\&lt; PairStore, EqrelMapComparator\l\&lt; PairStore \&gt;, std::allocator\l\&lt; PairStore \&gt;, 256, typename detail\l::default_strategy\&lt; PairStore \&gt;::type,\l true, std::function\&lt; parent_t(PairStore &amp;)\&gt; \&gt;\n||+ insert()\l+ insert()\l+ insert()\l+ LambdaBTree()\l+ operator!=()\l+ operator=()\l+ operator==()\l+ swap()\l}" alt="" coords="1045,1743,1364,1996"/>
<area shape="rect" id="node26" href="structsouffle_1_1_eqrel_map_comparator.html" title="{souffle::EqrelMapComparator\l\&lt; PairStore \&gt;\n||+ equal()\l+ less()\l+ operator()()\l}" alt="" coords="714,681,925,803"/>
<area shape="rect" id="node27" href="structsouffle_1_1detail_1_1updater.html" title="{souffle::detail::updater\l\&lt; PairStore \&gt;\n||+ update()\l}" alt="" coords="949,696,1119,788"/>
<area shape="rect" id="node30" href="classstd_1_1array_3_01std_1_1atomic_3_01value__type_01_5_01_4_00_01max_containers_01_4.html" title="{array\&lt; std::atomic\l\&lt; value_type * \&gt;, maxContainers \&gt;\n||}" alt="" coords="679,20,936,112"/>
<area shape="rect" id="node32" href="classsouffle_1_1_spin_lock.html" title="A &#39;sequential&#39; non&#45;locking implementation for a spin lock. " alt="" coords="267,5,399,127"/>
<area shape="rect" id="node33" href="classsouffle_1_1_disjoint_set.html" title="Structure that emulates a Disjoint Set, i.e. " alt="" coords="297,871,443,1168"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of operation hints speeding up some of the involved operations by exploiting temporal locality.  <a href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaac8ab699f542087d162752045bcb2d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#aaac8ab699f542087d162752045bcb2d3">element_type</a> = TupleType</td></tr>
<tr class="separator:aaac8ab699f542087d162752045bcb2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b2110f260423ec60353ef2b23f38266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">anteriorIt</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> anteriorVal) const</td></tr>
<tr class="memdesc:a3b2110f260423ec60353ef2b23f38266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that generates all pairs (A, X) for a given A, and X are elements within A's disjoint set.  <a href="#a3b2110f260423ec60353ef2b23f38266">More...</a><br /></td></tr>
<tr class="separator:a3b2110f260423ec60353ef2b23f38266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780aae54f493cbeee17db06f9166dd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a780aae54f493cbeee17db06f9166dd06">antpostit</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> anteriorVal, <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> posteriorVal) const</td></tr>
<tr class="memdesc:a780aae54f493cbeee17db06f9166dd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that generates the pair (A, B) for a given A and B.  <a href="#a780aae54f493cbeee17db06f9166dd06">More...</a><br /></td></tr>
<tr class="separator:a780aae54f493cbeee17db06f9166dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7f0c4be48aef1557027696c5509b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">begin</a> () const</td></tr>
<tr class="memdesc:a1d7f0c4be48aef1557027696c5509b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator pointing to the beginning of the tuples, with no restrictions  <a href="#a1d7f0c4be48aef1557027696c5509b7c">More...</a><br /></td></tr>
<tr class="separator:a1d7f0c4be48aef1557027696c5509b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed1091422ee726f11f09b0c900c303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a84ed1091422ee726f11f09b0c900c303">clear</a> ()</td></tr>
<tr class="memdesc:a84ed1091422ee726f11f09b0c900c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the relation.  <a href="#a84ed1091422ee726f11f09b0c900c303">More...</a><br /></td></tr>
<tr class="separator:a84ed1091422ee726f11f09b0c900c303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8099eb6b5846ccf01168eb1a82342003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a8099eb6b5846ccf01168eb1a82342003">closure</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> rep) const</td></tr>
<tr class="memdesc:a8099eb6b5846ccf01168eb1a82342003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin an iterator over all pairs within a single disjoint set - This is used for <a class="el" href="classsouffle_1_1_equivalence_relation.html#a3fbff12268dd7701a161a5cfe05d47d6" title="Generate an approximate number of iterators for parallel iteration The iterators returned are not nec...">partition()</a>.  <a href="#a8099eb6b5846ccf01168eb1a82342003">More...</a><br /></td></tr>
<tr class="separator:a8099eb6b5846ccf01168eb1a82342003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad250eaaace5ec907cfdfeaf57d05957a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#ad250eaaace5ec907cfdfeaf57d05957a">contains</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> x, <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> y) const</td></tr>
<tr class="memdesc:ad250eaaace5ec907cfdfeaf57d05957a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there exists a pair with these two nodes.  <a href="#ad250eaaace5ec907cfdfeaf57d05957a">More...</a><br /></td></tr>
<tr class="separator:ad250eaaace5ec907cfdfeaf57d05957a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42a6f9fa3c64684f109bfabb780cf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a9e42a6f9fa3c64684f109bfabb780cf1">contains</a> (const TupleType &amp;<a class="el" href="classsouffle_1_1tuple.html">tuple</a>, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;) const</td></tr>
<tr class="memdesc:a9e42a6f9fa3c64684f109bfabb780cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there exists given tuple.  <a href="#a9e42a6f9fa3c64684f109bfabb780cf1">More...</a><br /></td></tr>
<tr class="separator:a9e42a6f9fa3c64684f109bfabb780cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e87898f4ee6c8c8a6be9f3a0e6892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a588e87898f4ee6c8c8a6be9f3a0e6892">empty</a> () const</td></tr>
<tr class="memdesc:a588e87898f4ee6c8c8a6be9f3a0e6892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check emptiness.  <a href="#a588e87898f4ee6c8c8a6be9f3a0e6892">More...</a><br /></td></tr>
<tr class="separator:a588e87898f4ee6c8c8a6be9f3a0e6892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d475db863fbcf356f7f4e8a2e54666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">emptyPartition</a> () const</td></tr>
<tr class="separator:a23d475db863fbcf356f7f4e8a2e54666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ed88b84bb2364ad962d899352b69d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a> () const</td></tr>
<tr class="memdesc:a17ed88b84bb2364ad962d899352b69d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator pointing to the end of the tuples  <a href="#a17ed88b84bb2364ad962d899352b69d2">More...</a><br /></td></tr>
<tr class="separator:a17ed88b84bb2364ad962d899352b69d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeef9e64f9db4dbc2c2650b1d7ece15a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#aaeef9e64f9db4dbc2c2650b1d7ece15a">EquivalenceRelation</a> ()</td></tr>
<tr class="separator:aaeef9e64f9db4dbc2c2650b1d7ece15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb23552f6468ff537022e84f0d12f09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#aeb23552f6468ff537022e84f0d12f09e">extend</a> (const <a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a>&lt; TupleType &gt; &amp;other)</td></tr>
<tr class="memdesc:aeb23552f6468ff537022e84f0d12f09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend this relation with another relation, expanding this equivalence relation The supplied relation is the old knowledge, whilst this relation only contains explicitly new knowledge.  <a href="#aeb23552f6468ff537022e84f0d12f09e">More...</a><br /></td></tr>
<tr class="separator:aeb23552f6468ff537022e84f0d12f09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f226e19af7060cfae7ba93d28ff6abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a8f226e19af7060cfae7ba93d28ff6abd">find</a> (const TupleType &amp;, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;) const</td></tr>
<tr class="separator:a8f226e19af7060cfae7ba93d28ff6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dca800579ac4cc5e473755f9fc3f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a01dca800579ac4cc5e473755f9fc3f46">find</a> (const TupleType &amp;t) const</td></tr>
<tr class="separator:a01dca800579ac4cc5e473755f9fc3f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdad96b7ba875be9bc72b84653035426"><td class="memTemplParams" colspan="2">template&lt;unsigned levels&gt; </td></tr>
<tr class="memitem:acdad96b7ba875be9bc72b84653035426"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1range.html">range</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#acdad96b7ba875be9bc72b84653035426">getBoundaries</a> (const TupleType &amp;entry) const</td></tr>
<tr class="memdesc:acdad96b7ba875be9bc72b84653035426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a range of elements matching the prefix of the given entry up to levels elements.  <a href="#acdad96b7ba875be9bc72b84653035426">More...</a><br /></td></tr>
<tr class="separator:acdad96b7ba875be9bc72b84653035426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180e142355bd6ea5be1677c1f19a9b77"><td class="memTemplParams" colspan="2">template&lt;unsigned levels&gt; </td></tr>
<tr class="memitem:a180e142355bd6ea5be1677c1f19a9b77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1range.html">range</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a180e142355bd6ea5be1677c1f19a9b77">getBoundaries</a> (const TupleType &amp;entry, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;) const</td></tr>
<tr class="memdesc:a180e142355bd6ea5be1677c1f19a9b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a range of elements matching the prefix of the given entry up to levels elements.  <a href="#a180e142355bd6ea5be1677c1f19a9b77">More...</a><br /></td></tr>
<tr class="separator:a180e142355bd6ea5be1677c1f19a9b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725decc989a5f638cf8780a68ebdb93c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">insert</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> x, <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> y)</td></tr>
<tr class="memdesc:a725decc989a5f638cf8780a68ebdb93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the two values symbolically as a binary relation.  <a href="#a725decc989a5f638cf8780a68ebdb93c">More...</a><br /></td></tr>
<tr class="separator:a725decc989a5f638cf8780a68ebdb93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0659da55bb4acf41d3af5c3a81f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a13b0659da55bb4acf41d3af5c3a81f83">insert</a> (const TupleType &amp;<a class="el" href="classsouffle_1_1tuple.html">tuple</a>)</td></tr>
<tr class="memdesc:a13b0659da55bb4acf41d3af5c3a81f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the tuple symbolically.  <a href="#a13b0659da55bb4acf41d3af5c3a81f83">More...</a><br /></td></tr>
<tr class="separator:a13b0659da55bb4acf41d3af5c3a81f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8882d09a61a8418b683b3c63c0aff10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#ac8882d09a61a8418b683b3c63c0aff10">insert</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> x, <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> y, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a>)</td></tr>
<tr class="memdesc:ac8882d09a61a8418b683b3c63c0aff10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the two values symbolically as a binary relation.  <a href="#ac8882d09a61a8418b683b3c63c0aff10">More...</a><br /></td></tr>
<tr class="separator:ac8882d09a61a8418b683b3c63c0aff10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ff503b846eb60a89c3bc303db6f461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a49ff503b846eb60a89c3bc303db6f461">insertAll</a> (const <a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a>&lt; TupleType &gt; &amp;other)</td></tr>
<tr class="memdesc:a49ff503b846eb60a89c3bc303db6f461"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts all nodes from the other relation into this one  <a href="#a49ff503b846eb60a89c3bc303db6f461">More...</a><br /></td></tr>
<tr class="separator:a49ff503b846eb60a89c3bc303db6f461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4edbc62be51b13156fde774d9a771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a6da4edbc62be51b13156fde774d9a771">lower_bound</a> (const TupleType &amp;entry, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;) const</td></tr>
<tr class="memdesc:a6da4edbc62be51b13156fde774d9a771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act similar to getBoundaries.  <a href="#a6da4edbc62be51b13156fde774d9a771">More...</a><br /></td></tr>
<tr class="separator:a6da4edbc62be51b13156fde774d9a771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbff12268dd7701a161a5cfe05d47d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structsouffle_1_1range.html">souffle::range</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a3fbff12268dd7701a161a5cfe05d47d6">partition</a> (size_t chunks) const</td></tr>
<tr class="memdesc:a3fbff12268dd7701a161a5cfe05d47d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an approximate number of iterators for parallel iteration The iterators returned are not necessarily equal in size, but in practise are approximately similarly sized Depending on the structure of the data, there can be more or less partitions returned than requested.  <a href="#a3fbff12268dd7701a161a5cfe05d47d6">More...</a><br /></td></tr>
<tr class="separator:a3fbff12268dd7701a161a5cfe05d47d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555b07b774a103285669cca091c8dbdc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">size</a> () const</td></tr>
<tr class="memdesc:a555b07b774a103285669cca091c8dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of relation.  <a href="#a555b07b774a103285669cca091c8dbdc">More...</a><br /></td></tr>
<tr class="separator:a555b07b774a103285669cca091c8dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116e1fea52d021460197a9629822e33f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a116e1fea52d021460197a9629822e33f">upper_bound</a> (const TupleType &amp;, <a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;) const</td></tr>
<tr class="memdesc:a116e1fea52d021460197a9629822e33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only here in order to unify interfaces in <a class="el" href="classsouffle_1_1_interpreter_index.html" title="An index is an abstraction of a data structure. ">InterpreterIndex</a>.  <a href="#a116e1fea52d021460197a9629822e33f">More...</a><br /></td></tr>
<tr class="separator:a116e1fea52d021460197a9629822e33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eaaa7641cb0fb2f65332023a3941b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#ad9eaaa7641cb0fb2f65332023a3941b6">~EquivalenceRelation</a> ()</td></tr>
<tr class="separator:ad9eaaa7641cb0fb2f65332023a3941b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6a2a3c23169d3deb3aeb7fe15e56af26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a6a2a3c23169d3deb3aeb7fe15e56af26">containsElement</a> (<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> <a class="el" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a>) const</td></tr>
<tr class="separator:a6a2a3c23169d3deb3aeb7fe15e56af26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af8e7c6c6040cbf05d3caee0c758add13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a> = <a class="el" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a> *</td></tr>
<tr class="separator:af8e7c6c6040cbf05d3caee0c758add13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46699abae586ff76589cf15b3bf87520"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a> = <a class="el" href="classsouffle_1_1_piggy_list.html">souffle::PiggyList</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> &gt;</td></tr>
<tr class="separator:a46699abae586ff76589cf15b3bf87520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f4d1f2f7cb7ec1d1e2afa9e0f7e325"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a11f4d1f2f7cb7ec1d1e2afa9e0f7e325">StatesMap</a> = <a class="el" href="classsouffle_1_1_lambda_b_tree_set.html">souffle::LambdaBTreeSet</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a>, std::function&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a>(<a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a> &amp;)&gt;, <a class="el" href="structsouffle_1_1_eqrel_map_comparator.html">souffle::EqrelMapComparator</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a> &gt; &gt;</td></tr>
<tr class="separator:a11f4d1f2f7cb7ec1d1e2afa9e0f7e325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488232b36e1bacff97b19d948ea0354b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a> = std::pair&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>, <a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a> &gt;</td></tr>
<tr class="separator:a488232b36e1bacff97b19d948ea0354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436e869049ecd4f92c96576e47ceaf04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> = typename TupleType::value_type</td></tr>
<tr class="separator:a436e869049ecd4f92c96576e47ceaf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af098f80e3fd13dbf9bab83353a442614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a> () const</td></tr>
<tr class="memdesc:af098f80e3fd13dbf9bab83353a442614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a cache of the sets such that they can be iterated over efficiently.  <a href="#af098f80e3fd13dbf9bab83353a442614">More...</a><br /></td></tr>
<tr class="separator:af098f80e3fd13dbf9bab83353a442614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a930683e4395ebc703c21f9fba49be069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a11f4d1f2f7cb7ec1d1e2afa9e0f7e325">StatesMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a></td></tr>
<tr class="separator:a930683e4395ebc703c21f9fba49be069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3759a97afd524c6b08662740ccb33138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_sparse_disjoint_set.html">souffle::SparseDisjointSet</a>&lt; <a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a></td></tr>
<tr class="separator:a3759a97afd524c6b08662740ccb33138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ffe1d9bf1a1fccd71795c7085ef6dc"><td class="memItemLeft" align="right" valign="top">std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a></td></tr>
<tr class="separator:ac2ffe1d9bf1a1fccd71795c7085ef6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa914456b63481b450a3f3979dac962dc"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a></td></tr>
<tr class="separator:aa914456b63481b450a3f3979dac962dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TupleType&gt;<br />
class souffle::EquivalenceRelation&lt; TupleType &gt;</h3>


<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00042">42</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaac8ab699f542087d162752045bcb2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac8ab699f542087d162752045bcb2d3">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#aaac8ab699f542087d162752045bcb2d3">element_type</a> =  TupleType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00054">54</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<a id="af8e7c6c6040cbf05d3caee0c758add13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e7c6c6040cbf05d3caee0c758add13">&#9670;&nbsp;</a></span>StatesBucket</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a> =  <a class="el" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a>*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00048">48</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<a id="a46699abae586ff76589cf15b3bf87520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46699abae586ff76589cf15b3bf87520">&#9670;&nbsp;</a></span>StatesList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a> =  <a class="el" href="classsouffle_1_1_piggy_list.html">souffle::PiggyList</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00047">47</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<a id="a11f4d1f2f7cb7ec1d1e2afa9e0f7e325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f4d1f2f7cb7ec1d1e2afa9e0f7e325">&#9670;&nbsp;</a></span>StatesMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#a11f4d1f2f7cb7ec1d1e2afa9e0f7e325">StatesMap</a> =  <a class="el" href="classsouffle_1_1_lambda_b_tree_set.html">souffle::LambdaBTreeSet</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a>, std::function&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a>(<a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a>&amp;)&gt;, <a class="el" href="structsouffle_1_1_eqrel_map_comparator.html">souffle::EqrelMapComparator</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00051">51</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<a id="a488232b36e1bacff97b19d948ea0354b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488232b36e1bacff97b19d948ea0354b">&#9670;&nbsp;</a></span>StorePair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a> =  std::pair&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>, <a class="el" href="classsouffle_1_1_equivalence_relation.html#af8e7c6c6040cbf05d3caee0c758add13">StatesBucket</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00049">49</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<a id="a436e869049ecd4f92c96576e47ceaf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436e869049ecd4f92c96576e47ceaf04">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> =  typename TupleType::value_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00043">43</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaeef9e64f9db4dbc2c2650b1d7ece15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeef9e64f9db4dbc2c2650b1d7ece15a">&#9670;&nbsp;</a></span>EquivalenceRelation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::<a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00056">56</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;: <a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>(<span class="keyword">false</span>){};</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_aa914456b63481b450a3f3979dac962dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">souffle::EquivalenceRelation::statesMapStale</a></div><div class="ttdeci">std::atomic&lt; bool &gt; statesMapStale</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00694">EquivalenceRelation.h:694</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9eaaa7641cb0fb2f65332023a3941b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eaaa7641cb0fb2f65332023a3941b6">&#9670;&nbsp;</a></span>~EquivalenceRelation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::~<a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00057">57</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                           {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">emptyPartition</a>();</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a23d475db863fbcf356f7f4e8a2e54666"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">souffle::EquivalenceRelation::emptyPartition</a></div><div class="ttdeci">void emptyPartition() const</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00195">EquivalenceRelation.h:195</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b2110f260423ec60353ef2b23f38266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2110f260423ec60353ef2b23f38266">&#9670;&nbsp;</a></span>anteriorIt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::anteriorIt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>anteriorVal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that generates all pairs (A, X) for a given A, and X are elements within A's disjoint set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anteriorVal</td><td>The first value of the tuple to be generated for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00582">582</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00491">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00530">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                                                      {</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        <span class="comment">// locate the blocklist that the anterior val resides in</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keyword">auto</span> found = <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">find</a>({<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">findNode</a>(anteriorVal), <span class="keyword">nullptr</span>});</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        assert(found != <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">end</a>() &amp;&amp; <span class="stringliteral">&quot;iterator called on partition that doesn&#39;t exist&quot;</span>);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        <span class="keywordflow">return</span> iterator(<span class="keyword">this</span>, anteriorVal, (*found).second);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1detail_1_1btree_html_af6b96ea0b32c7cbe5f39c1c8a572aba9"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">souffle::detail::btree::find</a></div><div class="ttdeci">iterator find(const Key &amp;k) const</div><div class="ttdoc">Locates the given key within this tree and returns an iterator referencing its position. </div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01748">BTree.h:1748</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a60befefe2180d86a72de7de7c66296a4"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">souffle::detail::btree::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01705">BTree.h:1705</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_abd1e9f67b7e370f9d21624429cdc55c1"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">souffle::SparseDisjointSet::findNode</a></div><div class="ttdeci">SparseDomain findNode(SparseDomain x)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00317">UnionFind.h:317</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a780aae54f493cbeee17db06f9166dd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780aae54f493cbeee17db06f9166dd06">&#9670;&nbsp;</a></span>antpostit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::antpostit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>anteriorVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>posteriorVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that generates the pair (A, B) for a given A and B. </p>
<p>If A and B don't exist, or aren't in the same set, then the <a class="el" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2" title="iterator pointing to the end of the tuples ">end()</a> iterator is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anteriorVal</td><td>the A value of the tuple </td></tr>
    <tr><td class="paramname">posteriorVal</td><td>the B value of the tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing this </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00600">600</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00491">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00530">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>.</p>
<div class="fragment"><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                                                                              {</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <span class="comment">// obv if they&#39;re in diff sets, then iteration for this pair just ends.</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a59c337fad02a3b8cb5f7d7982d0a8cf3">sameSet</a>(anteriorVal, posteriorVal)) <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>();</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        <span class="comment">// locate the blocklist that the val resides in</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keyword">auto</span> found = <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">find</a>({<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">findNode</a>(posteriorVal), <span class="keyword">nullptr</span>});</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        assert(found != <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">end</a>() &amp;&amp; <span class="stringliteral">&quot;iterator called on partition that doesn&#39;t exist&quot;</span>);</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        <span class="keywordflow">return</span> iterator(<span class="keyword">this</span>, anteriorVal, posteriorVal, (*found).second);</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1detail_1_1btree_html_af6b96ea0b32c7cbe5f39c1c8a572aba9"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">souffle::detail::btree::find</a></div><div class="ttdeci">iterator find(const Key &amp;k) const</div><div class="ttdoc">Locates the given key within this tree and returns an iterator referencing its position. </div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01748">BTree.h:1748</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a60befefe2180d86a72de7de7c66296a4"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">souffle::detail::btree::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01705">BTree.h:1705</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a59c337fad02a3b8cb5f7d7982d0a8cf3"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a59c337fad02a3b8cb5f7d7982d0a8cf3">souffle::SparseDisjointSet::sameSet</a></div><div class="ttdeci">bool sameSet(SparseDomain x, SparseDomain y)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00313">UnionFind.h:313</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_abd1e9f67b7e370f9d21624429cdc55c1"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">souffle::SparseDisjointSet::findNode</a></div><div class="ttdeci">SparseDomain findNode(SparseDomain x)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00317">UnionFind.h:317</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d7f0c4be48aef1557027696c5509b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7f0c4be48aef1557027696c5509b7c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterator pointing to the beginning of the tuples, with no restrictions </p>
<dl class="section return"><dt>Returns</dt><dd>the iterator that corresponds to the beginning of the binary relation </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00453">453</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00669">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::find()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00491">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00530">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, and <a class="el" href="binary__relation__test_8cpp_source.html#l00098">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                           {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        <span class="keywordflow">return</span> iterator(<span class="keyword">this</span>);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a84ed1091422ee726f11f09b0c900c303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ed1091422ee726f11f09b0c900c303">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the relation. </p>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00209">209</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="binary__relation__test_8cpp_source.html#l00282">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                 {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.lock();</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#af6be0a45267d1dfd12ce62428b3719ef">clear</a>();</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">emptyPartition</a>();</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.unlock();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a23d475db863fbcf356f7f4e8a2e54666"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">souffle::EquivalenceRelation::emptyPartition</a></div><div class="ttdeci">void emptyPartition() const</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00195">EquivalenceRelation.h:195</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_af6be0a45267d1dfd12ce62428b3719ef"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#af6be0a45267d1dfd12ce62428b3719ef">souffle::SparseDisjointSet::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Remove all elements from this disjoint set. </div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00332">UnionFind.h:332</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_ac2ffe1d9bf1a1fccd71795c7085ef6dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">souffle::EquivalenceRelation::statesLock</a></div><div class="ttdeci">std::shared_mutex statesLock</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00690">EquivalenceRelation.h:690</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8099eb6b5846ccf01168eb1a82342003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8099eb6b5846ccf01168eb1a82342003">&#9670;&nbsp;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin an iterator over all pairs within a single disjoint set - This is used for <a class="el" href="classsouffle_1_1_equivalence_relation.html#a3fbff12268dd7701a161a5cfe05d47d6" title="Generate an approximate number of iterators for parallel iteration The iterators returned are not nec...">partition()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>the representative of (or element within) a disjoint set of which to generate all pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator that will generate all pairs within the disjoint set </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00618">618</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                                           {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        <span class="comment">// locate the blocklist that the val resides in</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        <span class="keyword">auto</span> found = <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">find</a>({<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">findNode</a>(rep), <span class="keyword">nullptr</span>});</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        <span class="keywordflow">return</span> iterator(<span class="keyword">this</span>, (*found).second);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1detail_1_1btree_html_af6b96ea0b32c7cbe5f39c1c8a572aba9"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#af6b96ea0b32c7cbe5f39c1c8a572aba9">souffle::detail::btree::find</a></div><div class="ttdeci">iterator find(const Key &amp;k) const</div><div class="ttdoc">Locates the given key within this tree and returns an iterator referencing its position. </div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01748">BTree.h:1748</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_abd1e9f67b7e370f9d21624429cdc55c1"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">souffle::SparseDisjointSet::findNode</a></div><div class="ttdeci">SparseDomain findNode(SparseDomain x)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00317">UnionFind.h:317</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad250eaaace5ec907cfdfeaf57d05957a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad250eaaace5ec907cfdfeaf57d05957a">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there exists a pair with these two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>front of pair </td></tr>
    <tr><td class="paramname">y</td><td>back of pair </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00183">183</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00191">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::contains()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00100">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insert()</a>, and <a class="el" href="binary__relation__test_8cpp_source.html#l00047">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                                                    {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">contains</a>(x, y);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a56160b019e1d2ab013e2917422d141c7"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">souffle::SparseDisjointSet::contains</a></div><div class="ttdeci">bool contains(SparseDomain v1, SparseDomain v2)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00349">UnionFind.h:349</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e42a6f9fa3c64684f109bfabb780cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e42a6f9fa3c64684f109bfabb780cf1">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there exists given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>The tuple to search for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00191">191</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                                                  {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#ad250eaaace5ec907cfdfeaf57d05957a">contains</a>(tuple[0], tuple[1]);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    };</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_ad250eaaace5ec907cfdfeaf57d05957a"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#ad250eaaace5ec907cfdfeaf57d05957a">souffle::EquivalenceRelation::contains</a></div><div class="ttdeci">bool contains(value_type x, value_type y) const</div><div class="ttdoc">Returns whether there exists a pair with these two nodes. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00183">EquivalenceRelation.h:183</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a2a3c23169d3deb3aeb7fe15e56af26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a3c23169d3deb3aeb7fe15e56af26">&#9670;&nbsp;</a></span>containsElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::containsElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00680">680</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>.</p>
<div class="fragment"><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                                             {</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        <span class="keywordflow">return</span> this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">nodeExists</a>(<a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a>);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    }</div><div class="ttc" id="html_js_chartist_min_8h_html_af6814cb38d86f56d30772f562eaee28e"><div class="ttname"><a href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter e</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_affb10cb03598014138ae497eadb6cbaf"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">souffle::SparseDisjointSet::nodeExists</a></div><div class="ttdeci">bool nodeExists(const SparseDomain val) const</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00345">UnionFind.h:345</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a588e87898f4ee6c8c8a6be9f3a0e6892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588e87898f4ee6c8c8a6be9f3a0e6892">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check emptiness. </p>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00572">572</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                       {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keywordflow">return</span> this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">size</a>() == 0;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a555b07b774a103285669cca091c8dbdc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">souffle::EquivalenceRelation::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Size of relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00222">EquivalenceRelation.h:222</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a23d475db863fbcf356f7f4e8a2e54666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d475db863fbcf356f7f4e8a2e54666">&#9670;&nbsp;</a></span>emptyPartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::emptyPartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00195">195</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00209">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::clear()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00700">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::genAllDisjointSetLists()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00057">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::~EquivalenceRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                                {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="comment">// delete the beautiful values inside (they&#39;re raw ptrs, so they need to be.)</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; pair : <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keyword">delete</span> pair.second;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        }</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="comment">// invalidate it my dude</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>.store(<span class="keyword">true</span>, std::memory_order_relaxed);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        equivalencePartition.clear();</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_aa914456b63481b450a3f3979dac962dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">souffle::EquivalenceRelation::statesMapStale</a></div><div class="ttdeci">std::atomic&lt; bool &gt; statesMapStale</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00694">EquivalenceRelation.h:694</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a17ed88b84bb2364ad962d899352b69d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ed88b84bb2364ad962d899352b69d2">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterator pointing to the end of the tuples </p>
<dl class="section return"><dt>Returns</dt><dd>the iterator which represents the end of the binary rel </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00462">462</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00600">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::antpostit()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00491">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00530">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, <a class="el" href="binary__relation__test_8cpp_source.html#l00098">souffle::test::TEST()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00565">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::upper_bound()</a>.</p>
<div class="fragment"><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                         {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        <span class="keywordflow">return</span> iterator(<span class="keyword">this</span>, <span class="keyword">true</span>);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aeb23552f6468ff537022e84f0d12f09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb23552f6468ff537022e84f0d12f09e">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a>&lt; TupleType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend this relation with another relation, expanding this equivalence relation The supplied relation is the old knowledge, whilst this relation only contains explicitly new knowledge. </p>
<p>After this operation the "implicitly new tuples" are now explicitly inserted this relation. </p>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00136">136</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                                                             {</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="comment">// nothing to extend if there&#39;s no new/original knowledge</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">if</span> (other.size() == 0 || this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">size</a>() == 0) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        other.genAllDisjointSetLists();</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        std::set&lt;value_type&gt; repsCovered;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="comment">// find all the disjoint sets that need to be added to this relation</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="comment">// that exist in other (and exist in this)</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keyword">auto</span> it = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a13aaa70f222e10ea1e46906fc9589235">sparseToDenseMap</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#a54e0957231292b248c88e35e1c0aa35c">begin</a>();</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            <span class="keyword">auto</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a> = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a13aaa70f222e10ea1e46906fc9589235">sparseToDenseMap</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">end</a>();</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> el;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            <span class="keywordflow">for</span> (; it != <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>; ++it) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                std::tie(el, <a class="code" href="namespacetestutil.html#a033ee69d872bfbb8267de21ef642a357">std::ignore</a>) = *it;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="keywordflow">if</span> (other.containsElement(el)) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                    <a class="code" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> rep = other.sds.findNode(el);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                    <span class="keywordflow">if</span> (repsCovered.count(rep) == 0) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                        repsCovered.emplace(rep);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                    }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="comment">// add the intersecting dj sets into this one</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> el;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> rep;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            <span class="keyword">auto</span> it = other.sds.sparseToDenseMap.begin();</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keyword">auto</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a> = other.sds.sparseToDenseMap.end();</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="keywordflow">for</span> (; it != <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>; ++it) {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                std::tie(el, <a class="code" href="namespacetestutil.html#a033ee69d872bfbb8267de21ef642a357">std::ignore</a>) = *it;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                rep = other.sds.findNode(el);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                <span class="keywordflow">if</span> (repsCovered.count(rep) != 0) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                    this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">insert</a>(el, rep);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a60befefe2180d86a72de7de7c66296a4"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a60befefe2180d86a72de7de7c66296a4">souffle::detail::btree::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01705">BTree.h:1705</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a54e0957231292b248c88e35e1c0aa35c"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a54e0957231292b248c88e35e1c0aa35c">souffle::detail::btree::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01700">BTree.h:1700</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a436e869049ecd4f92c96576e47ceaf04"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">souffle::EquivalenceRelation::value_type</a></div><div class="ttdeci">typename TupleType::value_type value_type</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00043">EquivalenceRelation.h:43</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a555b07b774a103285669cca091c8dbdc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">souffle::EquivalenceRelation::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Size of relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00222">EquivalenceRelation.h:222</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
<div class="ttc" id="namespacetestutil_html_a033ee69d872bfbb8267de21ef642a357"><div class="ttname"><a href="namespacetestutil.html#a033ee69d872bfbb8267de21ef642a357">testutil::ignore</a></div><div class="ttdeci">void ignore(const T &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="test_8h_source.html#l00064">test.h:64</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a725decc989a5f638cf8780a68ebdb93c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">souffle::EquivalenceRelation::insert</a></div><div class="ttdeci">bool insert(value_type x, value_type y)</div><div class="ttdoc">Insert the two values symbolically as a binary relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00078">EquivalenceRelation.h:78</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a13aaa70f222e10ea1e46906fc9589235"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a13aaa70f222e10ea1e46906fc9589235">souffle::SparseDisjointSet::sparseToDenseMap</a></div><div class="ttdeci">SparseMap sparseToDenseMap</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00265">UnionFind.h:265</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f226e19af7060cfae7ba93d28ff6abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f226e19af7060cfae7ba93d28ff6abd">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00669">669</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00674">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::find()</a>.</p>
<div class="fragment"><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                                                            {</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;error: find() is not compatible with equivalence relations&quot;</span>);</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">begin</a>();</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a1d7f0c4be48aef1557027696c5509b7c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">souffle::EquivalenceRelation::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdoc">iterator pointing to the beginning of the tuples, with no restrictions </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00453">EquivalenceRelation.h:453</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a01dca800579ac4cc5e473755f9fc3f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dca800579ac4cc5e473755f9fc3f46">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00674">674</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                                            {</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        operation_hints context;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a8f226e19af7060cfae7ba93d28ff6abd">find</a>(t, context);</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a8f226e19af7060cfae7ba93d28ff6abd"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a8f226e19af7060cfae7ba93d28ff6abd">souffle::EquivalenceRelation::find</a></div><div class="ttdeci">iterator find(const TupleType &amp;, operation_hints &amp;) const</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00669">EquivalenceRelation.h:669</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af098f80e3fd13dbf9bab83353a442614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af098f80e3fd13dbf9bab83353a442614">&#9670;&nbsp;</a></span>genAllDisjointSetLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::genAllDisjointSetLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a cache of the sets such that they can be iterated over efficiently. </p>
<p>Each set is partitioned into a <a class="el" href="classsouffle_1_1_piggy_list.html">PiggyList</a>. </p>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00700">700</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00582">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::anteriorIt()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00600">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::antpostit()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00453">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::begin()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00618">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::closure()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00112">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insertAll()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00222">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                                        {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.lock();</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <span class="comment">// no need to generate again, already done.</span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>.load(std::memory_order_acquire)) {</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.unlock();</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;            <span class="keywordflow">return</span>;</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        }</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        <span class="comment">// btree version</span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">emptyPartition</a>();</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;        <span class="keywordtype">size_t</span> dSetSize = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a38df7250650f8abb1d35a1283f20857d">ds</a>.<a class="code" href="classsouffle_1_1_disjoint_set.html#a00d76a3b5206f029e27490239089e3b5">a_blocks</a>.<a class="code" href="classsouffle_1_1_piggy_list.html#a746c46251639906bcfcc16bbd113b0d8">size</a>();</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; dSetSize; ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            <span class="keyword">typename</span> TupleType::value_type sparseVal = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a3328569233309e4674a44bfd19457872">toSparse</a>(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            <a class="code" href="namespacesouffle.html#aa5cd00ed671edea5d1ddf34bf8260388">parent_t</a> rep = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">findNode</a>(sparseVal);</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a> <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a> = {rep, <span class="keyword">nullptr</span>};</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            <a class="code" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a>* mapList = <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1_lambda_b_tree.html#ae2bdf268075f277e992ad88646a7cda0">insert</a>(p, [&amp;](<a class="code" href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">StorePair</a>&amp; sp) {</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                <span class="keyword">auto</span>* r = <span class="keyword">new</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a>(1);</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                sp.second = r;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;            });</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            mapList-&gt;append(sparseVal);</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        }</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>.store(<span class="keyword">false</span>, std::memory_order_release);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.unlock();</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1_lambda_b_tree_html_ae2bdf268075f277e992ad88646a7cda0"><div class="ttname"><a href="classsouffle_1_1detail_1_1_lambda_b_tree.html#ae2bdf268075f277e992ad88646a7cda0">souffle::detail::LambdaBTree::insert</a></div><div class="ttdeci">Functor::result_type insert(Key &amp;k, const Functor &amp;f)</div><div class="ttdoc">Inserts the given key into this tree. </div><div class="ttdef"><b>Definition:</b> <a href="_lambda_b_tree_8h_source.html#l00060">LambdaBTree.h:60</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00662">json11.h:662</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a3328569233309e4674a44bfd19457872"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a3328569233309e4674a44bfd19457872">souffle::SparseDisjointSet::toSparse</a></div><div class="ttdeci">const SparseDomain toSparse(const parent_t in) const</div><div class="ttdoc">For the given dense value, return the associated sparse value Undefined behaviour if dense value not ...</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00308">UnionFind.h:308</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a23d475db863fbcf356f7f4e8a2e54666"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a23d475db863fbcf356f7f4e8a2e54666">souffle::EquivalenceRelation::emptyPartition</a></div><div class="ttdeci">void emptyPartition() const</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00195">EquivalenceRelation.h:195</a></div></div>
<div class="ttc" id="classsouffle_1_1_disjoint_set_html_a00d76a3b5206f029e27490239089e3b5"><div class="ttname"><a href="classsouffle_1_1_disjoint_set.html#a00d76a3b5206f029e27490239089e3b5">souffle::DisjointSet::a_blocks</a></div><div class="ttdeci">PiggyList&lt; std::atomic&lt; block_t &gt; &gt; a_blocks</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00052">UnionFind.h:52</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="classsouffle_1_1_piggy_list_html_a746c46251639906bcfcc16bbd113b0d8"><div class="ttname"><a href="classsouffle_1_1_piggy_list.html#a746c46251639906bcfcc16bbd113b0d8">souffle::PiggyList::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Well, returns the number of nodes exist within the list + number of nodes queued to be inserted The r...</div><div class="ttdef"><b>Definition:</b> <a href="_piggy_list_8h_source.html#l00178">PiggyList.h:178</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_abd1e9f67b7e370f9d21624429cdc55c1"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#abd1e9f67b7e370f9d21624429cdc55c1">souffle::SparseDisjointSet::findNode</a></div><div class="ttdeci">SparseDomain findNode(SparseDomain x)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00317">UnionFind.h:317</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a38df7250650f8abb1d35a1283f20857d"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a38df7250650f8abb1d35a1283f20857d">souffle::SparseDisjointSet::ds</a></div><div class="ttdeci">DisjointSet ds</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00253">UnionFind.h:253</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a46699abae586ff76589cf15b3bf87520"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">souffle::EquivalenceRelation::StatesList</a></div><div class="ttdeci">souffle::PiggyList&lt; value_type &gt; StatesList</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00047">EquivalenceRelation.h:47</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_ac2ffe1d9bf1a1fccd71795c7085ef6dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">souffle::EquivalenceRelation::statesLock</a></div><div class="ttdeci">std::shared_mutex statesLock</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00690">EquivalenceRelation.h:690</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_aa914456b63481b450a3f3979dac962dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">souffle::EquivalenceRelation::statesMapStale</a></div><div class="ttdeci">std::atomic&lt; bool &gt; statesMapStale</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00694">EquivalenceRelation.h:694</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a488232b36e1bacff97b19d948ea0354b"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a488232b36e1bacff97b19d948ea0354b">souffle::EquivalenceRelation::StorePair</a></div><div class="ttdeci">std::pair&lt; value_type, StatesBucket &gt; StorePair</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00049">EquivalenceRelation.h:49</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa5cd00ed671edea5d1ddf34bf8260388"><div class="ttname"><a href="namespacesouffle.html#aa5cd00ed671edea5d1ddf34bf8260388">souffle::parent_t</a></div><div class="ttdeci">uint64_t parent_t</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00035">UnionFind.h:35</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acdad96b7ba875be9bc72b84653035426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdad96b7ba875be9bc72b84653035426">&#9670;&nbsp;</a></span>getBoundaries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<div class="memtemplate">
template&lt;unsigned levels&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1range.html">range</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&gt; <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::getBoundaries </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a range of elements matching the prefix of the given entry up to levels elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">levels</td><td>the length of the requested matching prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the entry to be looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding range of matching elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00475">475</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="binary__relation__test_8cpp_source.html#l00384">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                                                                {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        operation_hints ctxt;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keywordflow">return</span> getBoundaries&lt;levels&gt;(entry, ctxt);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a180e142355bd6ea5be1677c1f19a9b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180e142355bd6ea5be1677c1f19a9b77">&#9670;&nbsp;</a></span>getBoundaries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<div class="memtemplate">
template&lt;unsigned levels&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1range.html">range</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&gt; <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::getBoundaries </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a range of elements matching the prefix of the given entry up to levels elements. </p>
<p>A operation context may be provided to exploit temporal locality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">levels</td><td>the length of the requested matching prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the entry to be looking for </td></tr>
    <tr><td class="paramname">ctxt</td><td>the operation context to be utilized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding range of matching elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00491">491</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                                                                                  {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="comment">// if nothing is bound =&gt; just use begin and end</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keywordflow">if</span> (levels == 0) <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">begin</a>(), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="comment">// as disjoint set is exactly two args (equiv relation)</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        <span class="comment">// we only need to handle these cases</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">if</span> (levels == 1) {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="comment">// need to test if the entry actually exists</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">nodeExists</a>(entry[0])) <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>(), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="comment">// return an iterator over all (entry[0], _)</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">anteriorIt</a>(entry[0]), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordflow">if</span> (levels == 2) {</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            <span class="comment">// need to test if the entry actually exists</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">contains</a>(entry[0], entry[1])) <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>(), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            <span class="comment">// if so return an iterator containing exactly that node</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a780aae54f493cbeee17db06f9166dd06">antpostit</a>(entry[0], entry[1]), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        }</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid state, cannot search for &gt;2 arg start point in getBoundaries, in 2 arg tuple &quot;</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                     <span class="stringliteral">&quot;store\n&quot;</span>;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">throw</span> <span class="stringliteral">&quot;invalid state, cannot search for &gt;2 arg start point in getBoundaries, in 2 arg tuple store&quot;</span>;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>(), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>());</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3b2110f260423ec60353ef2b23f38266"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">souffle::EquivalenceRelation::anteriorIt</a></div><div class="ttdeci">iterator anteriorIt(value_type anteriorVal) const</div><div class="ttdoc">Creates an iterator that generates all pairs (A, X) for a given A, and X are elements within A&amp;#39;s disj...</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00582">EquivalenceRelation.h:582</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_affb10cb03598014138ae497eadb6cbaf"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">souffle::SparseDisjointSet::nodeExists</a></div><div class="ttdeci">bool nodeExists(const SparseDomain val) const</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00345">UnionFind.h:345</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a1d7f0c4be48aef1557027696c5509b7c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">souffle::EquivalenceRelation::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdoc">iterator pointing to the beginning of the tuples, with no restrictions </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00453">EquivalenceRelation.h:453</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a56160b019e1d2ab013e2917422d141c7"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">souffle::SparseDisjointSet::contains</a></div><div class="ttdeci">bool contains(SparseDomain v1, SparseDomain v2)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00349">UnionFind.h:349</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="namespacesouffle_html_acea8a37cc1681f657054f3b30af55003"><div class="ttname"><a href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a></div><div class="ttdeci">range&lt; Iter &gt; make_range(const Iter &amp;a, const Iter &amp;b)</div><div class="ttdoc">A utility function enabling the construction of ranges without explicitly specifying the iterator typ...</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00383">ContainerUtil.h:383</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a780aae54f493cbeee17db06f9166dd06"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a780aae54f493cbeee17db06f9166dd06">souffle::EquivalenceRelation::antpostit</a></div><div class="ttdeci">iterator antpostit(value_type anteriorVal, value_type posteriorVal) const</div><div class="ttdoc">Creates an iterator that generates the pair (A, B) for a given A and B. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00600">EquivalenceRelation.h:600</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a725decc989a5f638cf8780a68ebdb93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725decc989a5f638cf8780a68ebdb93c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the two values symbolically as a binary relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>node to be added/paired </td></tr>
    <tr><td class="paramname">y</td><td>node to be added/paired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pair is new to the data structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00078">78</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00078">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insert()</a>, and <a class="el" href="binary__relation__test_8cpp_source.html#l00047">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                                            {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        operation_hints z;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">insert</a>(x, y, z);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    };</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a725decc989a5f638cf8780a68ebdb93c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">souffle::EquivalenceRelation::insert</a></div><div class="ttdeci">bool insert(value_type x, value_type y)</div><div class="ttdoc">Insert the two values symbolically as a binary relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00078">EquivalenceRelation.h:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a13b0659da55bb4acf41d3af5c3a81f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0659da55bb4acf41d3af5c3a81f83">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the tuple symbolically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>The tuple to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the tuple is new to the data structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00088">88</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                                        {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        operation_hints hints;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">insert</a>(tuple[0], tuple[1], hints);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    };</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a725decc989a5f638cf8780a68ebdb93c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a725decc989a5f638cf8780a68ebdb93c">souffle::EquivalenceRelation::insert</a></div><div class="ttdeci">bool insert(value_type x, value_type y)</div><div class="ttdoc">Insert the two values symbolically as a binary relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00078">EquivalenceRelation.h:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8882d09a61a8418b683b3c63c0aff10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8882d09a61a8418b683b3c63c0aff10">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the two values symbolically as a binary relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>node to be added/paired </td></tr>
    <tr><td class="paramname">y</td><td>node to be added/paired </td></tr>
    <tr><td class="paramname">z</td><td>the hints to where the pair should be inserted (not applicable atm) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pair is new to the data structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00100">100</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                                             {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="comment">// indicate that iterators will have to generate on request</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>.store(<span class="keyword">true</span>, std::memory_order_relaxed);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordtype">bool</span> retval = <a class="code" href="classsouffle_1_1_equivalence_relation.html#ad250eaaace5ec907cfdfeaf57d05957a">contains</a>(x, y);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a6ce935a6c3fd19d68ffc6d9f15da7c3d">unionNodes</a>(x, y);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">return</span> retval;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a6ce935a6c3fd19d68ffc6d9f15da7c3d"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a6ce935a6c3fd19d68ffc6d9f15da7c3d">souffle::SparseDisjointSet::unionNodes</a></div><div class="ttdeci">void unionNodes(SparseDomain x, SparseDomain y)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00321">UnionFind.h:321</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_aa914456b63481b450a3f3979dac962dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">souffle::EquivalenceRelation::statesMapStale</a></div><div class="ttdeci">std::atomic&lt; bool &gt; statesMapStale</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00694">EquivalenceRelation.h:694</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_ad250eaaace5ec907cfdfeaf57d05957a"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#ad250eaaace5ec907cfdfeaf57d05957a">souffle::EquivalenceRelation::contains</a></div><div class="ttdeci">bool contains(value_type x, value_type y) const</div><div class="ttdoc">Returns whether there exists a pair with these two nodes. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00183">EquivalenceRelation.h:183</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a49ff503b846eb60a89c3bc303db6f461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ff503b846eb60a89c3bc303db6f461">&#9670;&nbsp;</a></span>insertAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::insertAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a>&lt; TupleType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts all nodes from the other relation into this one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the binary relation from which to add elements from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00112">112</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                                                                {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        other.genAllDisjointSetLists();</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">// iterate over partitions at a time</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classsouffle_1_1detail_1_1btree.html#a0daa39344d1a9dec04052fcc53fa61e3">StatesMap::chunk</a> it : other.equivalencePartition.getChunks(<a class="code" href="_parallel_util_8h.html#a8b5173357adb02a86c027316e0acdfa0">MAX_THREADS</a>)) {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a> : it) {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                <a class="code" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a> rep = <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>.first;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                <a class="code" href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">StatesList</a>&amp; pl = *<a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>.second;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">size_t</span> ksize = pl.size();</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; ksize; ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                    this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a6ce935a6c3fd19d68ffc6d9f15da7c3d">unionNodes</a>(rep, pl.get(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>));</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        }</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="comment">// invalidate iterators unconditionally</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">statesMapStale</a>.store(<span class="keyword">true</span>, std::memory_order_relaxed);</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a436e869049ecd4f92c96576e47ceaf04"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">souffle::EquivalenceRelation::value_type</a></div><div class="ttdeci">typename TupleType::value_type value_type</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00043">EquivalenceRelation.h:43</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00662">json11.h:662</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a0daa39344d1a9dec04052fcc53fa61e3"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a0daa39344d1a9dec04052fcc53fa61e3">souffle::detail::btree&lt; StorePair, souffle::EqrelMapComparator&lt; StorePair &gt;, std::allocator&lt; StorePair &gt;, blockSize, typename detail::default_strategy&lt; StorePair &gt;::type, isSet, souffle::EqrelMapComparator&lt; StorePair &gt;, detail::updater&lt; StorePair &gt; &gt;::chunk</a></div><div class="ttdeci">range&lt; iterator &gt; chunk</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l00258">BTree.h:258</a></div></div>
<div class="ttc" id="_parallel_util_8h_html_a8b5173357adb02a86c027316e0acdfa0"><div class="ttname"><a href="_parallel_util_8h.html#a8b5173357adb02a86c027316e0acdfa0">MAX_THREADS</a></div><div class="ttdeci">#define MAX_THREADS</div><div class="ttdef"><b>Definition:</b> <a href="_parallel_util_8h_source.html#l00098">ParallelUtil.h:98</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a46699abae586ff76589cf15b3bf87520"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a46699abae586ff76589cf15b3bf87520">souffle::EquivalenceRelation::StatesList</a></div><div class="ttdeci">souffle::PiggyList&lt; value_type &gt; StatesList</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00047">EquivalenceRelation.h:47</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a6ce935a6c3fd19d68ffc6d9f15da7c3d"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a6ce935a6c3fd19d68ffc6d9f15da7c3d">souffle::SparseDisjointSet::unionNodes</a></div><div class="ttdeci">void unionNodes(SparseDomain x, SparseDomain y)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00321">UnionFind.h:321</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_aa914456b63481b450a3f3979dac962dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#aa914456b63481b450a3f3979dac962dc">souffle::EquivalenceRelation::statesMapStale</a></div><div class="ttdeci">std::atomic&lt; bool &gt; statesMapStale</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00694">EquivalenceRelation.h:694</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6da4edbc62be51b13156fde774d9a771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da4edbc62be51b13156fde774d9a771">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Act similar to getBoundaries. </p>
<p>But non-static. This function should be used ONLY by interpreter, and its behavior is tightly coupling with <a class="el" href="classsouffle_1_1_interpreter_index.html" title="An index is an abstraction of a data structure. ">InterpreterIndex</a>. Do Not rely on this interface outside the interpreter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the entry to be looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding range of matching elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00530">530</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                                                         {</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <span class="keywordflow">if</span> (entry[0] == <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a> &amp;&amp; entry[1] == <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a>) {</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            <span class="comment">// Return an iterator over all tuples.</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">begin</a>();</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        }</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <span class="keywordflow">if</span> (entry[0] != <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a> &amp;&amp; entry[1] == <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a>) {</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            <span class="comment">// Return an iterator over all (entry[0], _)</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">nodeExists</a>(entry[0])) {</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>();</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            }</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">anteriorIt</a>(entry[0]);</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        }</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="keywordflow">if</span> (entry[0] != <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a> &amp;&amp; entry[1] != <a class="code" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a>) {</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="comment">// Return an iterator point to the exact same node.</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">sds</a>.<a class="code" href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">contains</a>(entry[0], entry[1])) {</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>();</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;            }</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a780aae54f493cbeee17db06f9166dd06">antpostit</a>(entry[0], entry[1]);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>();</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3b2110f260423ec60353ef2b23f38266"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">souffle::EquivalenceRelation::anteriorIt</a></div><div class="ttdeci">iterator anteriorIt(value_type anteriorVal) const</div><div class="ttdoc">Creates an iterator that generates all pairs (A, X) for a given A, and X are elements within A&amp;#39;s disj...</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00582">EquivalenceRelation.h:582</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_affb10cb03598014138ae497eadb6cbaf"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#affb10cb03598014138ae497eadb6cbaf">souffle::SparseDisjointSet::nodeExists</a></div><div class="ttdeci">bool nodeExists(const SparseDomain val) const</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00345">UnionFind.h:345</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a1d7f0c4be48aef1557027696c5509b7c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">souffle::EquivalenceRelation::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdoc">iterator pointing to the beginning of the tuples, with no restrictions </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00453">EquivalenceRelation.h:453</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab108e1ed3dc35638e9432fba35831c99"><div class="ttname"><a href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">souffle::MIN_RAM_SIGNED</a></div><div class="ttdeci">constexpr RamSigned MIN_RAM_SIGNED</div><div class="ttdoc">lower and upper boundaries for the ram types </div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00102">RamTypes.h:102</a></div></div>
<div class="ttc" id="classsouffle_1_1_sparse_disjoint_set_html_a56160b019e1d2ab013e2917422d141c7"><div class="ttname"><a href="classsouffle_1_1_sparse_disjoint_set.html#a56160b019e1d2ab013e2917422d141c7">souffle::SparseDisjointSet::contains</a></div><div class="ttdeci">bool contains(SparseDomain v1, SparseDomain v2)</div><div class="ttdef"><b>Definition:</b> <a href="_union_find_8h_source.html#l00349">UnionFind.h:349</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3759a97afd524c6b08662740ccb33138"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3759a97afd524c6b08662740ccb33138">souffle::EquivalenceRelation::sds</a></div><div class="ttdeci">souffle::SparseDisjointSet&lt; value_type &gt; sds</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00687">EquivalenceRelation.h:687</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a780aae54f493cbeee17db06f9166dd06"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a780aae54f493cbeee17db06f9166dd06">souffle::EquivalenceRelation::antpostit</a></div><div class="ttdeci">iterator antpostit(value_type anteriorVal, value_type posteriorVal) const</div><div class="ttdoc">Creates an iterator that generates the pair (A, B) for a given A and B. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00600">EquivalenceRelation.h:600</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3fbff12268dd7701a161a5cfe05d47d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbff12268dd7701a161a5cfe05d47d6">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structsouffle_1_1range.html">souffle::range</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a>&gt; &gt; <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an approximate number of iterators for parallel iteration The iterators returned are not necessarily equal in size, but in practise are approximately similarly sized Depending on the structure of the data, there can be more or less partitions returned than requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunks</td><td>the number of requested partitions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of the iterators as ranges </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00634">634</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="binary__relation__test_8cpp_source.html#l00483">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                                                                     {</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        <span class="comment">// generate all reps</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <span class="keywordtype">size_t</span> numPairs = this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">size</a>();</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        <span class="keywordflow">if</span> (numPairs == 0) <span class="keywordflow">return</span> {};</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">if</span> (numPairs == 1 || chunks &lt;= 1) <span class="keywordflow">return</span> {<a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">begin</a>(), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>())};</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="comment">// if there&#39;s more dj sets than requested chunks, then just return an iter per dj set</span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        std::vector&lt;souffle::range&lt;iterator&gt;&gt; ret;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        <span class="keywordflow">if</span> (chunks &lt;= <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>.<a class="code" href="classsouffle_1_1detail_1_1btree.html#a94faf32f8ee0537781512397d9bb442d">size</a>()) {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a> : <a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>) {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                ret.push_back(<a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a8099eb6b5846ccf01168eb1a82342003">closure</a>(<a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>.first), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>()));</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            }</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        }</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="comment">// keep it simple stupid</span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        <span class="comment">// just go through and if the size of the binrel is &gt; numpairs/chunks, then generate an anteriorIt for</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        <span class="comment">// each</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> perchunk = numPairs / chunks;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; itp : equivalencePartition) {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> s = itp.second-&gt;size();</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            <span class="keywordflow">if</span> (s * s &gt; perchunk) {</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : *itp.second) {</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                    ret.push_back(<a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">anteriorIt</a>(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>()));</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                ret.push_back(<a class="code" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a>(<a class="code" href="classsouffle_1_1_equivalence_relation.html#a8099eb6b5846ccf01168eb1a82342003">closure</a>(itp.first), <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>()));</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            }</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        }</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a3b2110f260423ec60353ef2b23f38266"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a3b2110f260423ec60353ef2b23f38266">souffle::EquivalenceRelation::anteriorIt</a></div><div class="ttdeci">iterator anteriorIt(value_type anteriorVal) const</div><div class="ttdoc">Creates an iterator that generates all pairs (A, X) for a given A, and X are elements within A&amp;#39;s disj...</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00582">EquivalenceRelation.h:582</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a1d7f0c4be48aef1557027696c5509b7c"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a1d7f0c4be48aef1557027696c5509b7c">souffle::EquivalenceRelation::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdoc">iterator pointing to the beginning of the tuples, with no restrictions </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00453">EquivalenceRelation.h:453</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00662">json11.h:662</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1btree_html_a94faf32f8ee0537781512397d9bb442d"><div class="ttname"><a href="classsouffle_1_1detail_1_1btree.html#a94faf32f8ee0537781512397d9bb442d">souffle::detail::btree::size</a></div><div class="ttdeci">size_type size() const</div><div class="ttdef"><b>Definition:</b> <a href="_b_tree_8h_source.html#l01297">BTree.h:1297</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a8099eb6b5846ccf01168eb1a82342003"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a8099eb6b5846ccf01168eb1a82342003">souffle::EquivalenceRelation::closure</a></div><div class="ttdeci">iterator closure(value_type rep) const</div><div class="ttdoc">Begin an iterator over all pairs within a single disjoint set - This is used for partition(). </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00618">EquivalenceRelation.h:618</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_acea8a37cc1681f657054f3b30af55003"><div class="ttname"><a href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a></div><div class="ttdeci">range&lt; Iter &gt; make_range(const Iter &amp;a, const Iter &amp;b)</div><div class="ttdoc">A utility function enabling the construction of ranges without explicitly specifying the iterator typ...</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00383">ContainerUtil.h:383</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a555b07b774a103285669cca091c8dbdc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a555b07b774a103285669cca091c8dbdc">souffle::EquivalenceRelation::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Size of relation. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00222">EquivalenceRelation.h:222</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a555b07b774a103285669cca091c8dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555b07b774a103285669cca091c8dbdc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of relation. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the number of pairs per disjoint set </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00222">222</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00572">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::empty()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, and <a class="el" href="binary__relation__test_8cpp_source.html#l00047">souffle::test::TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                        {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">genAllDisjointSetLists</a>();</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.lock_shared();</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keywordtype">size_t</span> retVal = 0;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a> : this-&gt;<a class="code" href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">equivalencePartition</a>) {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> s = <a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a>.second-&gt;size();</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            retVal += s * s;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <a class="code" href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">statesLock</a>.unlock_shared();</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a930683e4395ebc703c21f9fba49be069"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a930683e4395ebc703c21f9fba49be069">souffle::EquivalenceRelation::equivalencePartition</a></div><div class="ttdeci">StatesMap equivalencePartition</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00692">EquivalenceRelation.h:692</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_af6814cb38d86f56d30772f562eaee28e"><div class="ttname"><a href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter e</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_af098f80e3fd13dbf9bab83353a442614"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#af098f80e3fd13dbf9bab83353a442614">souffle::EquivalenceRelation::genAllDisjointSetLists</a></div><div class="ttdeci">void genAllDisjointSetLists() const</div><div class="ttdoc">Generate a cache of the sets such that they can be iterated over efficiently. </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00700">EquivalenceRelation.h:700</a></div></div>
<div class="ttc" id="classsouffle_1_1_equivalence_relation_html_ac2ffe1d9bf1a1fccd71795c7085ef6dc"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#ac2ffe1d9bf1a1fccd71795c7085ef6dc">souffle::EquivalenceRelation::statesLock</a></div><div class="ttdeci">std::shared_mutex statesLock</div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00690">EquivalenceRelation.h:690</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a116e1fea52d021460197a9629822e33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e1fea52d021460197a9629822e33f">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation_1_1iterator.html">iterator</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const TupleType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_equivalence_relation_1_1operation__hints.html">operation_hints</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is only here in order to unify interfaces in <a class="el" href="classsouffle_1_1_interpreter_index.html" title="An index is an abstraction of a data structure. ">InterpreterIndex</a>. </p>
<p>Unlike the name suggestes, it omit the arguments and simply return the end iterator of the relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omitted</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00565">565</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;                                                                   {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">end</a>();</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    }</div><div class="ttc" id="classsouffle_1_1_equivalence_relation_html_a17ed88b84bb2364ad962d899352b69d2"><div class="ttname"><a href="classsouffle_1_1_equivalence_relation.html#a17ed88b84bb2364ad962d899352b69d2">souffle::EquivalenceRelation::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdoc">iterator pointing to the end of the tuples </div><div class="ttdef"><b>Definition:</b> <a href="_equivalence_relation_8h_source.html#l00462">EquivalenceRelation.h:462</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a930683e4395ebc703c21f9fba49be069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930683e4395ebc703c21f9fba49be069">&#9670;&nbsp;</a></span>equivalencePartition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_equivalence_relation.html#a11f4d1f2f7cb7ec1d1e2afa9e0f7e325">StatesMap</a> <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::equivalencePartition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00692">692</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00582">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::anteriorIt()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00600">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::antpostit()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00618">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::closure()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00195">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::emptyPartition()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00112">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insertAll()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00634">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00222">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::size()</a>.</p>

</div>
</div>
<a id="a3759a97afd524c6b08662740ccb33138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3759a97afd524c6b08662740ccb33138">&#9670;&nbsp;</a></span>sds</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_sparse_disjoint_set.html">souffle::SparseDisjointSet</a>&lt;<a class="el" href="classsouffle_1_1_equivalence_relation.html#a436e869049ecd4f92c96576e47ceaf04">value_type</a>&gt; <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::sds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00687">687</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00582">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::anteriorIt()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00600">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::antpostit()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00209">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::clear()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00618">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::closure()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00183">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::contains()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00680">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::containsElement()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00136">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::extend()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00491">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00100">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insert()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00112">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insertAll()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00530">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>.</p>

</div>
</div>
<a id="ac2ffe1d9bf1a1fccd71795c7085ef6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ffe1d9bf1a1fccd71795c7085ef6dc">&#9670;&nbsp;</a></span>statesLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_mutex <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::statesLock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00690">690</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00209">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::clear()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00222">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::size()</a>.</p>

</div>
</div>
<a id="aa914456b63481b450a3f3979dac962dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa914456b63481b450a3f3979dac962dc">&#9670;&nbsp;</a></span>statesMapStale</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; <a class="el" href="classsouffle_1_1_equivalence_relation.html">souffle::EquivalenceRelation</a>&lt; TupleType &gt;::statesMapStale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_equivalence_relation_8h_source.html#l00694">694</a> of file <a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00195">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::emptyPartition()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00100">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insert()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00112">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::insertAll()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_equivalence_relation_8h_source.html">EquivalenceRelation.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
